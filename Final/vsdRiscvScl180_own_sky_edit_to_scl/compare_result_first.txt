diff -ry rtl/buff_flash_clkrst.v verilog/rtl/buff_flash_clkrst.v
module buff_flash_clkrst (					module buff_flash_clkrst (
	`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
		inout VPWR,							inout VPWR,
		inout VGND,							inout VGND,
	`endif								`endif
	input[11:0] in_n, 						input[11:0] in_n, 
	input[2:0] in_s, 						input[2:0] in_s, 
	output[11:0] out_s, 						output[11:0] out_s, 
	output[2:0] out_n);						output[2:0] out_n);

	sky130_fd_sc_hd__clkbuf_8 BUF[14:0] (				sky130_fd_sc_hd__clkbuf_8 BUF[14:0] (
		`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
			.VGND(VGND),							.VGND(VGND),
			.VNB(VGND),							.VNB(VGND),
			.VPB(VPWR),							.VPB(VPWR),
			.VPWR(VPWR),							.VPWR(VPWR),
		`endif								`endif
		.A({in_n, in_s}), 						.A({in_n, in_s}), 
		.X({out_s, out_n})); 						.X({out_s, out_n})); 

endmodule							endmoduleOnly in verilog/rtl: caravan_core.v
Only in verilog/rtl: caravan_logo.v
Only in verilog/rtl: caravan_motto.v
Only in verilog/rtl: caravan_netlists.v
Only in verilog/rtl: caravan_openframe.v
Only in verilog/rtl: caravan_power_routing.v
Only in verilog/rtl: caravan.v
diff -ry rtl/caravel_clocking.v verilog/rtl/caravel_clocking.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
// This routine synchronizes the 				// This routine synchronizes the 

module caravel_clocking(					module caravel_clocking(
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
    input VPWR,							    input VPWR,
    input VGND,							    input VGND,
`endif */						      |	`endif
    input porb,		// Master (negative sense) reset from	    input porb,		// Master (negative sense) reset from
    input resetb, 	// Master (negative sense) reset	    input resetb, 	// Master (negative sense) reset
    input ext_clk_sel,	// 0=use PLL clock, 1=use external (p	    input ext_clk_sel,	// 0=use PLL clock, 1=use external (p
    input ext_clk,	// External pad (slow) clock		    input ext_clk,	// External pad (slow) clock
    input pll_clk,	// Internal PLL (fast) clock		    input pll_clk,	// Internal PLL (fast) clock
    input pll_clk90,	// Internal PLL (fast) clock, 90 degr	    input pll_clk90,	// Internal PLL (fast) clock, 90 degr
    input [2:0] sel,	// Select clock divider value (0=thru	    input [2:0] sel,	// Select clock divider value (0=thru
    input [2:0] sel2,	// Select clock divider value for 90 	    input [2:0] sel2,	// Select clock divider value for 90 
    input ext_reset,	// Positive sense reset from housekee	    input ext_reset,	// Positive sense reset from housekee
    output core_clk,	// Output core clock			    output core_clk,	// Output core clock
    output user_clk,	// Output user (secondary) clock	    output user_clk,	// Output user (secondary) clock
    output resetb_sync	// Output propagated and buffered res	    output resetb_sync	// Output propagated and buffered res
);								);

    wire pll_clk_sel;						    wire pll_clk_sel;
    wire pll_clk_divided;					    wire pll_clk_divided;
    wire pll_clk90_divided;					    wire pll_clk90_divided;
    wire core_ext_clk;						    wire core_ext_clk;
    reg  use_pll_first;						    reg  use_pll_first;
    reg  use_pll_second;					    reg  use_pll_second;
    reg	 ext_clk_syncd_pre;					    reg	 ext_clk_syncd_pre;
    reg	 ext_clk_syncd;						    reg	 ext_clk_syncd;

    wire resetb_async;						    wire resetb_async;

    assign pll_clk_sel = ~ext_clk_sel;				    assign pll_clk_sel = ~ext_clk_sel;

    assign resetb_async = porb & resetb & (!ext_reset);		    assign resetb_async = porb & resetb & (!ext_reset);
    // Note that this implementation does not guard against s	    // Note that this implementation does not guard against s
    // the PLL clock if the PLL clock is not present.		    // the PLL clock if the PLL clock is not present.

    always @(posedge pll_clk or negedge resetb_async) begin	    always @(posedge pll_clk or negedge resetb_async) begin
	if (resetb_async == 1'b0) begin					if (resetb_async == 1'b0) begin
	    use_pll_first <= 1'b0;					    use_pll_first <= 1'b0;
	    use_pll_second <= 1'b0;					    use_pll_second <= 1'b0;
	    ext_clk_syncd <= 1'b0;					    ext_clk_syncd <= 1'b0;
	end else begin							end else begin
	    use_pll_first <= pll_clk_sel;				    use_pll_first <= pll_clk_sel;
	    use_pll_second <= use_pll_first;				    use_pll_second <= use_pll_first;
	    ext_clk_syncd_pre <= ext_clk;	// Sync ext_c		    ext_clk_syncd_pre <= ext_clk;	// Sync ext_c
	    ext_clk_syncd <= ext_clk_syncd_pre;	// Do this tw		    ext_clk_syncd <= ext_clk_syncd_pre;	// Do this tw
	end								end
    end								    end

    // Apply PLL clock divider					    // Apply PLL clock divider

    clock_div #(						    clock_div #(
	.SIZE(3)							.SIZE(3)
    ) divider (							    ) divider (
	.in(pll_clk),							.in(pll_clk),
	.out(pll_clk_divided),						.out(pll_clk_divided),
	.N(sel),							.N(sel),
	.resetb(resetb_async)						.resetb(resetb_async)
    ); 								    ); 

    // Secondary PLL clock divider for user space access	    // Secondary PLL clock divider for user space access

    clock_div #(						    clock_div #(
	.SIZE(3)							.SIZE(3)
    ) divider2 (						    ) divider2 (
	.in(pll_clk90),							.in(pll_clk90),
	.out(pll_clk90_divided),					.out(pll_clk90_divided),
	.N(sel2),							.N(sel2),
	.resetb(resetb_async)						.resetb(resetb_async)
    ); 								    ); 


    // Multiplex the clock output				    // Multiplex the clock output

    assign core_ext_clk = (use_pll_first) ? ext_clk_syncd : e	    assign core_ext_clk = (use_pll_first) ? ext_clk_syncd : e
    assign core_clk = (use_pll_second) ? pll_clk_divided : co	    assign core_clk = (use_pll_second) ? pll_clk_divided : co
    assign user_clk = (use_pll_second) ? pll_clk90_divided : 	    assign user_clk = (use_pll_second) ? pll_clk90_divided : 

    // Reset assignment.  "reset" comes from POR, while "ext_	    // Reset assignment.  "reset" comes from POR, while "ext_
    // comes from standalone SPI (and is normally zero unless	    // comes from standalone SPI (and is normally zero unless
    // activated from the SPI).					    // activated from the SPI).

    // Staged-delay reset					    // Staged-delay reset
    reg [2:0] reset_delay;					    reg [2:0] reset_delay;

    always @(negedge core_clk or negedge resetb_async) begin	    always @(negedge core_clk or negedge resetb_async) begin
        if (resetb_async == 1'b0) begin				        if (resetb_async == 1'b0) begin
        reset_delay <= 3'b111;					        reset_delay <= 3'b111;
        end else begin						        end else begin
        reset_delay <= {1'b0, reset_delay[2:1]};		        reset_delay <= {1'b0, reset_delay[2:1]};
        end							        end
    end								    end

    assign resetb_sync = ~reset_delay[0];			    assign resetb_sync = ~reset_delay[0];

endmodule							endmodule
`default_nettype wire						`default_nettype wire
diff -ry rtl/caravel_core.v verilog/rtl/caravel_core.v
							      |	 `ifdef SIM
 `default_nettype wire						 `default_nettype wire
 							      |	 `endif
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

/*----------------------------------------------------------- |	/*-----------------------------------------------------------
/* Vsdcaravel, RISC-V SoC Implementation using Synopsys and S |	/* caravel, a project harness for the Google/SkyWater sky130
/* a project for the VSD/Semiconductor Laboratory SCL180      |	/* fabrication process and open source PDK		
/* fabrication process 			                      |	/*                                                          
/*                                                            |	/* Copyright 2020 efabless, Inc.                            
/* Copyright 2025 efabless, Inc. /VSD                         |	/* Written by Tim Edwards, December 2019                    
/* Originally written by Tim Edwards, December 2019           |	/* and Mohamed Shalan, August 2020			    
/* and Mohamed Shalan, August 2020			      |	/* This file is open source hardware released under the     
/* Edited by Dhanvanti Bhavsar and Kunal Ghosh on (11/02/2025 |	/* Apache 2.0 license.  See file LICENSE.                   
/* Updated on 11/02/2025:  Revised using SCL180 PDK	      |	/*							
/* This file is open source hardware released under the       |	/* Updated 10/15/2021:  Revised using the housekeeping module
/* Apache 2.0 license.  See file LICENSE.                     |	/* from housekeeping.v (refactoring a number of functions fro
/* from housekeeping.v (refactoring a number of functions fro |	/* the management SoC).					
/* the management SoC).					      |	/*                                                          
/*                                                            |	/*-----------------------------------------------------------
/*----------------------------------------------------------- |
							      >
							      >	//Include by Ritesh Balaji S
							      >
							      >

`include "mprj_io_buffer.v"					`include "mprj_io_buffer.v"
`include "manual_power_connections.v"			      <
`include "empty_macro.v"					`include "empty_macro.v"
							      >	`include "manual_power_connections.v"
							      >	//`include "gpio_defaults_block.v"
							      >
							      >	//`include "housekeeping.v"
							      >	//`include "defines.v"
							      >	//`include "user_defines.v"
							      >	//`include "spare_logic_block.v"
							      >
							      >

module caravel_core (						module caravel_core (
    // All top-level I/O are package-facing pins		    // All top-level I/O are package-facing pins
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    inout vddio,  // Common 3.3V padframe/ESD power		    inout vddio,  // Common 3.3V padframe/ESD power
    inout vssio,  // Common padframe/ESD ground			    inout vssio,  // Common padframe/ESD ground
    inout vdda,   // Management 3.3V power			    inout vdda,   // Management 3.3V power
    inout vssa,   // Common analog ground			    inout vssa,   // Common analog ground
    inout vccd,   // Management/Common 1.8V power		    inout vccd,   // Management/Common 1.8V power
    inout vssd,   // Common digital ground			    inout vssd,   // Common digital ground
    inout vdda1,  // User area 1 3.3V power			    inout vdda1,  // User area 1 3.3V power
    inout vdda2,  // User area 2 3.3V power			    inout vdda2,  // User area 2 3.3V power
    inout vssa1,  // User area 1 analog ground			    inout vssa1,  // User area 1 analog ground
    inout vssa2,  // User area 2 analog ground			    inout vssa2,  // User area 2 analog ground
    inout vccd1,  // User area 1 1.8V power			    inout vccd1,  // User area 1 1.8V power
    inout vccd2,  // User area 2 1.8V power			    inout vccd2,  // User area 2 1.8V power
    inout vssd1,  // User area 1 digital ground			    inout vssd1,  // User area 1 digital ground
    inout vssd2,  // User area 2 digital ground			    inout vssd2,  // User area 2 digital ground	
`endif								`endif

    // SoC Core Interface					    // SoC Core Interface
    output porb_h,						    output porb_h,
    output por_l,						    output por_l,
    input  reset_n,					      |	    input  rstb_h,
    inout  rstb_h,					      <
    input  clock_core,						    input  clock_core,
    output gpio_out_core,					    output gpio_out_core,
    input  gpio_in_core,					    input  gpio_in_core,
    output gpio_mode0_core,					    output gpio_mode0_core,
    output gpio_mode1_core,					    output gpio_mode1_core,
    output gpio_outenb_core,					    output gpio_outenb_core,
    output gpio_inenb_core,					    output gpio_inenb_core,

    // Flash SPI communication					    // Flash SPI communication
    output flash_csb_frame,					    output flash_csb_frame,
    output flash_clk_frame,					    output flash_clk_frame,
    output flash_csb_oeb,					    output flash_csb_oeb,
    output flash_clk_oeb,					    output flash_clk_oeb,
    output flash_io0_oeb,					    output flash_io0_oeb,
    output flash_io1_oeb,					    output flash_io1_oeb,
    output flash_io0_ieb,					    output flash_io0_ieb,
    output flash_io1_ieb,					    output flash_io1_ieb,
    output flash_io0_do,					    output flash_io0_do,
    output flash_io1_do,					    output flash_io1_do,
    input  flash_io0_di,					    input  flash_io0_di,
    input  flash_io1_di,					    input  flash_io1_di,

    // User project IOs						    // User project IOs
    input  [  `MPRJ_IO_PADS-1:0] mprj_io_in,			    input  [  `MPRJ_IO_PADS-1:0] mprj_io_in,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_out,			    output [  `MPRJ_IO_PADS-1:0] mprj_io_out,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_oeb,			    output [  `MPRJ_IO_PADS-1:0] mprj_io_oeb,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_inp_dis,		    output [  `MPRJ_IO_PADS-1:0] mprj_io_inp_dis,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_ib_mode_sel,		    output [  `MPRJ_IO_PADS-1:0] mprj_io_ib_mode_sel,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_vtrip_sel,		    output [  `MPRJ_IO_PADS-1:0] mprj_io_vtrip_sel,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_slow_sel,		    output [  `MPRJ_IO_PADS-1:0] mprj_io_slow_sel,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_holdover,		    output [  `MPRJ_IO_PADS-1:0] mprj_io_holdover,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_analog_en,		    output [  `MPRJ_IO_PADS-1:0] mprj_io_analog_en,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_analog_sel,		    output [  `MPRJ_IO_PADS-1:0] mprj_io_analog_sel,
    output [  `MPRJ_IO_PADS-1:0] mprj_io_analog_pol,		    output [  `MPRJ_IO_PADS-1:0] mprj_io_analog_pol,
    output [`MPRJ_IO_PADS*3-1:0] mprj_io_dm,			    output [`MPRJ_IO_PADS*3-1:0] mprj_io_dm,

    // Loopbacks to constant value 1 in the 1.8V domain		    // Loopbacks to constant value 1 in the 1.8V domain
    output [`MPRJ_IO_PADS-1:0] mprj_io_one,			    output [`MPRJ_IO_PADS-1:0] mprj_io_one,

    // User project direct access to gpio pad connections for	    // User project direct access to gpio pad connections for
    // (all but the lowest-numbered 7 pads)			    // (all but the lowest-numbered 7 pads)
    inout [`MPRJ_IO_PADS-10:0] mprj_analog_io			    inout [`MPRJ_IO_PADS-10:0] mprj_analog_io
);								);

    //-------------------------------------------------------	    //-------------------------------------------------------
    // This value is uniquely defined for each user project.	    // This value is uniquely defined for each user project.
    //-------------------------------------------------------	    //-------------------------------------------------------
    parameter USER_PROJECT_ID = 32'h00000000;			    parameter USER_PROJECT_ID = 32'h00000000;

    /*								    /*
     *-------------------------------------------------------	     *-------------------------------------------------------
     *								     *
     * These pins are overlaid on mprj_io space.  They have t	     * These pins are overlaid on mprj_io space.  They have t
     * below when the management processor is in reset, or in	     * below when the management processor is in reset, or in
     * configuration.  They are assigned to uses in the user 	     * configuration.  They are assigned to uses in the user 
     * configuration program running off of the SPI flash.  N	     * configuration program running off of the SPI flash.  N
     * when the user has taken control of these pins, they ca	     * when the user has taken control of these pins, they ca
     * to the original use by setting the resetb pin low.  Th	     * to the original use by setting the resetb pin low.  Th
     * UART pins can be connected directly to an FTDI chip as	     * UART pins can be connected directly to an FTDI chip as
     * FTDI chip sets these lines to high impedence (input fu	     * FTDI chip sets these lines to high impedence (input fu
     * all times except when holding the chip in reset.		     * all times except when holding the chip in reset.
     *								     *
     * JTAG       = mprj_io[0]		(inout)			     * JTAG       = mprj_io[0]		(inout)
     * SDO 	  = mprj_io[1]		(output)		     * SDO 	  = mprj_io[1]		(output)
     * SDI 	  = mprj_io[2]		(input)			     * SDI 	  = mprj_io[2]		(input)
     * CSB 	  = mprj_io[3]		(input)			     * CSB 	  = mprj_io[3]		(input)
     * SCK	  = mprj_io[4]		(input)			     * SCK	  = mprj_io[4]		(input)
     * ser_rx     = mprj_io[5]		(input)			     * ser_rx     = mprj_io[5]		(input)
     * ser_tx     = mprj_io[6]		(output)		     * ser_tx     = mprj_io[6]		(output)
     * irq 	  = mprj_io[7]		(input)			     * irq 	  = mprj_io[7]		(input)
     *								     *
     * spi_sck    = mprj_io[32]		(output)		     * spi_sck    = mprj_io[32]		(output)
     * spi_csb    = mprj_io[33]		(output)		     * spi_csb    = mprj_io[33]		(output)
     * spi_sdi    = mprj_io[34]		(input)			     * spi_sdi    = mprj_io[34]		(input)
     * spi_sdo    = mprj_io[35]		(output)		     * spi_sdo    = mprj_io[35]		(output)
     * flash_io2  = mprj_io[36]		(inout) 		     * flash_io2  = mprj_io[36]		(inout) 
     * flash_io3  = mprj_io[37]		(inout) 		     * flash_io3  = mprj_io[37]		(inout) 
     *								     *
     * These pins are reserved for any project that wants to 	     * These pins are reserved for any project that wants to 
     * its own processor and flash controller.  While a user 	     * its own processor and flash controller.  While a user 
     * technically use any available I/O pins for the purpose	     * technically use any available I/O pins for the purpose
     * four pins connect to a pass-through mode from the SPI 	     * four pins connect to a pass-through mode from the SPI 
     * 1-4 above) so that any SPI flash connected to these sp	     * 1-4 above) so that any SPI flash connected to these sp
     * can be accessed through the SPI slave even when the pr	     * can be accessed through the SPI slave even when the pr
     * reset.							     * reset.
     *								     *
     * user_flash_csb = mprj_io[8]				     * user_flash_csb = mprj_io[8]
     * user_flash_sck = mprj_io[9]				     * user_flash_sck = mprj_io[9]
     * user_flash_io0 = mprj_io[10]				     * user_flash_io0 = mprj_io[10]
     * user_flash_io1 = mprj_io[11]				     * user_flash_io1 = mprj_io[11]
     *								     *
     *-------------------------------------------------------	     *-------------------------------------------------------
     */								     */


    // User Project Control (user-facing)			    // User Project Control (user-facing)
    wire [`MPRJ_IO_PADS-1:0] user_io_oeb;			    wire [`MPRJ_IO_PADS-1:0] user_io_oeb;
    wire [`MPRJ_IO_PADS-1:0] user_io_in;			    wire [`MPRJ_IO_PADS-1:0] user_io_in;
    wire [`MPRJ_IO_PADS-1:0] user_io_out;			    wire [`MPRJ_IO_PADS-1:0] user_io_out;

    /* Padframe control signals */				    /* Padframe control signals */
    wire [`MPRJ_IO_PADS_1-1:0] gpio_serial_link_1;		    wire [`MPRJ_IO_PADS_1-1:0] gpio_serial_link_1;
    wire [`MPRJ_IO_PADS_2-1:0] gpio_serial_link_2;		    wire [`MPRJ_IO_PADS_2-1:0] gpio_serial_link_2;
    wire mprj_io_loader_resetn;					    wire mprj_io_loader_resetn;
    wire mprj_io_loader_clock;					    wire mprj_io_loader_clock;
    wire mprj_io_loader_strobe;					    wire mprj_io_loader_strobe;
    wire mprj_io_loader_data_1;		/* user1 side serial 	    wire mprj_io_loader_data_1;		/* user1 side serial 
    wire mprj_io_loader_data_2;		/* user2 side serial 	    wire mprj_io_loader_data_2;		/* user2 side serial 

    // User Project Control management I/O			    // User Project Control management I/O
    // There are two types of GPIO connections:			    // There are two types of GPIO connections:
    // (1) Full Bidirectional: Management connects to in, out	    // (1) Full Bidirectional: Management connects to in, out
    //     Uses:  JTAG and SDO					    //     Uses:  JTAG and SDO
    // (2) Selectable bidirectional:  Management connects to 	    // (2) Selectable bidirectional:  Management connects to 
    //	   which are tied together.  oeb is grounded (oeb fro	    //	   which are tied together.  oeb is grounded (oeb fro
    //	   configuration is used)				    //	   configuration is used)

    // SDI 	 = mprj_io[2]		(input)			    // SDI 	 = mprj_io[2]		(input)
    // CSB 	 = mprj_io[3]		(input)			    // CSB 	 = mprj_io[3]		(input)
    // SCK	 = mprj_io[4]		(input)			    // SCK	 = mprj_io[4]		(input)
    // ser_rx    = mprj_io[5]		(input)			    // ser_rx    = mprj_io[5]		(input)
    // ser_tx    = mprj_io[6]		(output)		    // ser_tx    = mprj_io[6]		(output)
    // irq 	 = mprj_io[7]		(input)			    // irq 	 = mprj_io[7]		(input)

    wire [`MPRJ_IO_PADS-1:0] mgmt_io_in;	/* two- and t	    wire [`MPRJ_IO_PADS-1:0] mgmt_io_in;	/* two- and t
    wire [`MPRJ_IO_PADS-1:0] mgmt_io_out;	/* two- and t	    wire [`MPRJ_IO_PADS-1:0] mgmt_io_out;	/* two- and t
    wire [`MPRJ_IO_PADS-1:0] mgmt_io_oeb;	/* output ena	    wire [`MPRJ_IO_PADS-1:0] mgmt_io_oeb;	/* output ena
						/* the three-							/* the three-
    wire [`MPRJ_PWR_PADS-1:0] pwr_ctrl_nc;	/* no-connect	    wire [`MPRJ_PWR_PADS-1:0] pwr_ctrl_nc;	/* no-connect

    // Power-on-reset signal.  The reset pad generates the se	    // Power-on-reset signal.  The reset pad generates the se
    // reset at 3.3V.  The 1.8V signal and the inverted 1.8V 	    // reset at 3.3V.  The 1.8V signal and the inverted 1.8V 
    // derived.							    // derived.
    wire rstb_l;						    wire rstb_l;

    // Flash SPI communication (management SoC to housekeepin	    // Flash SPI communication (management SoC to housekeepin
    wire flash_clk_core,     flash_csb_core;			    wire flash_clk_core,     flash_csb_core;
    wire flash_io0_oeb_core, flash_io1_oeb_core;		    wire flash_io0_oeb_core, flash_io1_oeb_core;
    wire flash_io2_oeb_core, flash_io3_oeb_core;		    wire flash_io2_oeb_core, flash_io3_oeb_core;
    wire flash_io0_ieb_core, flash_io1_ieb_core;		    wire flash_io0_ieb_core, flash_io1_ieb_core;
    wire flash_io2_ieb_core, flash_io3_ieb_core;		    wire flash_io2_ieb_core, flash_io3_ieb_core;
    wire flash_io0_do_core,  flash_io1_do_core;			    wire flash_io0_do_core,  flash_io1_do_core;
    wire flash_io2_do_core,  flash_io3_do_core;			    wire flash_io2_do_core,  flash_io3_do_core;
    wire flash_io0_di_core,  flash_io1_di_core;			    wire flash_io0_di_core,  flash_io1_di_core;
    wire flash_io2_di_core,  flash_io3_di_core;			    wire flash_io2_di_core,  flash_io3_di_core;


    // SoC core							    // SoC core
    wire caravel_clk;						    wire caravel_clk;
    wire caravel_clk2;						    wire caravel_clk2;
    wire caravel_rstn;						    wire caravel_rstn;

    // Logic analyzer signals					    // Logic analyzer signals
    wire [127:0] la_data_in_user;  // From CPU to MPRJ		    wire [127:0] la_data_in_user;  // From CPU to MPRJ
    wire [127:0] la_data_in_mprj;  // From MPRJ to CPU		    wire [127:0] la_data_in_mprj;  // From MPRJ to CPU
    wire [127:0] la_data_out_mprj; // From CPU to MPRJ		    wire [127:0] la_data_out_mprj; // From CPU to MPRJ
    wire [127:0] la_data_out_user; // From MPRJ to CPU		    wire [127:0] la_data_out_user; // From MPRJ to CPU
    wire [127:0] la_oenb_user;     // From CPU to MPRJ		    wire [127:0] la_oenb_user;     // From CPU to MPRJ
    wire [127:0] la_oenb_mprj;     // From CPU to MPRJ		    wire [127:0] la_oenb_mprj;     // From CPU to MPRJ
    wire [127:0] la_iena_mprj;     // From CPU only		    wire [127:0] la_iena_mprj;     // From CPU only

    wire [2:0]   user_irq;	  // From MRPJ to CPU		    wire [2:0]   user_irq;	  // From MRPJ to CPU
    wire [2:0]   user_irq_core;					    wire [2:0]   user_irq_core;
    wire [2:0]   user_irq_ena;					    wire [2:0]   user_irq_ena;
    wire [2:0]	 irq_spi;	  // From SPI and external pi	    wire [2:0]	 irq_spi;	  // From SPI and external pi

    // Exported Wishbone Bus (processor facing)			    // Exported Wishbone Bus (processor facing)
    wire mprj_iena_wb;						    wire mprj_iena_wb;
    wire mprj_cyc_o_core;					    wire mprj_cyc_o_core;
    wire mprj_stb_o_core;					    wire mprj_stb_o_core;
    wire mprj_we_o_core;					    wire mprj_we_o_core;
    wire [3:0] mprj_sel_o_core;					    wire [3:0] mprj_sel_o_core;
    wire [31:0] mprj_adr_o_core;				    wire [31:0] mprj_adr_o_core;
    wire [31:0] mprj_dat_o_core;				    wire [31:0] mprj_dat_o_core;
    wire mprj_ack_i_core;					    wire mprj_ack_i_core;
    wire [31:0] mprj_dat_i_core;				    wire [31:0] mprj_dat_i_core;

    wire [31:0] hk_dat_i;					    wire [31:0] hk_dat_i;
    wire hk_ack_i;						    wire hk_ack_i;
    wire hk_stb_o;						    wire hk_stb_o;
    wire hk_cyc_o;						    wire hk_cyc_o;

    // Exported Wishbone Bus (user area facing)			    // Exported Wishbone Bus (user area facing)
    wire 	mprj_cyc_o_user;				    wire 	mprj_cyc_o_user;
    wire 	mprj_stb_o_user;				    wire 	mprj_stb_o_user;
    wire 	mprj_we_o_user;					    wire 	mprj_we_o_user;
    wire [3:0]  mprj_sel_o_user;				    wire [3:0]  mprj_sel_o_user;
    wire [31:0] mprj_adr_o_user;				    wire [31:0] mprj_adr_o_user;
    wire [31:0] mprj_dat_o_user;				    wire [31:0] mprj_dat_o_user;
    wire [31:0] mprj_dat_i_user;				    wire [31:0] mprj_dat_i_user;
    wire	mprj_ack_i_user;				    wire	mprj_ack_i_user;

    // Mask revision						    // Mask revision
    wire [31:0] mask_rev;					    wire [31:0] mask_rev;

    wire 	mprj_clock;					    wire 	mprj_clock;
    wire 	mprj_clock2;					    wire 	mprj_clock2;
    wire 	mprj_reset;					    wire 	mprj_reset;

    // Power monitoring 					    // Power monitoring 
    wire	mprj_vcc_pwrgood;				    wire	mprj_vcc_pwrgood;
    wire	mprj2_vcc_pwrgood;				    wire	mprj2_vcc_pwrgood;
    wire	mprj_vdd_pwrgood;				    wire	mprj_vdd_pwrgood;
    wire	mprj2_vdd_pwrgood;				    wire	mprj2_vdd_pwrgood;

`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
    // SRAM read-only access from housekeeping			    // SRAM read-only access from housekeeping
    wire 	hkspi_sram_clk;					    wire 	hkspi_sram_clk;
    wire 	hkspi_sram_csb;					    wire 	hkspi_sram_csb;
    wire [7:0]	hkspi_sram_addr;				    wire [7:0]	hkspi_sram_addr;
    wire [31:0]	hkspi_sram_data;				    wire [31:0]	hkspi_sram_data;
`endif								`endif

    // Management processor (wrapper).  Any management core	    // Management processor (wrapper).  Any management core
    // implementation must match this pinout.			    // implementation must match this pinout.

    mgmt_core_wrapper soc (					    mgmt_core_wrapper soc (
/*	`ifdef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
	`endif								`endif
*/							      |
	// Clock and reset						// Clock and reset
	.core_clk(caravel_clk),						.core_clk(caravel_clk),
	.core_rstn(caravel_rstn),					.core_rstn(caravel_rstn),

	// GPIO (1 pin)							// GPIO (1 pin)
	.gpio_out_pad(gpio_out_core),					.gpio_out_pad(gpio_out_core),
	.gpio_in_pad(gpio_in_core),					.gpio_in_pad(gpio_in_core),
	.gpio_mode0_pad(gpio_mode0_core),				.gpio_mode0_pad(gpio_mode0_core),
	.gpio_mode1_pad(gpio_mode1_core),				.gpio_mode1_pad(gpio_mode1_core),
	.gpio_outenb_pad(gpio_outenb_core),				.gpio_outenb_pad(gpio_outenb_core),
	.gpio_inenb_pad(gpio_inenb_core),				.gpio_inenb_pad(gpio_inenb_core),

	// Primary SPI flash controller					// Primary SPI flash controller
	.flash_csb(flash_csb_core),					.flash_csb(flash_csb_core),
	.flash_clk(flash_clk_core),					.flash_clk(flash_clk_core),
	.flash_io0_oeb(flash_io0_oeb_core),				.flash_io0_oeb(flash_io0_oeb_core),
	.flash_io0_di(flash_io0_di_core),				.flash_io0_di(flash_io0_di_core),
	.flash_io0_do(flash_io0_do_core),				.flash_io0_do(flash_io0_do_core),
	.flash_io1_oeb(flash_io1_oeb_core),				.flash_io1_oeb(flash_io1_oeb_core),
	.flash_io1_di(flash_io1_di_core),				.flash_io1_di(flash_io1_di_core),
	.flash_io1_do(flash_io1_do_core),				.flash_io1_do(flash_io1_do_core),
	.flash_io2_oeb(flash_io2_oeb_core),				.flash_io2_oeb(flash_io2_oeb_core),
	.flash_io2_di(flash_io2_di_core),				.flash_io2_di(flash_io2_di_core),
	.flash_io2_do(flash_io2_do_core),				.flash_io2_do(flash_io2_do_core),
	.flash_io3_oeb(flash_io3_oeb_core),				.flash_io3_oeb(flash_io3_oeb_core),
	.flash_io3_di(flash_io3_di_core),				.flash_io3_di(flash_io3_di_core),
	.flash_io3_do(flash_io3_do_core),				.flash_io3_do(flash_io3_do_core),

	// Exported Wishbone Bus					// Exported Wishbone Bus
	.mprj_wb_iena(mprj_iena_wb),					.mprj_wb_iena(mprj_iena_wb),
	.mprj_cyc_o(mprj_cyc_o_core),					.mprj_cyc_o(mprj_cyc_o_core),
	.mprj_stb_o(mprj_stb_o_core),					.mprj_stb_o(mprj_stb_o_core),
	.mprj_we_o(mprj_we_o_core),					.mprj_we_o(mprj_we_o_core),
	.mprj_sel_o(mprj_sel_o_core),					.mprj_sel_o(mprj_sel_o_core),
	.mprj_adr_o(mprj_adr_o_core),					.mprj_adr_o(mprj_adr_o_core),
	.mprj_dat_o(mprj_dat_o_core),					.mprj_dat_o(mprj_dat_o_core),
	.mprj_ack_i(mprj_ack_i_core),					.mprj_ack_i(mprj_ack_i_core),
	.mprj_dat_i(mprj_dat_i_core),					.mprj_dat_i(mprj_dat_i_core),

	.hk_stb_o(hk_stb_o),						.hk_stb_o(hk_stb_o),
	.hk_cyc_o(hk_cyc_o),						.hk_cyc_o(hk_cyc_o),
	.hk_dat_i(hk_dat_i),						.hk_dat_i(hk_dat_i),
	.hk_ack_i(hk_ack_i),						.hk_ack_i(hk_ack_i),

	// IRQ								// IRQ
	.irq({irq_spi, user_irq}),					.irq({irq_spi, user_irq}),
	.user_irq_ena(user_irq_ena),					.user_irq_ena(user_irq_ena),

	// Module status (these may or may not be implemented		// Module status (these may or may not be implemented
	.qspi_enabled(qspi_enabled),					.qspi_enabled(qspi_enabled),
	.uart_enabled(uart_enabled),					.uart_enabled(uart_enabled),
	.spi_enabled(spi_enabled),					.spi_enabled(spi_enabled),
	.debug_mode(debug_mode),					.debug_mode(debug_mode),

	// Module I/O (these may or may not be implemented)		// Module I/O (these may or may not be implemented)
	// UART								// UART
	.ser_tx(ser_tx),						.ser_tx(ser_tx),
	.ser_rx(ser_rx),						.ser_rx(ser_rx),
	// SPI master							// SPI master
	.spi_sdi(spi_sdi),						.spi_sdi(spi_sdi),
	.spi_csb(spi_csb),						.spi_csb(spi_csb),
	.spi_sck(spi_sck),						.spi_sck(spi_sck),
	.spi_sdo(spi_sdo),						.spi_sdo(spi_sdo),
	.spi_sdoenb(spi_sdoenb),					.spi_sdoenb(spi_sdoenb),
	// Debug							// Debug
	.debug_in(debug_in),						.debug_in(debug_in),
	.debug_out(debug_out),						.debug_out(debug_out),
	.debug_oeb(debug_oeb),						.debug_oeb(debug_oeb),
	// Logic analyzer						// Logic analyzer
	.la_input(la_data_in_mprj),					.la_input(la_data_in_mprj),
	.la_output(la_data_out_mprj),					.la_output(la_data_out_mprj),
	.la_oenb(la_oenb_mprj),						.la_oenb(la_oenb_mprj),
	.la_iena(la_iena_mprj),						.la_iena(la_iena_mprj),

`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
	// SRAM Read-only access from housekeeping			// SRAM Read-only access from housekeeping
	.sram_ro_clk(hkspi_sram_clk),					.sram_ro_clk(hkspi_sram_clk),
	.sram_ro_csb(hkspi_sram_csb),					.sram_ro_csb(hkspi_sram_csb),
	.sram_ro_addr(hkspi_sram_addr),					.sram_ro_addr(hkspi_sram_addr),
	.sram_ro_data(hkspi_sram_data),					.sram_ro_data(hkspi_sram_data),
`endif								`endif

	// Trap status							// Trap status
	.trap(trap)							.trap(trap)
    );								    );

    /* Clock and reset to user space are passed through a tri	    /* Clock and reset to user space are passed through a tri
    /* buffer like the above, but since they are intended to 	    /* buffer like the above, but since they are intended to 
    /* always active, connect the enable to the logic-1 outpu	    /* always active, connect the enable to the logic-1 outpu
    /* the vccd1 domain.					    /* the vccd1 domain.				

    mgmt_protect mgmt_buffers (					    mgmt_protect mgmt_buffers (
/*	`ifdef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
 	    .vccd(vccd),					 	    .vccd(vccd),
	    .vssd(vssd),						    .vssd(vssd),
	    .vccd1(vccd1),						    .vccd1(vccd1),
	    .vssd1(vssd1),						    .vssd1(vssd1),
	    .vccd2(vccd2),						    .vccd2(vccd2),
	    .vssd2(vssd2),						    .vssd2(vssd2),
	    .vdda1(vdda1),						    .vdda1(vdda1),
	    .vssa1(vssa1),						    .vssa1(vssa1),
	    .vdda2(vdda2),						    .vdda2(vdda2),
	    .vssa2(vssa2),						    .vssa2(vssa2),
	`endif */					      |		`endif
	.caravel_clk(caravel_clk),					.caravel_clk(caravel_clk),
	.caravel_clk2(caravel_clk2),					.caravel_clk2(caravel_clk2),
	.caravel_rstn(caravel_rstn),					.caravel_rstn(caravel_rstn),

	.mprj_iena_wb(mprj_iena_wb),					.mprj_iena_wb(mprj_iena_wb),
	.mprj_cyc_o_core(mprj_cyc_o_core),				.mprj_cyc_o_core(mprj_cyc_o_core),
	.mprj_stb_o_core(mprj_stb_o_core),				.mprj_stb_o_core(mprj_stb_o_core),
	.mprj_we_o_core(mprj_we_o_core),				.mprj_we_o_core(mprj_we_o_core),
	.mprj_sel_o_core(mprj_sel_o_core),				.mprj_sel_o_core(mprj_sel_o_core),
	.mprj_adr_o_core(mprj_adr_o_core),				.mprj_adr_o_core(mprj_adr_o_core),
	.mprj_dat_o_core(mprj_dat_o_core),				.mprj_dat_o_core(mprj_dat_o_core),
	.mprj_ack_i_core(mprj_ack_i_core),				.mprj_ack_i_core(mprj_ack_i_core),
	.mprj_dat_i_core(mprj_dat_i_core),				.mprj_dat_i_core(mprj_dat_i_core),

	.user_irq_core(user_irq_core),					.user_irq_core(user_irq_core),
	.user_irq_ena(user_irq_ena),					.user_irq_ena(user_irq_ena),
	.la_data_out_core(la_data_out_user),				.la_data_out_core(la_data_out_user),
	.la_data_out_mprj(la_data_out_mprj),				.la_data_out_mprj(la_data_out_mprj),
	.la_data_in_core(la_data_in_user),				.la_data_in_core(la_data_in_user),
	.la_data_in_mprj(la_data_in_mprj),				.la_data_in_mprj(la_data_in_mprj),
	.la_oenb_mprj(la_oenb_mprj),					.la_oenb_mprj(la_oenb_mprj),
	.la_oenb_core(la_oenb_user),					.la_oenb_core(la_oenb_user),
	.la_iena_mprj(la_iena_mprj),					.la_iena_mprj(la_iena_mprj),

	.user_clock(mprj_clock),					.user_clock(mprj_clock),
	.user_clock2(mprj_clock2),					.user_clock2(mprj_clock2),
	.user_reset(mprj_reset),					.user_reset(mprj_reset),

	.mprj_cyc_o_user(mprj_cyc_o_user),				.mprj_cyc_o_user(mprj_cyc_o_user),
	.mprj_stb_o_user(mprj_stb_o_user),				.mprj_stb_o_user(mprj_stb_o_user),
	.mprj_we_o_user(mprj_we_o_user),				.mprj_we_o_user(mprj_we_o_user),
	.mprj_sel_o_user(mprj_sel_o_user),				.mprj_sel_o_user(mprj_sel_o_user),
	.mprj_adr_o_user(mprj_adr_o_user),				.mprj_adr_o_user(mprj_adr_o_user),
	.mprj_dat_o_user(mprj_dat_o_user),				.mprj_dat_o_user(mprj_dat_o_user),
	.mprj_dat_i_user(mprj_dat_i_user),				.mprj_dat_i_user(mprj_dat_i_user),
	.mprj_ack_i_user(mprj_ack_i_user),				.mprj_ack_i_user(mprj_ack_i_user),
	.user_irq(user_irq),						.user_irq(user_irq),
	.user1_vcc_powergood(mprj_vcc_pwrgood),				.user1_vcc_powergood(mprj_vcc_pwrgood),
	.user2_vcc_powergood(mprj2_vcc_pwrgood),			.user2_vcc_powergood(mprj2_vcc_pwrgood),
	.user1_vdd_powergood(mprj_vdd_pwrgood),				.user1_vdd_powergood(mprj_vdd_pwrgood),
	.user2_vdd_powergood(mprj2_vdd_pwrgood)				.user2_vdd_powergood(mprj2_vdd_pwrgood)
    );								    );

    /*--------------------------------------------------*/	    /*--------------------------------------------------*/
    /* Wrapper module around the user project 		*/	    /* Wrapper module around the user project 		*/
    /*--------------------------------------------------*/	    /*--------------------------------------------------*/

    user_project_wrapper mprj ( 				    user_project_wrapper mprj ( 
    /*    `ifdef USE_POWER_PINS				      |	        `ifdef USE_POWER_PINS
	    .vdda1(vdda1),		// User area 1 3.3V p		    .vdda1(vdda1),		// User area 1 3.3V p
	    .vdda2(vdda2),		// User area 2 3.3V p		    .vdda2(vdda2),		// User area 2 3.3V p
	    .vssa1(vssa1),		// User area 1 analog		    .vssa1(vssa1),		// User area 1 analog
	    .vssa2(vssa2),		// User area 2 analog		    .vssa2(vssa2),		// User area 2 analog
	    .vccd1(vccd1),		// User area 1 1.8V p		    .vccd1(vccd1),		// User area 1 1.8V p
	    .vccd2(vccd2),		// User area 2 1.8V p		    .vccd2(vccd2),		// User area 2 1.8V p
	    .vssd1(vssd1),		// User area 1 digita		    .vssd1(vssd1),		// User area 1 digita
	    .vssd2(vssd2),		// User area 2 digita		    .vssd2(vssd2),		// User area 2 digita
    	`endif*/					      |	    	`endif

    	.wb_clk_i(mprj_clock),					    	.wb_clk_i(mprj_clock),
    	.wb_rst_i(mprj_reset),					    	.wb_rst_i(mprj_reset),

	// Management SoC Wishbone bus (exported)			// Management SoC Wishbone bus (exported)
	.wbs_cyc_i(mprj_cyc_o_user),					.wbs_cyc_i(mprj_cyc_o_user),
	.wbs_stb_i(mprj_stb_o_user),					.wbs_stb_i(mprj_stb_o_user),
	.wbs_we_i(mprj_we_o_user),					.wbs_we_i(mprj_we_o_user),
	.wbs_sel_i(mprj_sel_o_user),					.wbs_sel_i(mprj_sel_o_user),
	.wbs_adr_i(mprj_adr_o_user),					.wbs_adr_i(mprj_adr_o_user),
	.wbs_dat_i(mprj_dat_o_user),					.wbs_dat_i(mprj_dat_o_user),
	.wbs_ack_o(mprj_ack_i_user),					.wbs_ack_o(mprj_ack_i_user),
	.wbs_dat_o(mprj_dat_i_user),					.wbs_dat_o(mprj_dat_i_user),

	// GPIO pad 3-pin interface (plus analog)			// GPIO pad 3-pin interface (plus analog)
	.io_in (user_io_in),						.io_in (user_io_in),
    .io_out(user_io_out),					    .io_out(user_io_out),
    .io_oeb(user_io_oeb),					    .io_oeb(user_io_oeb),
	.analog_io(mprj_analog_io),					.analog_io(mprj_analog_io),

	// Logic analyzer						// Logic analyzer
	.la_data_in(la_data_in_user),					.la_data_in(la_data_in_user),
	.la_data_out(la_data_out_user),					.la_data_out(la_data_out_user),
	.la_oenb(la_oenb_user),						.la_oenb(la_oenb_user),

	// Independent clock						// Independent clock
	.user_clock2(mprj_clock2),					.user_clock2(mprj_clock2),

	// IRQ								// IRQ
	.user_irq(user_irq_core)					.user_irq(user_irq_core)
    );								    );

    /*------------------------------------------*/		    /*------------------------------------------*/
    /* End user project instantiation		*/		    /* End user project instantiation		*/
    /*------------------------------------------*/		    /*------------------------------------------*/

    wire [`MPRJ_IO_PADS_1-1:0] gpio_serial_link_1_shifted;	    wire [`MPRJ_IO_PADS_1-1:0] gpio_serial_link_1_shifted;
    wire [`MPRJ_IO_PADS_2-1:0] gpio_serial_link_2_shifted;	    wire [`MPRJ_IO_PADS_2-1:0] gpio_serial_link_2_shifted;

  assign gpio_serial_link_1_shifted = {				  assign gpio_serial_link_1_shifted = {
    gpio_serial_link_1[`MPRJ_IO_PADS_1-2:0], mprj_io_loader_d	    gpio_serial_link_1[`MPRJ_IO_PADS_1-2:0], mprj_io_loader_d
  };								  };
  // Note that serial_link_2 is backwards compared to serial_	  // Note that serial_link_2 is backwards compared to serial_
  // shifts in the other direction.				  // shifts in the other direction.
  assign gpio_serial_link_2_shifted = {				  assign gpio_serial_link_2_shifted = {
    mprj_io_loader_data_2, gpio_serial_link_2[`MPRJ_IO_PADS_2	    mprj_io_loader_data_2, gpio_serial_link_2[`MPRJ_IO_PADS_2
  };								  };

    // Propagating clock and reset to mitigate timing and fan	    // Propagating clock and reset to mitigate timing and fan
    wire [`MPRJ_IO_PADS_1-1:0] gpio_clock_1;			    wire [`MPRJ_IO_PADS_1-1:0] gpio_clock_1;
    wire [`MPRJ_IO_PADS_2-1:0] gpio_clock_2;			    wire [`MPRJ_IO_PADS_2-1:0] gpio_clock_2;
    wire [`MPRJ_IO_PADS_1-1:0] gpio_resetn_1;			    wire [`MPRJ_IO_PADS_1-1:0] gpio_resetn_1;
    wire [`MPRJ_IO_PADS_2-1:0] gpio_resetn_2;			    wire [`MPRJ_IO_PADS_2-1:0] gpio_resetn_2;
    wire [`MPRJ_IO_PADS_1-1:0] gpio_load_1;			    wire [`MPRJ_IO_PADS_1-1:0] gpio_load_1;
    wire [`MPRJ_IO_PADS_2-1:0] gpio_load_2;			    wire [`MPRJ_IO_PADS_2-1:0] gpio_load_2;
    wire [`MPRJ_IO_PADS_1-1:0] gpio_clock_1_shifted;		    wire [`MPRJ_IO_PADS_1-1:0] gpio_clock_1_shifted;
    wire [`MPRJ_IO_PADS_2-1:0] gpio_clock_2_shifted;		    wire [`MPRJ_IO_PADS_2-1:0] gpio_clock_2_shifted;
    wire [`MPRJ_IO_PADS_1-1:0] gpio_resetn_1_shifted;		    wire [`MPRJ_IO_PADS_1-1:0] gpio_resetn_1_shifted;
    wire [`MPRJ_IO_PADS_2-1:0] gpio_resetn_2_shifted;		    wire [`MPRJ_IO_PADS_2-1:0] gpio_resetn_2_shifted;
    wire [`MPRJ_IO_PADS_1-1:0] gpio_load_1_shifted;		    wire [`MPRJ_IO_PADS_1-1:0] gpio_load_1_shifted;
    wire [`MPRJ_IO_PADS_2-1:0] gpio_load_2_shifted;		    wire [`MPRJ_IO_PADS_2-1:0] gpio_load_2_shifted;

  assign gpio_clock_1_shifted  = {gpio_clock_1[`MPRJ_IO_PADS_	  assign gpio_clock_1_shifted  = {gpio_clock_1[`MPRJ_IO_PADS_
  assign gpio_clock_2_shifted  = {mprj_io_loader_clock, gpio_	  assign gpio_clock_2_shifted  = {mprj_io_loader_clock, gpio_
  assign gpio_resetn_1_shifted = {gpio_resetn_1[`MPRJ_IO_PADS	  assign gpio_resetn_1_shifted = {gpio_resetn_1[`MPRJ_IO_PADS
  assign gpio_resetn_2_shifted = {mprj_io_loader_resetn, gpio	  assign gpio_resetn_2_shifted = {mprj_io_loader_resetn, gpio
  assign gpio_load_1_shifted   = {gpio_load_1[`MPRJ_IO_PADS_1	  assign gpio_load_1_shifted   = {gpio_load_1[`MPRJ_IO_PADS_1
  assign gpio_load_2_shifted   = {mprj_io_loader_strobe, gpio	  assign gpio_load_2_shifted   = {mprj_io_loader_strobe, gpio

    wire [2:0] spi_pll_sel;					    wire [2:0] spi_pll_sel;
    wire [2:0] spi_pll90_sel;					    wire [2:0] spi_pll90_sel;
    wire [4:0] spi_pll_div;					    wire [4:0] spi_pll_div;
    wire [25:0] spi_pll_trim;					    wire [25:0] spi_pll_trim;

    // Clocking control						    // Clocking control

    caravel_clocking clock_ctrl (				    caravel_clocking clock_ctrl (
    /*`ifdef USE_POWER_PINS				      |	    `ifdef USE_POWER_PINS
		.VPWR(vccd),							.VPWR(vccd),
		.VGND(vssd),							.VGND(vssd),
    `endif*/						      |	    `endif
        .porb(porb_l),						        .porb(porb_l),
        .ext_clk_sel(ext_clk_sel),				        .ext_clk_sel(ext_clk_sel),
        .ext_clk(clock_core),					        .ext_clk(clock_core),
        .pll_clk(pll_clk),					        .pll_clk(pll_clk),
        .pll_clk90(pll_clk90),					        .pll_clk90(pll_clk90),
        .resetb(rstb_l),					        .resetb(rstb_l),
        .sel(spi_pll_sel),					        .sel(spi_pll_sel),
        .sel2(spi_pll90_sel),					        .sel2(spi_pll90_sel),
        .ext_reset(ext_reset),  // From housekeeping SPI	        .ext_reset(ext_reset),  // From housekeeping SPI
        .core_clk(caravel_clk),					        .core_clk(caravel_clk),
        .user_clk(caravel_clk2),				        .user_clk(caravel_clk2),
        .resetb_sync(caravel_rstn)				        .resetb_sync(caravel_rstn)
    );								    );

    // DCO/Digital Locked Loop					    // DCO/Digital Locked Loop

    digital_pll pll (						    digital_pll pll (
							      >	    
							      >	    //ritesh
    /*`ifdef USE_POWER_PINS					    /*`ifdef USE_POWER_PINS
		.VPWR(vccd),							.VPWR(vccd),
		.VGND(vssd),							.VGND(vssd),
    `endif*/							    `endif*/
        .resetb(rstb_l),					        .resetb(rstb_l),
        .enable(spi_pll_ena),					        .enable(spi_pll_ena),
        .osc(clock_core),					        .osc(clock_core),
        .clockp({pll_clk, pll_clk90}),				        .clockp({pll_clk, pll_clk90}),
        .div(spi_pll_div),					        .div(spi_pll_div),
        .dco(spi_pll_dco_ena),					        .dco(spi_pll_dco_ena),
        .ext_trim(spi_pll_trim)					        .ext_trim(spi_pll_trim)
    );								    );


  // mprj_gpio_buffer signals					  // mprj_gpio_buffer signals
  wire [`MPRJ_IO_PADS-1:0] mgmt_io_in_hk;	/* mgmt_io_in	  wire [`MPRJ_IO_PADS-1:0] mgmt_io_in_hk;	/* mgmt_io_in
  wire [`MPRJ_IO_PADS-1:0] mgmt_io_out_hk;	/* mgmt_io_ou	  wire [`MPRJ_IO_PADS-1:0] mgmt_io_out_hk;	/* mgmt_io_ou
  wire [`MPRJ_IO_PADS-1:0] mgmt_io_oeb_hk;	/* mgmt_io_oe	  wire [`MPRJ_IO_PADS-1:0] mgmt_io_oeb_hk;	/* mgmt_io_oe

  wire [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_in;			  wire [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_in;
  wire [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_out;			  wire [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_out;
  wire [2:0] mgmt_gpio_oeb;					  wire [2:0] mgmt_gpio_oeb;
  wire [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_in_buf;		  wire [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_in_buf;
  wire [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_out_buf;		  wire [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_out_buf;
  wire [2:0] mgmt_gpio_oeb_buf;					  wire [2:0] mgmt_gpio_oeb_buf;

    // Housekeeping interface					    // Housekeeping interface

    housekeeping housekeeping (					    housekeeping housekeeping (
    `ifndef USE_POWER_PINS				      |	    `ifdef USE_POWER_PINS
		.VPWR(vccd),							.VPWR(vccd),
		.VGND(vssd),							.VGND(vssd),
    `endif							    `endif

        .wb_clk_i(caravel_clk),					        .wb_clk_i(caravel_clk),
        .wb_rstn_i(caravel_rstn),				        .wb_rstn_i(caravel_rstn),

        .wb_adr_i(mprj_adr_o_core),				        .wb_adr_i(mprj_adr_o_core),
        .wb_dat_i(mprj_dat_o_core),				        .wb_dat_i(mprj_dat_o_core),
        .wb_sel_i(mprj_sel_o_core),				        .wb_sel_i(mprj_sel_o_core),
        .wb_we_i(mprj_we_o_core),				        .wb_we_i(mprj_we_o_core),
        .wb_cyc_i(hk_cyc_o),					        .wb_cyc_i(hk_cyc_o),
        .wb_stb_i(hk_stb_o),					        .wb_stb_i(hk_stb_o),
        .wb_ack_o(hk_ack_i),					        .wb_ack_o(hk_ack_i),
        .wb_dat_o(hk_dat_i),					        .wb_dat_o(hk_dat_i),

        .porb(porb_l),						        .porb(porb_l),

        .pll_ena(spi_pll_ena),					        .pll_ena(spi_pll_ena),
        .pll_dco_ena(spi_pll_dco_ena),				        .pll_dco_ena(spi_pll_dco_ena),
        .pll_div(spi_pll_div),					        .pll_div(spi_pll_div),
        .pll_sel(spi_pll_sel),					        .pll_sel(spi_pll_sel),
        .pll90_sel(spi_pll90_sel),				        .pll90_sel(spi_pll90_sel),
        .pll_trim(spi_pll_trim),				        .pll_trim(spi_pll_trim),
        .pll_bypass(ext_clk_sel),				        .pll_bypass(ext_clk_sel),

	.qspi_enabled(qspi_enabled),					.qspi_enabled(qspi_enabled),
	.uart_enabled(uart_enabled),					.uart_enabled(uart_enabled),
	.spi_enabled(spi_enabled),					.spi_enabled(spi_enabled),
	.debug_mode(debug_mode),					.debug_mode(debug_mode),

	.ser_tx(ser_tx),						.ser_tx(ser_tx),
	.ser_rx(ser_rx),						.ser_rx(ser_rx),

	.spi_sdi(spi_sdi),						.spi_sdi(spi_sdi),
	.spi_csb(spi_csb),						.spi_csb(spi_csb),
	.spi_sck(spi_sck),						.spi_sck(spi_sck),
	.spi_sdo(spi_sdo),						.spi_sdo(spi_sdo),
	.spi_sdoenb(spi_sdoenb),					.spi_sdoenb(spi_sdoenb),

	.debug_in(debug_in),						.debug_in(debug_in),
	.debug_out(debug_out),						.debug_out(debug_out),
	.debug_oeb(debug_oeb),						.debug_oeb(debug_oeb),

        .irq(irq_spi),						        .irq(irq_spi),
        .reset(ext_reset),					        .reset(ext_reset),

        .serial_clock(mprj_io_loader_clock),			        .serial_clock(mprj_io_loader_clock),
        .serial_load(mprj_io_loader_strobe),			        .serial_load(mprj_io_loader_strobe),
        .serial_resetn(mprj_io_loader_resetn),			        .serial_resetn(mprj_io_loader_resetn),
        .serial_data_1(mprj_io_loader_data_1),			        .serial_data_1(mprj_io_loader_data_1),
        .serial_data_2(mprj_io_loader_data_2),			        .serial_data_2(mprj_io_loader_data_2),

	.mgmt_gpio_in(mgmt_io_in_hk),					.mgmt_gpio_in(mgmt_io_in_hk),
	.mgmt_gpio_out(mgmt_io_out_hk),					.mgmt_gpio_out(mgmt_io_out_hk),
	.mgmt_gpio_oeb(mgmt_io_oeb_hk),					.mgmt_gpio_oeb(mgmt_io_oeb_hk),

	.pwr_ctrl_out(pwr_ctrl_nc),	/* Not used in this v		.pwr_ctrl_out(pwr_ctrl_nc),	/* Not used in this v

        .trap(trap),						        .trap(trap),

	.user_clock(caravel_clk2),					.user_clock(caravel_clk2),

        .mask_rev_in(mask_rev),					        .mask_rev_in(mask_rev),

	.spimemio_flash_csb(flash_csb_core),				.spimemio_flash_csb(flash_csb_core),
	.spimemio_flash_clk(flash_clk_core),				.spimemio_flash_clk(flash_clk_core),
	.spimemio_flash_io0_oeb(flash_io0_oeb_core),			.spimemio_flash_io0_oeb(flash_io0_oeb_core),
	.spimemio_flash_io1_oeb(flash_io1_oeb_core),			.spimemio_flash_io1_oeb(flash_io1_oeb_core),
	.spimemio_flash_io2_oeb(flash_io2_oeb_core),			.spimemio_flash_io2_oeb(flash_io2_oeb_core),
	.spimemio_flash_io3_oeb(flash_io3_oeb_core),			.spimemio_flash_io3_oeb(flash_io3_oeb_core),
	.spimemio_flash_io0_do(flash_io0_do_core),			.spimemio_flash_io0_do(flash_io0_do_core),
	.spimemio_flash_io1_do(flash_io1_do_core),			.spimemio_flash_io1_do(flash_io1_do_core),
	.spimemio_flash_io2_do(flash_io2_do_core),			.spimemio_flash_io2_do(flash_io2_do_core),
	.spimemio_flash_io3_do(flash_io3_do_core),			.spimemio_flash_io3_do(flash_io3_do_core),
	.spimemio_flash_io0_di(flash_io0_di_core),			.spimemio_flash_io0_di(flash_io0_di_core),
	.spimemio_flash_io1_di(flash_io1_di_core),			.spimemio_flash_io1_di(flash_io1_di_core),
	.spimemio_flash_io2_di(flash_io2_di_core),			.spimemio_flash_io2_di(flash_io2_di_core),
	.spimemio_flash_io3_di(flash_io3_di_core),			.spimemio_flash_io3_di(flash_io3_di_core),

	.pad_flash_csb(flash_csb_frame),				.pad_flash_csb(flash_csb_frame),
	.pad_flash_csb_oeb(flash_csb_oeb),				.pad_flash_csb_oeb(flash_csb_oeb),
	.pad_flash_clk(flash_clk_frame),				.pad_flash_clk(flash_clk_frame),
	.pad_flash_clk_oeb(flash_clk_oeb),				.pad_flash_clk_oeb(flash_clk_oeb),
	.pad_flash_io0_oeb(flash_io0_oeb),				.pad_flash_io0_oeb(flash_io0_oeb),
	.pad_flash_io1_oeb(flash_io1_oeb),				.pad_flash_io1_oeb(flash_io1_oeb),
	.pad_flash_io0_ieb(flash_io0_ieb),				.pad_flash_io0_ieb(flash_io0_ieb),
	.pad_flash_io1_ieb(flash_io1_ieb),				.pad_flash_io1_ieb(flash_io1_ieb),
	.pad_flash_io0_do(flash_io0_do),				.pad_flash_io0_do(flash_io0_do),
	.pad_flash_io1_do(flash_io1_do),				.pad_flash_io1_do(flash_io1_do),
	.pad_flash_io0_di(flash_io0_di),				.pad_flash_io0_di(flash_io0_di),
	.pad_flash_io1_di(flash_io1_di),				.pad_flash_io1_di(flash_io1_di),

`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
	.sram_ro_clk(hkspi_sram_clk),					.sram_ro_clk(hkspi_sram_clk),
	.sram_ro_csb(hkspi_sram_csb),					.sram_ro_csb(hkspi_sram_csb),
	.sram_ro_addr(hkspi_sram_addr),					.sram_ro_addr(hkspi_sram_addr),
	.sram_ro_data(hkspi_sram_data),					.sram_ro_data(hkspi_sram_data),
`endif								`endif

	.usr1_vcc_pwrgood(mprj_vcc_pwrgood),				.usr1_vcc_pwrgood(mprj_vcc_pwrgood),
	.usr2_vcc_pwrgood(mprj2_vcc_pwrgood),				.usr2_vcc_pwrgood(mprj2_vcc_pwrgood),
	.usr1_vdd_pwrgood(mprj_vdd_pwrgood),				.usr1_vdd_pwrgood(mprj_vdd_pwrgood),
	.usr2_vdd_pwrgood(mprj2_vdd_pwrgood)				.usr2_vdd_pwrgood(mprj2_vdd_pwrgood)
    );								    );

  mprj_io_buffer gpio_buf (					  mprj_io_buffer gpio_buf (
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
      .VPWR(vccd),						      .VPWR(vccd),
      .VGND(vssd),						      .VGND(vssd),
`endif */						      |	`endif

      .mgmt_gpio_in(mgmt_gpio_in),				      .mgmt_gpio_in(mgmt_gpio_in),
      .mgmt_gpio_in_buf(mgmt_gpio_in_buf),			      .mgmt_gpio_in_buf(mgmt_gpio_in_buf),
      .mgmt_gpio_oeb(mgmt_gpio_oeb),				      .mgmt_gpio_oeb(mgmt_gpio_oeb),
      .mgmt_gpio_oeb_buf(mgmt_gpio_oeb_buf),			      .mgmt_gpio_oeb_buf(mgmt_gpio_oeb_buf),
      .mgmt_gpio_out(mgmt_gpio_out),				      .mgmt_gpio_out(mgmt_gpio_out),
      .mgmt_gpio_out_buf(mgmt_gpio_out_buf)			      .mgmt_gpio_out_buf(mgmt_gpio_out_buf)
  );								  );

  assign mgmt_gpio_in  = mgmt_io_in[(`MPRJ_IO_PADS-1):(`MPRJ_	  assign mgmt_gpio_in  = mgmt_io_in[(`MPRJ_IO_PADS-1):(`MPRJ_
  assign mgmt_gpio_out = mgmt_io_out_hk[(`MPRJ_IO_PADS-1):(`M	  assign mgmt_gpio_out = mgmt_io_out_hk[(`MPRJ_IO_PADS-1):(`M
  assign mgmt_gpio_oeb = mgmt_io_oeb_hk[(`MPRJ_IO_PADS-1):(`M	  assign mgmt_gpio_oeb = mgmt_io_oeb_hk[(`MPRJ_IO_PADS-1):(`M
  								  
  assign mgmt_io_in_hk = {mgmt_gpio_in_buf, mgmt_io_in[(`MPRJ	  assign mgmt_io_in_hk = {mgmt_gpio_in_buf, mgmt_io_in[(`MPRJ
  assign mgmt_io_out   = {mgmt_gpio_out_buf, mgmt_io_out_hk[(	  assign mgmt_io_out   = {mgmt_gpio_out_buf, mgmt_io_out_hk[(
  assign mgmt_io_oeb   = {mgmt_gpio_oeb_buf, mgmt_io_oeb_hk[(	  assign mgmt_io_oeb   = {mgmt_gpio_oeb_buf, mgmt_io_oeb_hk[(

    /* GPIO defaults (via programmed) */			    /* GPIO defaults (via programmed) */
    wire [`MPRJ_IO_PADS*13-1:0] gpio_defaults;			    wire [`MPRJ_IO_PADS*13-1:0] gpio_defaults;

    /* Fixed defaults for the first 5 GPIO pins */		    /* Fixed defaults for the first 5 GPIO pins */

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(13'h1803)					.GPIO_CONFIG_INIT(13'h1803)
    ) gpio_defaults_block_0 (					    ) gpio_defaults_block_0 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[12:0])				.gpio_defaults(gpio_defaults[12:0])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(13'h1803)					.GPIO_CONFIG_INIT(13'h1803)
    ) gpio_defaults_block_1 (					    ) gpio_defaults_block_1 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[25:13])				.gpio_defaults(gpio_defaults[25:13])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(13'h0403)					.GPIO_CONFIG_INIT(13'h0403)
    ) gpio_defaults_block_2 (					    ) gpio_defaults_block_2 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[38:26])				.gpio_defaults(gpio_defaults[38:26])
    );								    );

    // CSB pin is set as an internal pull-up			    // CSB pin is set as an internal pull-up
    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(13'h0801)					.GPIO_CONFIG_INIT(13'h0801)
    ) gpio_defaults_block_3 (					    ) gpio_defaults_block_3 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[51:39])				.gpio_defaults(gpio_defaults[51:39])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(13'h0403)					.GPIO_CONFIG_INIT(13'h0403)
    ) gpio_defaults_block_4 (					    ) gpio_defaults_block_4 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[64:52])				.gpio_defaults(gpio_defaults[64:52])
    );								    );

    /* Via-programmable defaults for the rest of the GPIO pin	    /* Via-programmable defaults for the rest of the GPIO pin

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_5_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_5_INIT)
    ) gpio_defaults_block_5 (					    ) gpio_defaults_block_5 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[77:65])				.gpio_defaults(gpio_defaults[77:65])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_6_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_6_INIT)
    ) gpio_defaults_block_6 (					    ) gpio_defaults_block_6 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[90:78])				.gpio_defaults(gpio_defaults[90:78])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_7_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_7_INIT)
    ) gpio_defaults_block_7 (					    ) gpio_defaults_block_7 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[103:91])				.gpio_defaults(gpio_defaults[103:91])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_8_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_8_INIT)
    ) gpio_defaults_block_8 (					    ) gpio_defaults_block_8 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[116:104])				.gpio_defaults(gpio_defaults[116:104])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_9_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_9_INIT)
    ) gpio_defaults_block_9 (					    ) gpio_defaults_block_9 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[129:117])				.gpio_defaults(gpio_defaults[129:117])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_10_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_10_INIT)
    ) gpio_defaults_block_10 (					    ) gpio_defaults_block_10 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[142:130])				.gpio_defaults(gpio_defaults[142:130])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_11_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_11_INIT)
    ) gpio_defaults_block_11 (					    ) gpio_defaults_block_11 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[155:143])				.gpio_defaults(gpio_defaults[155:143])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_12_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_12_INIT)
    ) gpio_defaults_block_12 (					    ) gpio_defaults_block_12 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[168:156])				.gpio_defaults(gpio_defaults[168:156])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_13_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_13_INIT)
    ) gpio_defaults_block_13 (					    ) gpio_defaults_block_13 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[181:169])				.gpio_defaults(gpio_defaults[181:169])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_14_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_14_INIT)
    ) gpio_defaults_block_14 (					    ) gpio_defaults_block_14 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[194:182])				.gpio_defaults(gpio_defaults[194:182])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_15_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_15_INIT)
    ) gpio_defaults_block_15 (					    ) gpio_defaults_block_15 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[207:195])				.gpio_defaults(gpio_defaults[207:195])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_16_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_16_INIT)
    ) gpio_defaults_block_16 (					    ) gpio_defaults_block_16 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[220:208])				.gpio_defaults(gpio_defaults[220:208])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_17_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_17_INIT)
    ) gpio_defaults_block_17 (					    ) gpio_defaults_block_17 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[233:221])				.gpio_defaults(gpio_defaults[233:221])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_18_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_18_INIT)
    ) gpio_defaults_block_18 (					    ) gpio_defaults_block_18 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[246:234])				.gpio_defaults(gpio_defaults[246:234])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_19_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_19_INIT)
    ) gpio_defaults_block_19 (					    ) gpio_defaults_block_19 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[259:247])				.gpio_defaults(gpio_defaults[259:247])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_20_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_20_INIT)
    ) gpio_defaults_block_20 (					    ) gpio_defaults_block_20 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[272:260])				.gpio_defaults(gpio_defaults[272:260])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_21_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_21_INIT)
    ) gpio_defaults_block_21 (					    ) gpio_defaults_block_21 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[285:273])				.gpio_defaults(gpio_defaults[285:273])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_22_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_22_INIT)
    ) gpio_defaults_block_22 (					    ) gpio_defaults_block_22 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[298:286])				.gpio_defaults(gpio_defaults[298:286])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_23_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_23_INIT)
    ) gpio_defaults_block_23 (					    ) gpio_defaults_block_23 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[311:299])				.gpio_defaults(gpio_defaults[311:299])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_24_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_24_INIT)
    ) gpio_defaults_block_24 (					    ) gpio_defaults_block_24 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[324:312])				.gpio_defaults(gpio_defaults[324:312])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_25_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_25_INIT)
    ) gpio_defaults_block_25 (					    ) gpio_defaults_block_25 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[337:325])				.gpio_defaults(gpio_defaults[337:325])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_26_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_26_INIT)
    ) gpio_defaults_block_26 (					    ) gpio_defaults_block_26 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[350:338])				.gpio_defaults(gpio_defaults[350:338])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_27_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_27_INIT)
    ) gpio_defaults_block_27 (					    ) gpio_defaults_block_27 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[363:351])				.gpio_defaults(gpio_defaults[363:351])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_28_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_28_INIT)
    ) gpio_defaults_block_28 (					    ) gpio_defaults_block_28 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[376:364])				.gpio_defaults(gpio_defaults[376:364])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_29_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_29_INIT)
    ) gpio_defaults_block_29 (					    ) gpio_defaults_block_29 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[389:377])				.gpio_defaults(gpio_defaults[389:377])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_30_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_30_INIT)
    ) gpio_defaults_block_30 (					    ) gpio_defaults_block_30 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[402:390])				.gpio_defaults(gpio_defaults[402:390])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_31_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_31_INIT)
    ) gpio_defaults_block_31 (					    ) gpio_defaults_block_31 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[415:403])				.gpio_defaults(gpio_defaults[415:403])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_32_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_32_INIT)
    ) gpio_defaults_block_32 (					    ) gpio_defaults_block_32 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[428:416])				.gpio_defaults(gpio_defaults[428:416])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_33_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_33_INIT)
    ) gpio_defaults_block_33 (					    ) gpio_defaults_block_33 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[441:429])				.gpio_defaults(gpio_defaults[441:429])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_34_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_34_INIT)
    ) gpio_defaults_block_34 (					    ) gpio_defaults_block_34 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[454:442])				.gpio_defaults(gpio_defaults[454:442])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_35_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_35_INIT)
    ) gpio_defaults_block_35 (					    ) gpio_defaults_block_35 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[467:455])				.gpio_defaults(gpio_defaults[467:455])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_36_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_36_INIT)
    ) gpio_defaults_block_36 (					    ) gpio_defaults_block_36 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[480:468])				.gpio_defaults(gpio_defaults[480:468])
    );								    );

    gpio_defaults_block #(					    gpio_defaults_block #(
	.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_37_INIT)			.GPIO_CONFIG_INIT(`USER_CONFIG_GPIO_37_INIT)
    ) gpio_defaults_block_37 (					    ) gpio_defaults_block_37 (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
        `endif							        `endif
	.gpio_defaults(gpio_defaults[493:481])				.gpio_defaults(gpio_defaults[493:481])
    );								    );

    // Each control block sits next to an I/O pad in the user	    // Each control block sits next to an I/O pad in the user
    // It gets input through a serial chain from the previous	    // It gets input through a serial chain from the previous
    // block and passes it to the next control block.  Due to	    // block and passes it to the next control block.  Due to
    // of the shift register, bits are presented in reverse, 	    // of the shift register, bits are presented in reverse, 
    // bit in ends up as the last bit of the last I/O pad con	    // bit in ends up as the last bit of the last I/O pad con

    // There are two types of block;  the first two and the l	    // There are two types of block;  the first two and the l
    // are configured to be full bidirectional under control 	    // are configured to be full bidirectional under control 
    // management Soc (JTAG and SDO for the first two;  flash	    // management Soc (JTAG and SDO for the first two;  flash
    // flash_io3 for the last two).  The rest are configured 	    // flash_io3 for the last two).  The rest are configured 
    // (input).  Note that the first two and last two are the	    // (input).  Note that the first two and last two are the
    // to the management SoC on either side, which minimizes 	    // to the management SoC on either side, which minimizes 
    // of the extra signals those pads need.			    // of the extra signals those pads need.

    /* First two GPIOs (JTAG and SDO) */			    /* First two GPIOs (JTAG and SDO) */

    gpio_control_block gpio_control_bidir_1 [1:0] (		    gpio_control_block gpio_control_bidir_1 [1:0] (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .vccd(vccd),						    .vccd(vccd),
	    .vssd(vssd),						    .vssd(vssd),
	    .vccd1(vccd1),						    .vccd1(vccd1),
	    .vssd1(vssd1),						    .vssd1(vssd1),
        `endif							        `endif

	.gpio_defaults(gpio_defaults[25:0]),				.gpio_defaults(gpio_defaults[25:0]),

    	// Management Soc-facing signals			    	// Management Soc-facing signals

    	.resetn(gpio_resetn_1_shifted[1:0]),			    	.resetn(gpio_resetn_1_shifted[1:0]),
    	.serial_clock(gpio_clock_1_shifted[1:0]),		    	.serial_clock(gpio_clock_1_shifted[1:0]),
    	.serial_load(gpio_load_1_shifted[1:0]),			    	.serial_load(gpio_load_1_shifted[1:0]),

    	.resetn_out(gpio_resetn_1[1:0]),			    	.resetn_out(gpio_resetn_1[1:0]),
    	.serial_clock_out(gpio_clock_1[1:0]),			    	.serial_clock_out(gpio_clock_1[1:0]),
    	.serial_load_out(gpio_load_1[1:0]),			    	.serial_load_out(gpio_load_1[1:0]),

    	.mgmt_gpio_in(mgmt_io_in[1:0]),				    	.mgmt_gpio_in(mgmt_io_in[1:0]),
	.mgmt_gpio_out(mgmt_io_out[1:0]),				.mgmt_gpio_out(mgmt_io_out[1:0]),
	.mgmt_gpio_oeb(mgmt_io_oeb[1:0]),				.mgmt_gpio_oeb(mgmt_io_oeb[1:0]),

        .one(mprj_io_one[1:0]),					        .one(mprj_io_one[1:0]),
        .zero(),						        .zero(),

    	// Serial data chain for pad configuration		    	// Serial data chain for pad configuration
    	.serial_data_in(gpio_serial_link_1_shifted[1:0]),	    	.serial_data_in(gpio_serial_link_1_shifted[1:0]),
    	.serial_data_out(gpio_serial_link_1[1:0]),		    	.serial_data_out(gpio_serial_link_1[1:0]),

    	// User-facing signals					    	// User-facing signals
    	.user_gpio_out(user_io_out[1:0]),			    	.user_gpio_out(user_io_out[1:0]),
    	.user_gpio_oeb(user_io_oeb[1:0]),			    	.user_gpio_oeb(user_io_oeb[1:0]),
    	.user_gpio_in(user_io_in[1:0]),				    	.user_gpio_in(user_io_in[1:0]),

    	// Pad-facing signals (Pad GPIOv2)			    	// Pad-facing signals (Pad GPIOv2)
    	.pad_gpio_inenb(mprj_io_inp_dis[1:0]),			    	.pad_gpio_inenb(mprj_io_inp_dis[1:0]),
    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[1:0]),	    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[1:0]),
    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[1:0]),		    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[1:0]),
    	.pad_gpio_slow_sel(mprj_io_slow_sel[1:0]),		    	.pad_gpio_slow_sel(mprj_io_slow_sel[1:0]),
    	.pad_gpio_holdover(mprj_io_holdover[1:0]),		    	.pad_gpio_holdover(mprj_io_holdover[1:0]),
    	.pad_gpio_ana_en(mprj_io_analog_en[1:0]),		    	.pad_gpio_ana_en(mprj_io_analog_en[1:0]),
    	.pad_gpio_ana_sel(mprj_io_analog_sel[1:0]),		    	.pad_gpio_ana_sel(mprj_io_analog_sel[1:0]),
    	.pad_gpio_ana_pol(mprj_io_analog_pol[1:0]),		    	.pad_gpio_ana_pol(mprj_io_analog_pol[1:0]),
    	.pad_gpio_dm(mprj_io_dm[5:0]),				    	.pad_gpio_dm(mprj_io_dm[5:0]),
    	.pad_gpio_outenb(mprj_io_oeb[1:0]),			    	.pad_gpio_outenb(mprj_io_oeb[1:0]),
    	.pad_gpio_out(mprj_io_out[1:0]),			    	.pad_gpio_out(mprj_io_out[1:0]),
    	.pad_gpio_in(mprj_io_in[1:0])				    	.pad_gpio_in(mprj_io_in[1:0])
    );								    );

    /* Section 1 GPIOs (GPIO 2 to 7) that start up under mana	    /* Section 1 GPIOs (GPIO 2 to 7) that start up under mana

    gpio_control_block gpio_control_in_1a [5:0] (		    gpio_control_block gpio_control_in_1a [5:0] (
        `ifndef USE_POWER_PINS				      |	        `ifdef USE_POWER_PINS
            .vccd(vccd),					            .vccd(vccd),
	    .vssd(vssd),						    .vssd(vssd),
	    .vccd1(vccd1),						    .vccd1(vccd1),
	    .vssd1(vssd1),						    .vssd1(vssd1),
        `endif							        `endif

	.gpio_defaults(gpio_defaults[103:26]),				.gpio_defaults(gpio_defaults[103:26]),

    	// Management Soc-facing signals			    	// Management Soc-facing signals

    	.resetn(gpio_resetn_1_shifted[7:2]),			    	.resetn(gpio_resetn_1_shifted[7:2]),
    	.serial_clock(gpio_clock_1_shifted[7:2]),		    	.serial_clock(gpio_clock_1_shifted[7:2]),
    	.serial_load(gpio_load_1_shifted[7:2]),			    	.serial_load(gpio_load_1_shifted[7:2]),

    	.resetn_out(gpio_resetn_1[7:2]),			    	.resetn_out(gpio_resetn_1[7:2]),
    	.serial_clock_out(gpio_clock_1[7:2]),			    	.serial_clock_out(gpio_clock_1[7:2]),
    	.serial_load_out(gpio_load_1[7:2]),			    	.serial_load_out(gpio_load_1[7:2]),

	.mgmt_gpio_in(mgmt_io_in[7:2]),					.mgmt_gpio_in(mgmt_io_in[7:2]),
	.mgmt_gpio_out(mgmt_io_out[7:2]),				.mgmt_gpio_out(mgmt_io_out[7:2]),
	.mgmt_gpio_oeb(mprj_io_one[7:2]),				.mgmt_gpio_oeb(mprj_io_one[7:2]),

        .one(mprj_io_one[7:2]),					        .one(mprj_io_one[7:2]),
        .zero(),						        .zero(),

    	// Serial data chain for pad configuration		    	// Serial data chain for pad configuration
    	.serial_data_in(gpio_serial_link_1_shifted[7:2]),	    	.serial_data_in(gpio_serial_link_1_shifted[7:2]),
    	.serial_data_out(gpio_serial_link_1[7:2]),		    	.serial_data_out(gpio_serial_link_1[7:2]),

    	// User-facing signals					    	// User-facing signals
    	.user_gpio_out(user_io_out[7:2]),			    	.user_gpio_out(user_io_out[7:2]),
    	.user_gpio_oeb(user_io_oeb[7:2]),			    	.user_gpio_oeb(user_io_oeb[7:2]),
    	.user_gpio_in(user_io_in[7:2]),				    	.user_gpio_in(user_io_in[7:2]),

    	// Pad-facing signals (Pad GPIOv2)			    	// Pad-facing signals (Pad GPIOv2)
    	.pad_gpio_inenb(mprj_io_inp_dis[7:2]),			    	.pad_gpio_inenb(mprj_io_inp_dis[7:2]),
    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[7:2]),	    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[7:2]),
    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[7:2]),		    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[7:2]),
    	.pad_gpio_slow_sel(mprj_io_slow_sel[7:2]),		    	.pad_gpio_slow_sel(mprj_io_slow_sel[7:2]),
    	.pad_gpio_holdover(mprj_io_holdover[7:2]),		    	.pad_gpio_holdover(mprj_io_holdover[7:2]),
    	.pad_gpio_ana_en(mprj_io_analog_en[7:2]),		    	.pad_gpio_ana_en(mprj_io_analog_en[7:2]),
    	.pad_gpio_ana_sel(mprj_io_analog_sel[7:2]),		    	.pad_gpio_ana_sel(mprj_io_analog_sel[7:2]),
    	.pad_gpio_ana_pol(mprj_io_analog_pol[7:2]),		    	.pad_gpio_ana_pol(mprj_io_analog_pol[7:2]),
    	.pad_gpio_dm(mprj_io_dm[23:6]),				    	.pad_gpio_dm(mprj_io_dm[23:6]),
    	.pad_gpio_outenb(mprj_io_oeb[7:2]),			    	.pad_gpio_outenb(mprj_io_oeb[7:2]),
    	.pad_gpio_out(mprj_io_out[7:2]),			    	.pad_gpio_out(mprj_io_out[7:2]),
    	.pad_gpio_in(mprj_io_in[7:2])				    	.pad_gpio_in(mprj_io_in[7:2])
    );								    );

    /* Section 1 GPIOs (GPIO 8 to 18) */			    /* Section 1 GPIOs (GPIO 8 to 18) */

    gpio_control_block gpio_control_in_1 [`MPRJ_IO_PADS_1-9:0	    gpio_control_block gpio_control_in_1 [`MPRJ_IO_PADS_1-9:0
        `ifndef USE_POWER_PINS				      |	        `ifdef USE_POWER_PINS
            .vccd(vccd),					            .vccd(vccd),
	    .vssd(vssd),						    .vssd(vssd),
	    .vccd1(vccd1),						    .vccd1(vccd1),
	    .vssd1(vssd1),						    .vssd1(vssd1),
        `endif							        `endif

	.gpio_defaults(gpio_defaults[(`MPRJ_IO_PADS_1*13-1):1		.gpio_defaults(gpio_defaults[(`MPRJ_IO_PADS_1*13-1):1

    	// Management Soc-facing signals			    	// Management Soc-facing signals

    	.resetn(gpio_resetn_1_shifted[(`MPRJ_IO_PADS_1-1):8])	    	.resetn(gpio_resetn_1_shifted[(`MPRJ_IO_PADS_1-1):8])
    	.serial_clock(gpio_clock_1_shifted[(`MPRJ_IO_PADS_1-1	    	.serial_clock(gpio_clock_1_shifted[(`MPRJ_IO_PADS_1-1
    	.serial_load(gpio_load_1_shifted[(`MPRJ_IO_PADS_1-1):	    	.serial_load(gpio_load_1_shifted[(`MPRJ_IO_PADS_1-1):

    	.resetn_out(gpio_resetn_1[(`MPRJ_IO_PADS_1-1):8]),	    	.resetn_out(gpio_resetn_1[(`MPRJ_IO_PADS_1-1):8]),
    	.serial_clock_out(gpio_clock_1[(`MPRJ_IO_PADS_1-1):8]	    	.serial_clock_out(gpio_clock_1[(`MPRJ_IO_PADS_1-1):8]
    	.serial_load_out(gpio_load_1[(`MPRJ_IO_PADS_1-1):8]),	    	.serial_load_out(gpio_load_1[(`MPRJ_IO_PADS_1-1):8]),

	.mgmt_gpio_in(mgmt_io_in[(`MPRJ_IO_PADS_1-1):8]),		.mgmt_gpio_in(mgmt_io_in[(`MPRJ_IO_PADS_1-1):8]),
	.mgmt_gpio_out(mgmt_io_out[(`MPRJ_IO_PADS_1-1):8]),		.mgmt_gpio_out(mgmt_io_out[(`MPRJ_IO_PADS_1-1):8]),
	.mgmt_gpio_oeb(mprj_io_one[(`MPRJ_IO_PADS_1-1):8]),		.mgmt_gpio_oeb(mprj_io_one[(`MPRJ_IO_PADS_1-1):8]),
  								  
        .one(mprj_io_one[(`MPRJ_IO_PADS_1-1):8]),		        .one(mprj_io_one[(`MPRJ_IO_PADS_1-1):8]),
        .zero(),						        .zero(),

    	// Serial data chain for pad configuration		    	// Serial data chain for pad configuration
    	.serial_data_in(gpio_serial_link_1_shifted[(`MPRJ_IO_	    	.serial_data_in(gpio_serial_link_1_shifted[(`MPRJ_IO_
    	.serial_data_out(gpio_serial_link_1[(`MPRJ_IO_PADS_1-	    	.serial_data_out(gpio_serial_link_1[(`MPRJ_IO_PADS_1-

    	// User-facing signals					    	// User-facing signals
    	.user_gpio_out(user_io_out[(`MPRJ_IO_PADS_1-1):8]),	    	.user_gpio_out(user_io_out[(`MPRJ_IO_PADS_1-1):8]),
    	.user_gpio_oeb(user_io_oeb[(`MPRJ_IO_PADS_1-1):8]),	    	.user_gpio_oeb(user_io_oeb[(`MPRJ_IO_PADS_1-1):8]),
    	.user_gpio_in(user_io_in[(`MPRJ_IO_PADS_1-1):8]),	    	.user_gpio_in(user_io_in[(`MPRJ_IO_PADS_1-1):8]),

    	// Pad-facing signals (Pad GPIOv2)			    	// Pad-facing signals (Pad GPIOv2)
    	.pad_gpio_inenb(mprj_io_inp_dis[(`MPRJ_IO_PADS_1-1):8	    	.pad_gpio_inenb(mprj_io_inp_dis[(`MPRJ_IO_PADS_1-1):8
    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[(`MPRJ_IO_P	    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[(`MPRJ_IO_P
    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[(`MPRJ_IO_PADS_	    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[(`MPRJ_IO_PADS_
    	.pad_gpio_slow_sel(mprj_io_slow_sel[(`MPRJ_IO_PADS_1-	    	.pad_gpio_slow_sel(mprj_io_slow_sel[(`MPRJ_IO_PADS_1-
    	.pad_gpio_holdover(mprj_io_holdover[(`MPRJ_IO_PADS_1-	    	.pad_gpio_holdover(mprj_io_holdover[(`MPRJ_IO_PADS_1-
    	.pad_gpio_ana_en(mprj_io_analog_en[(`MPRJ_IO_PADS_1-1	    	.pad_gpio_ana_en(mprj_io_analog_en[(`MPRJ_IO_PADS_1-1
    	.pad_gpio_ana_sel(mprj_io_analog_sel[(`MPRJ_IO_PADS_1	    	.pad_gpio_ana_sel(mprj_io_analog_sel[(`MPRJ_IO_PADS_1
    	.pad_gpio_ana_pol(mprj_io_analog_pol[(`MPRJ_IO_PADS_1	    	.pad_gpio_ana_pol(mprj_io_analog_pol[(`MPRJ_IO_PADS_1
    	.pad_gpio_dm(mprj_io_dm[(`MPRJ_IO_PADS_1*3-1):24]),	    	.pad_gpio_dm(mprj_io_dm[(`MPRJ_IO_PADS_1*3-1):24]),
    	.pad_gpio_outenb(mprj_io_oeb[(`MPRJ_IO_PADS_1-1):8]),	    	.pad_gpio_outenb(mprj_io_oeb[(`MPRJ_IO_PADS_1-1):8]),
    	.pad_gpio_out(mprj_io_out[(`MPRJ_IO_PADS_1-1):8]),	    	.pad_gpio_out(mprj_io_out[(`MPRJ_IO_PADS_1-1):8]),
    	.pad_gpio_in(mprj_io_in[(`MPRJ_IO_PADS_1-1):8])		    	.pad_gpio_in(mprj_io_in[(`MPRJ_IO_PADS_1-1):8])
    );								    );

    /* Last three GPIOs (spi_sdo, flash_io2, and flash_io3) *	    /* Last three GPIOs (spi_sdo, flash_io2, and flash_io3) *

    gpio_control_block gpio_control_bidir_2 [2:0] (		    gpio_control_block gpio_control_bidir_2 [2:0] (
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
	    .vccd(vccd),						    .vccd(vccd),
	    .vssd(vssd),						    .vssd(vssd),
	    .vccd1(vccd1),						    .vccd1(vccd1),
	    .vssd1(vssd1),						    .vssd1(vssd1),
        `endif							        `endif

	.gpio_defaults(gpio_defaults[(`MPRJ_IO_PADS*13-1):(`M		.gpio_defaults(gpio_defaults[(`MPRJ_IO_PADS*13-1):(`M

    	// Management Soc-facing signals			    	// Management Soc-facing signals

    	.resetn(gpio_resetn_2_shifted[(`MPRJ_IO_PADS_2-1):(`M	    	.resetn(gpio_resetn_2_shifted[(`MPRJ_IO_PADS_2-1):(`M
    	.serial_clock(gpio_clock_2_shifted[(`MPRJ_IO_PADS_2-1	    	.serial_clock(gpio_clock_2_shifted[(`MPRJ_IO_PADS_2-1
    	.serial_load(gpio_load_2_shifted[(`MPRJ_IO_PADS_2-1):	    	.serial_load(gpio_load_2_shifted[(`MPRJ_IO_PADS_2-1):

    	.resetn_out(gpio_resetn_2[(`MPRJ_IO_PADS_2-1):(`MPRJ_	    	.resetn_out(gpio_resetn_2[(`MPRJ_IO_PADS_2-1):(`MPRJ_
    	.serial_clock_out(gpio_clock_2[(`MPRJ_IO_PADS_2-1):(`	    	.serial_clock_out(gpio_clock_2[(`MPRJ_IO_PADS_2-1):(`
    	.serial_load_out(gpio_load_2[(`MPRJ_IO_PADS_2-1):(`MP	    	.serial_load_out(gpio_load_2[(`MPRJ_IO_PADS_2-1):(`MP

    	.mgmt_gpio_in(mgmt_io_in[(`MPRJ_IO_PADS-1):(`MPRJ_IO_	    	.mgmt_gpio_in(mgmt_io_in[(`MPRJ_IO_PADS-1):(`MPRJ_IO_
	.mgmt_gpio_out(mgmt_io_out[(`MPRJ_IO_PADS-1):(`MPRJ_I		.mgmt_gpio_out(mgmt_io_out[(`MPRJ_IO_PADS-1):(`MPRJ_I
	.mgmt_gpio_oeb(mgmt_io_oeb[(`MPRJ_IO_PADS-1):(`MPRJ_I		.mgmt_gpio_oeb(mgmt_io_oeb[(`MPRJ_IO_PADS-1):(`MPRJ_I

        .one(mprj_io_one[(`MPRJ_IO_PADS-1):(`MPRJ_IO_PADS-3)]	        .one(mprj_io_one[(`MPRJ_IO_PADS-1):(`MPRJ_IO_PADS-3)]
        .zero(),						        .zero(),

    	// Serial data chain for pad configuration		    	// Serial data chain for pad configuration
    	.serial_data_in(gpio_serial_link_2_shifted[(`MPRJ_IO_	    	.serial_data_in(gpio_serial_link_2_shifted[(`MPRJ_IO_
    	.serial_data_out(gpio_serial_link_2[(`MPRJ_IO_PADS_2-	    	.serial_data_out(gpio_serial_link_2[(`MPRJ_IO_PADS_2-

    	// User-facing signals					    	// User-facing signals
    	.user_gpio_out(user_io_out[(`MPRJ_IO_PADS-1):(`MPRJ_I	    	.user_gpio_out(user_io_out[(`MPRJ_IO_PADS-1):(`MPRJ_I
    	.user_gpio_oeb(user_io_oeb[(`MPRJ_IO_PADS-1):(`MPRJ_I	    	.user_gpio_oeb(user_io_oeb[(`MPRJ_IO_PADS-1):(`MPRJ_I
    	.user_gpio_in(user_io_in[(`MPRJ_IO_PADS-1):(`MPRJ_IO_	    	.user_gpio_in(user_io_in[(`MPRJ_IO_PADS-1):(`MPRJ_IO_

    	// Pad-facing signals (Pad GPIOv2)			    	// Pad-facing signals (Pad GPIOv2)
    	.pad_gpio_inenb(mprj_io_inp_dis[(`MPRJ_IO_PADS-1):(`M	    	.pad_gpio_inenb(mprj_io_inp_dis[(`MPRJ_IO_PADS-1):(`M
    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[(`MPRJ_IO_P	    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[(`MPRJ_IO_P
    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[(`MPRJ_IO_PADS-	    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[(`MPRJ_IO_PADS-
    	.pad_gpio_slow_sel(mprj_io_slow_sel[(`MPRJ_IO_PADS-1)	    	.pad_gpio_slow_sel(mprj_io_slow_sel[(`MPRJ_IO_PADS-1)
    	.pad_gpio_holdover(mprj_io_holdover[(`MPRJ_IO_PADS-1)	    	.pad_gpio_holdover(mprj_io_holdover[(`MPRJ_IO_PADS-1)
    	.pad_gpio_ana_en(mprj_io_analog_en[(`MPRJ_IO_PADS-1):	    	.pad_gpio_ana_en(mprj_io_analog_en[(`MPRJ_IO_PADS-1):
    	.pad_gpio_ana_sel(mprj_io_analog_sel[(`MPRJ_IO_PADS-1	    	.pad_gpio_ana_sel(mprj_io_analog_sel[(`MPRJ_IO_PADS-1
    	.pad_gpio_ana_pol(mprj_io_analog_pol[(`MPRJ_IO_PADS-1	    	.pad_gpio_ana_pol(mprj_io_analog_pol[(`MPRJ_IO_PADS-1
    	.pad_gpio_dm(mprj_io_dm[(`MPRJ_IO_PADS*3-1):(`MPRJ_IO	    	.pad_gpio_dm(mprj_io_dm[(`MPRJ_IO_PADS*3-1):(`MPRJ_IO
    	.pad_gpio_outenb(mprj_io_oeb[(`MPRJ_IO_PADS-1):(`MPRJ	    	.pad_gpio_outenb(mprj_io_oeb[(`MPRJ_IO_PADS-1):(`MPRJ
    	.pad_gpio_out(mprj_io_out[(`MPRJ_IO_PADS-1):(`MPRJ_IO	    	.pad_gpio_out(mprj_io_out[(`MPRJ_IO_PADS-1):(`MPRJ_IO
    	.pad_gpio_in(mprj_io_in[(`MPRJ_IO_PADS-1):(`MPRJ_IO_P	    	.pad_gpio_in(mprj_io_in[(`MPRJ_IO_PADS-1):(`MPRJ_IO_P
    );								    );

    /* Section 2 GPIOs (GPIO 19 to 34) */			    /* Section 2 GPIOs (GPIO 19 to 34) */

    gpio_control_block gpio_control_in_2 [`MPRJ_IO_PADS_2-4:0	    gpio_control_block gpio_control_in_2 [`MPRJ_IO_PADS_2-4:0
    	`ifndef USE_POWER_PINS				      |	    	`ifdef USE_POWER_PINS
            .vccd(vccd),					            .vccd(vccd),
	    .vssd(vssd),						    .vssd(vssd),
	    .vccd1(vccd1),						    .vccd1(vccd1),
	    .vssd1(vssd1),						    .vssd1(vssd1),
        `endif							        `endif

	.gpio_defaults(gpio_defaults[(`MPRJ_IO_PADS*13-40):(`		.gpio_defaults(gpio_defaults[(`MPRJ_IO_PADS*13-40):(`

    	// Management Soc-facing signals			    	// Management Soc-facing signals

    	.resetn(gpio_resetn_2_shifted[(`MPRJ_IO_PADS_2-4):0])	    	.resetn(gpio_resetn_2_shifted[(`MPRJ_IO_PADS_2-4):0])
    	.serial_clock(gpio_clock_2_shifted[(`MPRJ_IO_PADS_2-4	    	.serial_clock(gpio_clock_2_shifted[(`MPRJ_IO_PADS_2-4
    	.serial_load(gpio_load_2_shifted[(`MPRJ_IO_PADS_2-4):	    	.serial_load(gpio_load_2_shifted[(`MPRJ_IO_PADS_2-4):

    	.resetn_out(gpio_resetn_2[(`MPRJ_IO_PADS_2-4):0]),	    	.resetn_out(gpio_resetn_2[(`MPRJ_IO_PADS_2-4):0]),
    	.serial_clock_out(gpio_clock_2[(`MPRJ_IO_PADS_2-4):0]	    	.serial_clock_out(gpio_clock_2[(`MPRJ_IO_PADS_2-4):0]
    	.serial_load_out(gpio_load_2[(`MPRJ_IO_PADS_2-4):0]),	    	.serial_load_out(gpio_load_2[(`MPRJ_IO_PADS_2-4):0]),

	.mgmt_gpio_in(mgmt_io_in[(`MPRJ_IO_PADS-4):(`MPRJ_IO_		.mgmt_gpio_in(mgmt_io_in[(`MPRJ_IO_PADS-4):(`MPRJ_IO_
	.mgmt_gpio_out(mgmt_io_out[(`MPRJ_IO_PADS-4):(`MPRJ_I		.mgmt_gpio_out(mgmt_io_out[(`MPRJ_IO_PADS-4):(`MPRJ_I
	.mgmt_gpio_oeb(mprj_io_one[(`MPRJ_IO_PADS-4):(`MPRJ_I		.mgmt_gpio_oeb(mprj_io_one[(`MPRJ_IO_PADS-4):(`MPRJ_I


        .one(mprj_io_one[(`MPRJ_IO_PADS-4):(`MPRJ_IO_PADS_1)]	        .one(mprj_io_one[(`MPRJ_IO_PADS-4):(`MPRJ_IO_PADS_1)]
        .zero(),						        .zero(),

    	// Serial data chain for pad configuration		    	// Serial data chain for pad configuration
    	.serial_data_in(gpio_serial_link_2_shifted[(`MPRJ_IO_	    	.serial_data_in(gpio_serial_link_2_shifted[(`MPRJ_IO_
    	.serial_data_out(gpio_serial_link_2[(`MPRJ_IO_PADS_2-	    	.serial_data_out(gpio_serial_link_2[(`MPRJ_IO_PADS_2-

    	// User-facing signals					    	// User-facing signals
    	.user_gpio_out(user_io_out[(`MPRJ_IO_PADS-4):(`MPRJ_I	    	.user_gpio_out(user_io_out[(`MPRJ_IO_PADS-4):(`MPRJ_I
    	.user_gpio_oeb(user_io_oeb[(`MPRJ_IO_PADS-4):(`MPRJ_I	    	.user_gpio_oeb(user_io_oeb[(`MPRJ_IO_PADS-4):(`MPRJ_I
    	.user_gpio_in(user_io_in[(`MPRJ_IO_PADS-4):(`MPRJ_IO_	    	.user_gpio_in(user_io_in[(`MPRJ_IO_PADS-4):(`MPRJ_IO_

    	// Pad-facing signals (Pad GPIOv2)			    	// Pad-facing signals (Pad GPIOv2)
    	.pad_gpio_inenb(mprj_io_inp_dis[(`MPRJ_IO_PADS-4):(`M	    	.pad_gpio_inenb(mprj_io_inp_dis[(`MPRJ_IO_PADS-4):(`M
    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[(`MPRJ_IO_P	    	.pad_gpio_ib_mode_sel(mprj_io_ib_mode_sel[(`MPRJ_IO_P
    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[(`MPRJ_IO_PADS-	    	.pad_gpio_vtrip_sel(mprj_io_vtrip_sel[(`MPRJ_IO_PADS-
    	.pad_gpio_slow_sel(mprj_io_slow_sel[(`MPRJ_IO_PADS-4)	    	.pad_gpio_slow_sel(mprj_io_slow_sel[(`MPRJ_IO_PADS-4)
    	.pad_gpio_holdover(mprj_io_holdover[(`MPRJ_IO_PADS-4)	    	.pad_gpio_holdover(mprj_io_holdover[(`MPRJ_IO_PADS-4)
    	.pad_gpio_ana_en(mprj_io_analog_en[(`MPRJ_IO_PADS-4):	    	.pad_gpio_ana_en(mprj_io_analog_en[(`MPRJ_IO_PADS-4):
    	.pad_gpio_ana_sel(mprj_io_analog_sel[(`MPRJ_IO_PADS-4	    	.pad_gpio_ana_sel(mprj_io_analog_sel[(`MPRJ_IO_PADS-4
    	.pad_gpio_ana_pol(mprj_io_analog_pol[(`MPRJ_IO_PADS-4	    	.pad_gpio_ana_pol(mprj_io_analog_pol[(`MPRJ_IO_PADS-4
    	.pad_gpio_dm(mprj_io_dm[(`MPRJ_IO_PADS*3-10):(`MPRJ_I	    	.pad_gpio_dm(mprj_io_dm[(`MPRJ_IO_PADS*3-10):(`MPRJ_I
    	.pad_gpio_outenb(mprj_io_oeb[(`MPRJ_IO_PADS-4):(`MPRJ	    	.pad_gpio_outenb(mprj_io_oeb[(`MPRJ_IO_PADS-4):(`MPRJ
    	.pad_gpio_out(mprj_io_out[(`MPRJ_IO_PADS-4):(`MPRJ_IO	    	.pad_gpio_out(mprj_io_out[(`MPRJ_IO_PADS-4):(`MPRJ_IO
    	.pad_gpio_in(mprj_io_in[(`MPRJ_IO_PADS-4):(`MPRJ_IO_P	    	.pad_gpio_in(mprj_io_in[(`MPRJ_IO_PADS-4):(`MPRJ_IO_P
    );								    );

    user_id_programming #(					    user_id_programming #(
	.USER_PROJECT_ID(USER_PROJECT_ID)				.USER_PROJECT_ID(USER_PROJECT_ID)
    ) user_id_value (						    ) user_id_value (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
		.VPWR(vccd),							.VPWR(vccd),
		.VGND(vssd),							.VGND(vssd),
	`endif								`endif
	.mask_rev(mask_rev)						.mask_rev(mask_rev)
    );								    );

    // Power-on-reset circuit					    // Power-on-reset circuit
    wire porb_l;					      |	    simple_por por (
    assign porb_h=reset_n;				      |		`ifdef USE_POWER_PINS
    assign porb_l=porb_h;				      |			.vdd3v3(vddio),
    assign por_l=~porb_l;				      |			.vdd1v8(vccd),
    							      |			.vss3v3(vssio),
							      >			.vss1v8(vssd),
							      >		`endif
							      >			.porb_h(porb_h),
							      >			.porb_l(porb_l),
							      >			.por_l(por_l)
							      >	    );

    // XRES (chip input pin reset) reset level converter	    // XRES (chip input pin reset) reset level converter
    xres_buf rstb_level (					    xres_buf rstb_level (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
		.VPWR(vddio),							.VPWR(vddio),
		.LVPWR(vccd),							.LVPWR(vccd),
		.LVGND(vssd),							.LVGND(vssd),
		.VGND(vssio),							.VGND(vssio),
	`endif								`endif
		.A(rstb_h),							.A(rstb_h),
		.X(rstb_l)							.X(rstb_l)
    );								    );

    /* Spare logic for metal mask fixes */			    /* Spare logic for metal mask fixes */
    // `define NUM_SPARE_BLOCKS (`MPRJ_IO_PADS+4)		    // `define NUM_SPARE_BLOCKS (`MPRJ_IO_PADS+4)
    `define NUM_SPARE_BLOCKS 4					    `define NUM_SPARE_BLOCKS 4

    wire [(27*`NUM_SPARE_BLOCKS)-1:0] spare_xz_nc;		    wire [(27*`NUM_SPARE_BLOCKS)-1:0] spare_xz_nc;
    wire [(4*`NUM_SPARE_BLOCKS)-1:0] spare_xi_nc;		    wire [(4*`NUM_SPARE_BLOCKS)-1:0] spare_xi_nc;
    wire [(1*`NUM_SPARE_BLOCKS)-1:0] spare_xib_nc;		    wire [(1*`NUM_SPARE_BLOCKS)-1:0] spare_xib_nc;
    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xna_nc;		    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xna_nc;
    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xno_nc;		    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xno_nc;
    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xmx_nc;		    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xmx_nc;
    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xfq_nc;		    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xfq_nc;
    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xfqn_nc;		    wire [(2*`NUM_SPARE_BLOCKS)-1:0] spare_xfqn_nc;

    // Four spare logic blocks above the processor and one pe	    // Four spare logic blocks above the processor and one pe
    // control block.						    // control block.
(* keep *) spare_logic_block spare_logic [`NUM_SPARE_BLOCKS-1	(* keep *) spare_logic_block spare_logic [`NUM_SPARE_BLOCKS-1
	/*`ifdef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
							      <
		.vccd(vccd),							.vccd(vccd),
		.vssd(vssd),							.vssd(vssd),
	`endif */					      |		`endif
		.spare_xz(spare_xz_nc),						.spare_xz(spare_xz_nc),
		.spare_xi(spare_xi_nc),						.spare_xi(spare_xi_nc),
		.spare_xib(spare_xib_nc),					.spare_xib(spare_xib_nc),
		.spare_xna(spare_xna_nc),					.spare_xna(spare_xna_nc),
		.spare_xno(spare_xno_nc),					.spare_xno(spare_xno_nc),
		.spare_xmx(spare_xmx_nc),					.spare_xmx(spare_xmx_nc),
		.spare_xfq(spare_xfq_nc),					.spare_xfq(spare_xfq_nc),
		.spare_xfqn(spare_xfqn_nc)					.spare_xfqn(spare_xfqn_nc)
    );								    );
(* keep *) empty_macro empty_macro_0 ();			(* keep *) empty_macro empty_macro_0 ();
(* keep *) empty_macro empty_macro_1 ();			(* keep *) empty_macro empty_macro_1 ();
(* keep *) manual_power_connections manual_power_connections 	(* keep *) manual_power_connections manual_power_connections 
endmodule							endmodule
// `default_nettype wire					// `default_nettype wire
diff -ry rtl/caravel_logo.v verilog/rtl/caravel_logo.v
module caravel_logo ();						module caravel_logo ();
endmodule							endmodule
diff -ry rtl/caravel_motto.v verilog/rtl/caravel_motto.v
module caravel_motto ();					module caravel_motto ();
endmodule							endmodule
diff -ry rtl/caravel_netlists.v verilog/rtl/caravel_netlists.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`timescale 1 ns / 1 ps						`timescale 1 ns / 1 ps

`define UNIT_DELAY #1						`define UNIT_DELAY #1
`define USE_POWER_PINS						`define USE_POWER_PINS

`ifdef SIM							`ifdef SIM

    `include "defines.v"					    `include "defines.v"
    `include "user_defines.v"					    `include "user_defines.v"
    `include "pads.v"						    `include "pads.v"
    //`include "RAM128.v"				      <
    //`include "RAM256.v"				      <

    /* NOTE: Need to pass the PDK root directory to iverilog 	    /* NOTE: Need to pass the PDK root directory to iverilog 

							      |	    `ifdef  EF_STYLE 
							      >		`include "libs.ref/verilog/sky130_fd_io/sky130_fd_io.
							      >		`include "libs.ref/verilog/sky130_fd_io/sky130_ef_io.
							      >
							      >		`include "libs.ref/verilog/sky130_fd_sc_hd/primitives
							      >		`include "libs.ref/verilog/sky130_fd_sc_hd/sky130_fd_
							      >		`include "libs.ref/verilog/sky130_fd_sc_hvl/primitive
							      >		`include "libs.ref/verilog/sky130_fd_sc_hvl/sky130_fd
							      >		`include "libs.ref/verilog/sky130_sram_macros/sky130_
							      >	    `else 
							      >		`include "libs.ref/sky130_fd_io/verilog/sky130_fd_io.
							      >		`include "libs.ref/sky130_fd_io/verilog/sky130_ef_io.
							      >
							      >		`include "libs.ref/sky130_fd_sc_hd/verilog/primitives
							      >		`include "libs.ref/sky130_fd_sc_hd/verilog/sky130_fd_
							      >		`include "libs.ref/sky130_fd_sc_hvl/verilog/primitive
							      >		`include "libs.ref/sky130_fd_sc_hvl/verilog/sky130_fd
							      >		`include "libs.ref/sky130_sram_macros/verilog/sky130_
							      >	    `endif 

    `ifdef GL							    `ifdef GL
        `include "defines.v"				      |		`include "../gl/digital_pll.v"
	`include "digital_pll.v"			      |		`include "../gl/caravel_clocking.v"
	`include "caravel_clocking.v"			      <
	`include "user_id_programming.v"				`include "user_id_programming.v"
	`include "chip_io.v"				      |		`include "../gl/chip_io.v"
	`include "housekeeping.v"			      |		`include "../gl/housekeeping.v"
	`include "mprj_logic_high.v"			      |		`include "../gl/mprj_logic_high.v"
	`include "mprj2_logic_high.v"			      |		`include "../gl/mprj2_logic_high.v"
	`include "mgmt_protect.v"			      |		`include "../gl/mgmt_protect.v"
	//`include "gl/mgmt_protect_hv.v"		      |		`include "../gl/mgmt_protect_hv.v"
	`include "constant_block.v"			      |		`include "../gl/constant_block.v"
	`include "gpio_control_block.v"					`include "gpio_control_block.v"
	`include "gpio_defaults_block.v"				`include "gpio_defaults_block.v"
	//`include "gl/gpio_defaults_block_0403.v"	      |		`include "../gl/gpio_defaults_block_0403.v"
	//`include "gl/gpio_defaults_block_1803.v"	      |		`include "../gl/gpio_defaults_block_1803.v"
	//`include "gl/gpio_defaults_block_0801.v"	      |		`include "../gl/gpio_defaults_block_0801.v"
	//`include "gl/gpio_signal_buffering.v"		      |		`include "../gl/gpio_signal_buffering.v"
	`include "gpio_logic_high.v"			      |		`include "../gl/gpio_logic_high.v"
	`include "xres_buf.v"				      |		`include "../gl/xres_buf.v"
	`include "spare_logic_block.v"			      |		`include "../gl/spare_logic_block.v"
	//`include "gl/mgmt_defines.v"			      |		
	`include "mgmt_core_wrapper.v"			      |		// modified by Ritesh Balaji S
	//`include "gl/caravel.v"			      |		
        //`include "pc3b03ed_wrapper.v"			      |		`include "../gl/mgmt_defines.v"
        //`include "pc3d21.v"				      |		`include "../gl/mgmt_core_wrapper.v"
       // `include "pc3d01.v"				      |		
        //`include "pt3b02.v"				      |		`include "../gl/caravel.v"
        //added for streamlining the file references and comp <
        `include "__user_project_wrapper.v"		      <
    `else							    `else
        `include "pc3b03ed_wrapper.v"			      <
        //`include "pc3d21.v"				      <
        //`include "pvdi.v"				      <
	//`include "pvda.v"				      <
	//`include "pv0a.v"				      <
        //`include "pc3d01_wrapper.v"			      <
	//`include "pt3b02_wrapper.v"			      <
	`include "digital_pll.v"					`include "digital_pll.v"
	`include "digital_pll_controller.v"				`include "digital_pll_controller.v"
	`include "ring_osc2x13.v"					`include "ring_osc2x13.v"
	`include "caravel_clocking.v"					`include "caravel_clocking.v"
	`include "user_id_programming.v"				`include "user_id_programming.v"
	`include "clock_div.v"						`include "clock_div.v"
	`include "mprj_io.v"						`include "mprj_io.v"
	`include "chip_io.v"						`include "chip_io.v"
	`include "housekeeping_spi.v"					`include "housekeeping_spi.v"
	`include "housekeeping.v"					`include "housekeeping.v"
	`include "mprj_logic_high.v"					`include "mprj_logic_high.v"
	`include "mprj2_logic_high.v"					`include "mprj2_logic_high.v"
	`include "mgmt_protect.v"					`include "mgmt_protect.v"
	`include "mgmt_protect_hv.v"					`include "mgmt_protect_hv.v"
	`include "constant_block.v"					`include "constant_block.v"
	`include "gpio_control_block.v"					`include "gpio_control_block.v"
	`include "gpio_defaults_block.v"				`include "gpio_defaults_block.v"
	`include "gpio_signal_buffering.v" // need to ask why |		`include "gpio_signal_buffering.v"
	`include "gpio_logic_high.v"					`include "gpio_logic_high.v"
	`include "xres_buf.v"						`include "xres_buf.v"
	`include "spare_logic_block.v"					`include "spare_logic_block.v"
	`include "mgmt_core_wrapper.v"					`include "mgmt_core_wrapper.v"
	`include "vsdcaravel.v"				      |		`include "caravel.v"
                //`include ""				      <
    `endif							    `endif
							      >
							      >	    `include "simple_por.v"

`endif								`endif
diff -ry rtl/caravel_openframe.v verilog/rtl/caravel_openframe.v
// `default_nettype none					// `default_nettype none
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* Vsdcaravel, RISC-V SoC Implementation using Synopsys and S |	/* caravel_openframe, a project harness for the Google/SkyWat
/* a project for the VSD/Semiconductor Laboratory SCL180      |	/* sky130 fabrication process and open source PDK	
/* fabrication process 			                      |	/*                                                          
/*                                                            |	/* Copyright 2023 Efabless Corporation			
/* Copyright 2025 efabless, Inc. /VSD                         |	/* Written by Tim Edwards, March 2023                    
/* Originally written by Tim Edwards, December 2019           |	/* This file is open source hardware released under the     
/* and Mohamed Shalan, August 2020			      <
/* Edited by Dhanvanti Bhavsar and Kunal Ghosh on (11/02/2025 <
/* Updated on 11/02/2025:  Revised using SCL180 PDK	      <
/* Apache 2.0 license.  See file LICENSE.                   	/* Apache 2.0 license.  See file LICENSE.                   
/*								/*							
/* The caravel_openframe is a chip top level design conformin	/* The caravel_openframe is a chip top level design conformin
/* to the pad locations and assignments used by the Caravel a	/* to the pad locations and assignments used by the Caravel a
/* Caravan chips top level definition.  However, it does not	/* Caravan chips top level definition.  However, it does not
/* define any embedded processor or other interfaces.		/* define any embedded processor or other interfaces.	
/*								/*							
/* The padframe of caravel_openframe consists of the same 38	/* The padframe of caravel_openframe consists of the same 38
/* general-purpose I/O pads as Caravel.  The pads formerly	/* general-purpose I/O pads as Caravel.  The pads formerly
/* used by Caravel for dedicated functions of the management	/* used by Caravel for dedicated functions of the management
/* SoC (flash controller CSB, SCK, IO0 and IO1, gpio, and	/* SoC (flash controller CSB, SCK, IO0 and IO1, gpio, and
/* clock) are redefined as additional general-purpose I/O for	/* clock) are redefined as additional general-purpose I/O for
/* a total of 44 GPIO pads.  The resetb pad retains its		/* a total of 44 GPIO pads.  The resetb pad retains its	
/* function as an input pin with weak pull-up with high and	/* function as an input pin with weak pull-up with high and
/* low voltage domain (3.3V and 1.8V) versions of the output	/* low voltage domain (3.3V and 1.8V) versions of the output
/* exported to the chip project core.  The user may elect to	/* exported to the chip project core.  The user may elect to
/* use the reset pin for a purpose other than a master reset.	/* use the reset pin for a purpose other than a master reset.
/*								/*							
/* The padframe implements a simple power-on reset circuit, a	/* The padframe implements a simple power-on reset circuit, a
/* provides a 32-bit bus in the 1.8V digital domain consistin	/* provides a 32-bit bus in the 1.8V digital domain consistin
/* of the (fixed) user project ID.				/* of the (fixed) user project ID.			
/*								/*							
/* Each GPIO pad must be configured by the user project.  The	/* Each GPIO pad must be configured by the user project.  The
/* padframe exports constant value "1" and "0" bits in the 1.	/* padframe exports constant value "1" and "0" bits in the 1.
/* domain for each GPIO pad that can be used by the user	/* domain for each GPIO pad that can be used by the user
/* project to loop back to the GPIO to set a static		/* project to loop back to the GPIO to set a static	
/* configuration on power-up.					/* configuration on power-up.				
/*								/*							
/* Every user project must instantiate a module called		/* Every user project must instantiate a module called	
/* "openframe_project_wrapper" that connects to all of the	/* "openframe_project_wrapper" that connects to all of the
/* signals as defined in the module call, below.  The layout	/* signals as defined in the module call, below.  The layout
/* of the user project must correspond to the provided wrappe	/* of the user project must correspond to the provided wrappe
/* cell layout, describing the position of signal and power	/* cell layout, describing the position of signal and power
/* pins on the perimeter of the wrapper.			/* pins on the perimeter of the wrapper.		
/*								/*							
/* Bon voyage!							/* Bon voyage!						
/*-----------------------------------------------------------	/*-----------------------------------------------------------

/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* NOTE:  This file can be checked for syntax directly using:	/* NOTE:  This file can be checked for syntax directly using:
/*								/*							
/* iverilog -I ${PDK_ROOT}/${PDK} -DSIM -DFUNCTIONAL \		/* iverilog -I ${PDK_ROOT}/${PDK} -DSIM -DFUNCTIONAL \	
/* openframe_netlists.v __openframe_project_wrapper.v \		/* openframe_netlists.v __openframe_project_wrapper.v \	
/* -s caravel_openframe						/* -s caravel_openframe					
/*-----------------------------------------------------------	/*-----------------------------------------------------------

module caravel_openframe (					module caravel_openframe (

    // All top-level I/O are package-facing pins		    // All top-level I/O are package-facing pins

    inout vddio,	// Common 3.3V padframe/ESD power	    inout vddio,	// Common 3.3V padframe/ESD power
    inout vddio_2,	// Common 3.3V padframe/ESD power	    inout vddio_2,	// Common 3.3V padframe/ESD power
    inout vssio,	// Common padframe/ESD ground		    inout vssio,	// Common padframe/ESD ground
    inout vssio_2,	// Common padframe/ESD ground		    inout vssio_2,	// Common padframe/ESD ground
    inout vdda,		// Management 3.3V power		    inout vdda,		// Management 3.3V power
    inout vssa,		// Common analog ground			    inout vssa,		// Common analog ground
    inout vccd,		// Management/Common 1.8V power		    inout vccd,		// Management/Common 1.8V power
    inout vssd,		// Common digital ground		    inout vssd,		// Common digital ground
    inout vdda1,	// User area 1 3.3V power		    inout vdda1,	// User area 1 3.3V power
    inout vdda1_2,	// User area 1 3.3V power		    inout vdda1_2,	// User area 1 3.3V power
    inout vdda2,	// User area 2 3.3V power		    inout vdda2,	// User area 2 3.3V power
    inout vssa1,	// User area 1 analog ground		    inout vssa1,	// User area 1 analog ground
    inout vssa1_2,	// User area 1 analog ground		    inout vssa1_2,	// User area 1 analog ground
    inout vssa2,	// User area 2 analog ground		    inout vssa2,	// User area 2 analog ground
    inout vccd1,	// User area 1 1.8V power		    inout vccd1,	// User area 1 1.8V power
    inout vccd2,	// User area 2 1.8V power		    inout vccd2,	// User area 2 1.8V power
    inout vssd1,	// User area 1 digital ground		    inout vssd1,	// User area 1 digital ground
    inout vssd2,	// User area 2 digital ground		    inout vssd2,	// User area 2 digital ground

    inout [`OPENFRAME_IO_PADS-1:0] gpio,			    inout [`OPENFRAME_IO_PADS-1:0] gpio,
    input resetb	// Reset input (sense inverted)		    input resetb	// Reset input (sense inverted)
);								);

    //-------------------------------------------------------	    //-------------------------------------------------------
    // This value is uniquely defined for each user project.	    // This value is uniquely defined for each user project.
    //-------------------------------------------------------	    //-------------------------------------------------------
    parameter USER_PROJECT_ID = 32'h00000000;			    parameter USER_PROJECT_ID = 32'h00000000;

    // Project Control (pad-facing)				    // Project Control (pad-facing)
    wire [`OPENFRAME_IO_PADS-1:0] gpio_inp_dis;			    wire [`OPENFRAME_IO_PADS-1:0] gpio_inp_dis;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_oeb;			    wire [`OPENFRAME_IO_PADS-1:0] gpio_oeb;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_ib_mode_sel;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_ib_mode_sel;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_vtrip_sel;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_vtrip_sel;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_slow_sel;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_slow_sel;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_holdover;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_holdover;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_analog_en;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_analog_en;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_analog_sel;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_analog_sel;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_analog_pol;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_analog_pol;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_dm0;			    wire [`OPENFRAME_IO_PADS-1:0] gpio_dm0;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_dm1;			    wire [`OPENFRAME_IO_PADS-1:0] gpio_dm1;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_dm2;			    wire [`OPENFRAME_IO_PADS-1:0] gpio_dm2;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_in;			    wire [`OPENFRAME_IO_PADS-1:0] gpio_in;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_in_h;			    wire [`OPENFRAME_IO_PADS-1:0] gpio_in_h;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_out;			    wire [`OPENFRAME_IO_PADS-1:0] gpio_out;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_loopback_zero;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_loopback_zero;
    wire [`OPENFRAME_IO_PADS-1:0] gpio_loopback_one;		    wire [`OPENFRAME_IO_PADS-1:0] gpio_loopback_one;
    wire [`OPENFRAME_IO_PADS-1:0] analog_io;			    wire [`OPENFRAME_IO_PADS-1:0] analog_io;
    wire [`OPENFRAME_IO_PADS-1:0] analog_noesd_io;		    wire [`OPENFRAME_IO_PADS-1:0] analog_noesd_io;

    // Power-on-reset signal.  The simple POR circuit generat	    // Power-on-reset signal.  The simple POR circuit generat
    // three signals, uses them to enable the GPIO, and expor	    // three signals, uses them to enable the GPIO, and expor
    // signals to the core.					    // signals to the core.

    wire porb_h;						    wire porb_h;
    wire porb_l;						    wire porb_l;
    wire por_l;							    wire por_l;

    // Master reset signal.  The reset pad generates the sens	    // Master reset signal.  The reset pad generates the sens
    // reset at 3.3V.  The 1.8V signal is derived.		    // reset at 3.3V.  The 1.8V signal is derived.

    wire rstb_h;						    wire rstb_h;
    wire rstb_l;						    wire rstb_l;

    // Mask revision:  Output from the padframe, exporting th	    // Mask revision:  Output from the padframe, exporting th
    // user ID value.						    // user ID value.

    wire [31:0] mask_rev;					    wire [31:0] mask_rev;

    chip_io_openframe #(					    chip_io_openframe #(
		.USER_PROJECT_ID(USER_PROJECT_ID)				.USER_PROJECT_ID(USER_PROJECT_ID)
	) padframe (							) padframe (
									
	// Pad side power connections					// Pad side power connections
	`ifndef TOP_ROUTING						`ifndef TOP_ROUTING
		// Package Pins							// Package Pins
		.vddio_pad	(vddio),		// Co			.vddio_pad	(vddio),		// Co
		.vddio_pad2	(vddio_2),					.vddio_pad2	(vddio_2),
		.vssio_pad	(vssio),		// Co			.vssio_pad	(vssio),		// Co
		.vssio_pad2	(vssio_2),					.vssio_pad2	(vssio_2),
		.vccd_pad	(vccd),			// Co			.vccd_pad	(vccd),			// Co
		.vssd_pad	(vssd),			// Co			.vssd_pad	(vssd),			// Co
		.vdda_pad	(vdda),			// Ma			.vdda_pad	(vdda),			// Ma
		.vssa_pad	(vssa),			// Ma			.vssa_pad	(vssa),			// Ma
		.vdda1_pad	(vdda1),		// Us			.vdda1_pad	(vdda1),		// Us
		.vdda1_pad2	(vdda1_2),					.vdda1_pad2	(vdda1_2),		
		.vdda2_pad	(vdda2),		// Us			.vdda2_pad	(vdda2),		// Us
		.vssa1_pad	(vssa1),		// Us			.vssa1_pad	(vssa1),		// Us
		.vssa1_pad2	(vssa1_2),					.vssa1_pad2	(vssa1_2),
		.vssa2_pad	(vssa2),		// Us			.vssa2_pad	(vssa2),		// Us
		.vccd1_pad	(vccd1),		// Us			.vccd1_pad	(vccd1),		// Us
		.vccd2_pad	(vccd2),		// Us			.vccd2_pad	(vccd2),		// Us
		.vssd1_pad	(vssd1),		// Us			.vssd1_pad	(vssd1),		// Us
		.vssd2_pad	(vssd2),		// Us			.vssd2_pad	(vssd2),		// Us
	`endif								`endif

	// Pad side signals						// Pad side signals
	.resetb_pad(resetb),						.resetb_pad(resetb),
	.gpio(gpio),							.gpio(gpio),

	// Core side power connections					// Core side power connections
	.vddio	(vddio_core),						.vddio	(vddio_core),
	.vssio	(vssio_core),						.vssio	(vssio_core),
	.vdda	(vdda_core),						.vdda	(vdda_core),
	.vssa	(vssa_core),						.vssa	(vssa_core),
	.vccd	(vccd_core),						.vccd	(vccd_core),
	.vssd	(vssd_core),						.vssd	(vssd_core),
	.vdda1	(vdda1_core),						.vdda1	(vdda1_core),
	.vdda2	(vdda2_core),						.vdda2	(vdda2_core),
	.vssa1	(vssa1_core),						.vssa1	(vssa1_core),
	.vssa2	(vssa2_core),						.vssa2	(vssa2_core),
	.vccd1	(vccd1_core),						.vccd1	(vccd1_core),
	.vccd2	(vccd2_core),						.vccd2	(vccd2_core),
	.vssd1	(vssd1_core),						.vssd1	(vssd1_core),
	.vssd2	(vssd2_core),						.vssd2	(vssd2_core),

	// Core side signals						// Core side signals
	.porb_h(porb_h),						.porb_h(porb_h),
	.porb_l(porb_l),						.porb_l(porb_l),
	.por_l(por_l),							.por_l(por_l),
	.resetb_h(rstb_h),						.resetb_h(rstb_h),
	.resetb_l(rstb_l),						.resetb_l(rstb_l),
	.mask_rev(mask_rev),						.mask_rev(mask_rev),

	.gpio_in(gpio_in),						.gpio_in(gpio_in),
	.gpio_in_h(gpio_in_h),						.gpio_in_h(gpio_in_h),
	.gpio_out(gpio_out),						.gpio_out(gpio_out),
	.gpio_oeb(gpio_oeb),						.gpio_oeb(gpio_oeb),
	.gpio_inp_dis(gpio_inp_dis),					.gpio_inp_dis(gpio_inp_dis),
	.gpio_ib_mode_sel(gpio_ib_mode_sel),				.gpio_ib_mode_sel(gpio_ib_mode_sel),
	.gpio_vtrip_sel(gpio_vtrip_sel),				.gpio_vtrip_sel(gpio_vtrip_sel),
	.gpio_slow_sel(gpio_slow_sel),					.gpio_slow_sel(gpio_slow_sel),
	.gpio_holdover(gpio_holdover),					.gpio_holdover(gpio_holdover),
	.gpio_analog_en(gpio_analog_en),				.gpio_analog_en(gpio_analog_en),
	.gpio_analog_sel(gpio_analog_sel),				.gpio_analog_sel(gpio_analog_sel),
	.gpio_analog_pol(gpio_analog_pol),				.gpio_analog_pol(gpio_analog_pol),
	.gpio_dm0(gpio_dm0),						.gpio_dm0(gpio_dm0),
	.gpio_dm1(gpio_dm1),						.gpio_dm1(gpio_dm1),
	.gpio_dm2(gpio_dm2),						.gpio_dm2(gpio_dm2),
	.gpio_loopback_zero(gpio_loopback_zero),			.gpio_loopback_zero(gpio_loopback_zero),
	.gpio_loopback_one(gpio_loopback_one),				.gpio_loopback_one(gpio_loopback_one),
	.analog_io(analog_io),						.analog_io(analog_io),
	.analog_noesd_io(analog_noesd_io)				.analog_noesd_io(analog_noesd_io)
    );								    );

    /*--------------------------------------------------*/	    /*--------------------------------------------------*/
    /* Wrapper module around the user project 		*/	    /* Wrapper module around the user project 		*/
    /*--------------------------------------------------*/	    /*--------------------------------------------------*/

    openframe_project_wrapper user_project (			    openframe_project_wrapper user_project (
        `ifdef USE_POWER_PINS					        `ifdef USE_POWER_PINS
	    .vdda(vdda_core),						    .vdda(vdda_core),
	    .vssa(vssa_core),						    .vssa(vssa_core),
	    .vccd(vccd_core),						    .vccd(vccd_core),
	    .vssd(vssd_core),						    .vssd(vssd_core),
	    .vdda1(vdda1_core),		// User area 1 3.3V p		    .vdda1(vdda1_core),		// User area 1 3.3V p
	    .vdda2(vdda2_core),		// User area 2 3.3V p		    .vdda2(vdda2_core),		// User area 2 3.3V p
	    .vssa1(vssa1_core),		// User area 1 analog		    .vssa1(vssa1_core),		// User area 1 analog
	    .vssa2(vssa2_core),		// User area 2 analog		    .vssa2(vssa2_core),		// User area 2 analog
	    .vccd1(vccd1_core),		// User area 1 1.8V p		    .vccd1(vccd1_core),		// User area 1 1.8V p
	    .vccd2(vccd2_core),		// User area 2 1.8V p		    .vccd2(vccd2_core),		// User area 2 1.8V p
	    .vssd1(vssd1_core),		// User area 1 digita		    .vssd1(vssd1_core),		// User area 1 digita
	    .vssd2(vssd2_core),		// User area 2 digita		    .vssd2(vssd2_core),		// User area 2 digita
    	`endif							    	`endif

	.porb_h(porb_h),						.porb_h(porb_h),
	.porb_l(porb_l),						.porb_l(porb_l),
	.por_l(por_l),							.por_l(por_l),
	.resetb_h(rstb_h),						.resetb_h(rstb_h),
	.resetb_l(rstb_l),						.resetb_l(rstb_l),
	.mask_rev(mask_rev),						.mask_rev(mask_rev),

	.gpio_in(gpio_in),						.gpio_in(gpio_in),
	.gpio_in_h(gpio_in_h),						.gpio_in_h(gpio_in_h),
	.gpio_out(gpio_out),						.gpio_out(gpio_out),
	.gpio_oeb(gpio_oeb),						.gpio_oeb(gpio_oeb),
	.gpio_inp_dis(gpio_inp_dis),					.gpio_inp_dis(gpio_inp_dis),
	.gpio_ib_mode_sel(gpio_ib_mode_sel),				.gpio_ib_mode_sel(gpio_ib_mode_sel),
	.gpio_vtrip_sel(gpio_vtrip_sel),				.gpio_vtrip_sel(gpio_vtrip_sel),
	.gpio_slow_sel(gpio_slow_sel),					.gpio_slow_sel(gpio_slow_sel),
	.gpio_holdover(gpio_holdover),					.gpio_holdover(gpio_holdover),
	.gpio_analog_en(gpio_analog_en),				.gpio_analog_en(gpio_analog_en),
	.gpio_analog_sel(gpio_analog_sel),				.gpio_analog_sel(gpio_analog_sel),
	.gpio_analog_pol(gpio_analog_pol),				.gpio_analog_pol(gpio_analog_pol),
	.gpio_dm0(gpio_dm0),						.gpio_dm0(gpio_dm0),
	.gpio_dm1(gpio_dm1),						.gpio_dm1(gpio_dm1),
	.gpio_dm2(gpio_dm2),						.gpio_dm2(gpio_dm2),
	.gpio_loopback_zero(gpio_loopback_zero),			.gpio_loopback_zero(gpio_loopback_zero),
	.gpio_loopback_one(gpio_loopback_one),				.gpio_loopback_one(gpio_loopback_one),
	.analog_io(analog_io),						.analog_io(analog_io),
	.analog_noesd_io(analog_noesd_io)				.analog_noesd_io(analog_noesd_io)
    );								    );

    /*------------------------------------------*/		    /*------------------------------------------*/
    /* End user project instantiation		*/		    /* End user project instantiation		*/
    /*------------------------------------------*/		    /*------------------------------------------*/

endmodule							endmodule
// `default_nettype wire					// `default_nettype wire
diff -ry rtl/caravel_power_routing.v verilog/rtl/caravel_power_routing.v
module caravel_power_routing ();				module caravel_power_routing ();
endmodule							endmodule
diff -ry rtl/caravel.v verilog/rtl/caravel.v
 `ifdef SIM							 `ifdef SIM
 `default_nettype wire						 `default_nettype wire
 `endif								 `endif
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

/*-----------------------------------------------------------	/*-----------------------------------------------------------
//* Vsdcaravel, RISC-V SoC Implementation using Synopsys and  |	/* caravel, a project harness for the Google/SkyWater sky130
/* a project for the VSD/Semiconductor Laboratory SCL180      |	/* fabrication process and open source PDK		
/* fabrication process 			                      |	/*                                                          
/*                                                            |	/* Copyright 2020 efabless, Inc.                            
/* Copyright 2025 efabless, Inc. /VSD                         |	/* Written by Tim Edwards, December 2019                    
/* Originally written by Tim Edwards, December 2019           |	/* and Mohamed Shalan, August 2020			    
/* and Mohamed Shalan, August 2020			      |	/* This file is open source hardware released under the     
/* Edited by Dhanvanti Bhavsar and Kunal Ghosh on (11/02/2025 |	/* Apache 2.0 license.  See file LICENSE.                   
/* Updated on 11/02/2025:  Revised using SCL180 PDK	      |	/*							
/* This file is open source hardware released under the       |	/* Updated 10/15/2021:  Revised using the housekeeping module
/* Apache 2.0 license.  See file LICENSE.                     <
/* from housekeeping.v (refactoring a number of functions fro	/* from housekeeping.v (refactoring a number of functions fro
/* the management SoC).						/* the management SoC).					
/*                                                          	/*                                                          
/*-----------------------------------------------------------	/*-----------------------------------------------------------

							      >
							      >	//Include by Ritesh Balaji S
							      >
							      >	`include "caravel_core.v"
`include "copyright_block.v"					`include "copyright_block.v"
`include "caravel_logo.v"					`include "caravel_logo.v"
`include "caravel_motto.v"					`include "caravel_motto.v"
`include "open_source.v"					`include "open_source.v"
`include "user_id_textblock.v"					`include "user_id_textblock.v"
`include "caravel_core.v"				      |

module caravel (						module caravel (
    // All top-level I/O are package-facing pins		    // All top-level I/O are package-facing pins
    inout                     vddio,    // Common 3.3V padfra	    inout                     vddio,    // Common 3.3V padfra
    inout                     vddio_2,  // Common 3.3V padfra	    inout                     vddio_2,  // Common 3.3V padfra
    inout                     vssio,    // Common padframe/ES	    inout                     vssio,    // Common padframe/ES
    inout                     vssio_2,  // Common padframe/ES	    inout                     vssio_2,  // Common padframe/ES
    inout                     vdda,     // Management 3.3V po	    inout                     vdda,     // Management 3.3V po
    inout                     vssa,     // Common analog grou	    inout                     vssa,     // Common analog grou
    inout                     vccd,     // Management/Common 	    inout                     vccd,     // Management/Common 
    inout                     vssd,     // Common digital gro	    inout                     vssd,     // Common digital gro
    inout                     vdda1,    // User area 1 3.3V p	    inout                     vdda1,    // User area 1 3.3V p
    inout                     vdda1_2,  // User area 1 3.3V p	    inout                     vdda1_2,  // User area 1 3.3V p
    inout                     vdda2,    // User area 2 3.3V p	    inout                     vdda2,    // User area 2 3.3V p
    inout                     vssa1,    // User area 1 analog	    inout                     vssa1,    // User area 1 analog
    inout                     vssa1_2,  // User area 1 analog	    inout                     vssa1_2,  // User area 1 analog
    inout                     vssa2,    // User area 2 analog	    inout                     vssa2,    // User area 2 analog
    inout                     vccd1,    // User area 1 1.8V p	    inout                     vccd1,    // User area 1 1.8V p
    inout                     vccd2,    // User area 2 1.8V p	    inout                     vccd2,    // User area 2 1.8V p
    inout                     vssd1,    // User area 1 digita	    inout                     vssd1,    // User area 1 digita
    inout                     vssd2,    // User area 2 digita	    inout                     vssd2,    // User area 2 digita
    inout                     gpio,     // Used for external 	    inout                     gpio,     // Used for external 
    inout [`MPRJ_IO_PADS-1:0] mprj_io,				    inout [`MPRJ_IO_PADS-1:0] mprj_io,
    input                     clock,    // CMOS core clock in	    input                     clock,    // CMOS core clock in
    input                     resetb,   // Reset input (Activ	    input                     resetb,   // Reset input (Activ

    // Note that only two flash data pins are dedicated to th	    // Note that only two flash data pins are dedicated to th
    // management SoC wrapper.  The management SoC exports th	    // management SoC wrapper.  The management SoC exports th
    // quad SPI mode status to make use of the top two mprj_i	    // quad SPI mode status to make use of the top two mprj_i
    // pins for io2 and io3.					    // pins for io2 and io3.
    output flash_csb,						    output flash_csb,
    output flash_clk,						    output flash_clk,
    inout  flash_io0,						    inout  flash_io0,
    inout  flash_io1						    inout  flash_io1
);								);

  //---------------------------------------------------------	  //---------------------------------------------------------
  // This value is uniquely defined for each user project.	  // This value is uniquely defined for each user project.
  //---------------------------------------------------------	  //---------------------------------------------------------
  parameter USER_PROJECT_ID = 32'h00000000;			  parameter USER_PROJECT_ID = 32'h00000000;

  /*								  /*
     *-------------------------------------------------------	     *-------------------------------------------------------
     * These pins are overlaid on mprj_io space. They have th	     * These pins are overlaid on mprj_io space. They have th
     * below when the management processor is in reset, or in	     * below when the management processor is in reset, or in
     * configuration. They are assigned to uses in the user s	     * configuration. They are assigned to uses in the user s
     * configuration program running off of the SPI flash.  N	     * configuration program running off of the SPI flash.  N
     * when the user has taken control of these pins, they ca	     * when the user has taken control of these pins, they ca
     * to the original use by setting the resetb pin low.  Th	     * to the original use by setting the resetb pin low.  Th
     * UART pins can be connected directly to an FTDI chip as	     * UART pins can be connected directly to an FTDI chip as
     * FTDI chip sets these lines to high impedence (input fu	     * FTDI chip sets these lines to high impedence (input fu
     * all times except when holding the chip in reset.		     * all times except when holding the chip in reset.
     *								     *
     * JTAG			= mprj_io[0]		(inou	     * JTAG			= mprj_io[0]		(inou
     * SDO			= mprj_io[1]		(outp	     * SDO			= mprj_io[1]		(outp
     * SDI			= mprj_io[2]		(inpu	     * SDI			= mprj_io[2]		(inpu
     * CSB			= mprj_io[3]		(inpu	     * CSB			= mprj_io[3]		(inpu
     * SCK			= mprj_io[4]		(inpu	     * SCK			= mprj_io[4]		(inpu
     * ser_rx		= mprj_io[5]		(input)		     * ser_rx		= mprj_io[5]		(input)
     * ser_tx		= mprj_io[6]		(output)	     * ser_tx		= mprj_io[6]		(output)
     * irq			= mprj_io[7]		(inpu	     * irq			= mprj_io[7]		(inpu
     *								     *
     * spi_sck		= mprj_io[32]		(output)	     * spi_sck		= mprj_io[32]		(output)
     * spi_csb		= mprj_io[33]		(output)	     * spi_csb		= mprj_io[33]		(output)
     * spi_sdi		= mprj_io[34]		(input)		     * spi_sdi		= mprj_io[34]		(input)
     * spi_sdo		= mprj_io[35]		(output)	     * spi_sdo		= mprj_io[35]		(output)
     * flash_io2	= mprj_io[36]		(inout) 	     * flash_io2	= mprj_io[36]		(inout) 
     * flash_io3	= mprj_io[37]		(inout) 	     * flash_io3	= mprj_io[37]		(inout) 
     *								     *
     * These pins are reserved for any project that wants to 	     * These pins are reserved for any project that wants to 
     * its own processor and flash controller.  While a user 	     * its own processor and flash controller.  While a user 
     * technically use any available I/O pins for the purpose	     * technically use any available I/O pins for the purpose
     * four pins connect to a pass-through mode from the SPI 	     * four pins connect to a pass-through mode from the SPI 
     * 1-4 above) so that any SPI flash connected to these sp	     * 1-4 above) so that any SPI flash connected to these sp
     * can be accessed through the SPI slave even when the pr	     * can be accessed through the SPI slave even when the pr
     * reset.							     * reset.
     *								     *
     * user_flash_csb = mprj_io[8]				     * user_flash_csb = mprj_io[8]
     * user_flash_sck = mprj_io[9]				     * user_flash_sck = mprj_io[9]
     * user_flash_io0 = mprj_io[10]				     * user_flash_io0 = mprj_io[10]
     * user_flash_io1 = mprj_io[11]				     * user_flash_io1 = mprj_io[11]
     *								     *
     *-------------------------------------------------------	     *-------------------------------------------------------
     */								     */

  // One-bit GPIO dedicated to management SoC (outside of use	  // One-bit GPIO dedicated to management SoC (outside of use
  wire gpio_out_core;						  wire gpio_out_core;
  wire gpio_in_core;						  wire gpio_in_core;
  wire gpio_mode0_core;						  wire gpio_mode0_core;
  wire gpio_mode1_core;						  wire gpio_mode1_core;
  wire gpio_outenb_core;					  wire gpio_outenb_core;
  wire gpio_inenb_core;						  wire gpio_inenb_core;

  // User Project Control (pad-facing)				  // User Project Control (pad-facing)
  wire [`MPRJ_IO_PADS-1:0] mprj_io_inp_dis;			  wire [`MPRJ_IO_PADS-1:0] mprj_io_inp_dis;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_oeb;				  wire [`MPRJ_IO_PADS-1:0] mprj_io_oeb;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_ib_mode_sel;			  wire [`MPRJ_IO_PADS-1:0] mprj_io_ib_mode_sel;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_vtrip_sel;			  wire [`MPRJ_IO_PADS-1:0] mprj_io_vtrip_sel;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_slow_sel;			  wire [`MPRJ_IO_PADS-1:0] mprj_io_slow_sel;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_holdover;			  wire [`MPRJ_IO_PADS-1:0] mprj_io_holdover;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_analog_en;			  wire [`MPRJ_IO_PADS-1:0] mprj_io_analog_en;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_analog_sel;			  wire [`MPRJ_IO_PADS-1:0] mprj_io_analog_sel;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_analog_pol;			  wire [`MPRJ_IO_PADS-1:0] mprj_io_analog_pol;
  wire [`MPRJ_IO_PADS*3-1:0] mprj_io_dm;			  wire [`MPRJ_IO_PADS*3-1:0] mprj_io_dm;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_in;				  wire [`MPRJ_IO_PADS-1:0] mprj_io_in;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_out;				  wire [`MPRJ_IO_PADS-1:0] mprj_io_out;
  wire [`MPRJ_IO_PADS-1:0] mprj_io_one;				  wire [`MPRJ_IO_PADS-1:0] mprj_io_one;

  // User Project Control (user-facing)				  // User Project Control (user-facing)
  // NOT NEEDED						      <
  wire [`MPRJ_IO_PADS-10:0] user_analog_io;			  wire [`MPRJ_IO_PADS-10:0] user_analog_io;

  // User Project Control management I/O			  // User Project Control management I/O
  // There are two types of GPIO connections:			  // There are two types of GPIO connections:
  // (1) Full Bidirectional: Management connects to in, out, 	  // (1) Full Bidirectional: Management connects to in, out, 
  //     Uses:  JTAG and SDO					  //     Uses:  JTAG and SDO
  // (2) Selectable bidirectional:  Management connects to in	  // (2) Selectable bidirectional:  Management connects to in
  //	   which are tied together.  oeb is grounded (oeb fro	  //	   which are tied together.  oeb is grounded (oeb fro
  //	   configuration is used)				  //	   configuration is used)

  // SDI		= mprj_io[2]		(input)		  // SDI		= mprj_io[2]		(input)
  // CSB		= mprj_io[3]		(input)		  // CSB		= mprj_io[3]		(input)
  // SCK		= mprj_io[4]		(input)		  // SCK		= mprj_io[4]		(input)
  // ser_rx	= mprj_io[5]		(input)			  // ser_rx	= mprj_io[5]		(input)
  // ser_tx	= mprj_io[6]		(output)		  // ser_tx	= mprj_io[6]		(output)
  // irq		= mprj_io[7]		(input)		  // irq		= mprj_io[7]		(input)

  wire clock_core;						  wire clock_core;

  // Power-on-reset signal.  The reset pad generates the sens	  // Power-on-reset signal.  The reset pad generates the sens
  // reset at 3.3V.  The 1.8V signal and the inverted 1.8V si	  // reset at 3.3V.  The 1.8V signal and the inverted 1.8V si
  // derived.							  // derived.

  wire porb_h;							  wire porb_h;
  wire porb_l;							  wire porb_l;
  wire por_l;							  wire por_l;

  wire rstb_h;							  wire rstb_h;

  // Flash SPI communication (					  // Flash SPI communication (
  wire flash_clk_frame;						  wire flash_clk_frame;
  wire flash_csb_frame;						  wire flash_csb_frame;
  wire flash_clk_oeb, flash_csb_oeb;				  wire flash_clk_oeb, flash_csb_oeb;
  wire flash_clk_ieb, flash_csb_ieb;				  wire flash_clk_ieb, flash_csb_ieb;
  wire flash_io0_oeb, flash_io1_oeb;				  wire flash_io0_oeb, flash_io1_oeb;
  wire flash_io0_ieb, flash_io1_ieb;				  wire flash_io0_ieb, flash_io1_ieb;
  wire flash_io0_do, flash_io1_do;				  wire flash_io0_do, flash_io1_do;
  wire flash_io0_di, flash_io1_di;				  wire flash_io0_di, flash_io1_di;

  wire vddio_core;						  wire vddio_core;
  wire vssio_core;						  wire vssio_core;
  wire vdda_core;						  wire vdda_core;
  wire vssa_core;						  wire vssa_core;
  wire vccd_core;						  wire vccd_core;
  wire vssd_core;						  wire vssd_core;
  wire vdda1_core;						  wire vdda1_core;
  wire vdda2_core;						  wire vdda2_core;
  wire vssa1_core;						  wire vssa1_core;
  wire vssa2_core;						  wire vssa2_core;
  wire vccd1_core;						  wire vccd1_core;
  wire vccd2_core;						  wire vccd2_core;
  wire vssd1_core;						  wire vssd1_core;
  wire vssd2_core;						  wire vssd2_core;

  chip_io padframe (						  chip_io padframe (
`ifndef TOP_ROUTING						`ifndef TOP_ROUTING
      // Package Pins						      // Package Pins
      .vddio_pad(vddio),  // Common padframe/ESD supply		      .vddio_pad(vddio),  // Common padframe/ESD supply
      .vddio_pad2(vddio_2),					      .vddio_pad2(vddio_2),
      .vssio_pad(vssio),  // Common padframe/ESD ground		      .vssio_pad(vssio),  // Common padframe/ESD ground
      .vssio_pad2(vssio_2),					      .vssio_pad2(vssio_2),
      .vccd_pad(vccd),  // Common 1.8V supply			      .vccd_pad(vccd),  // Common 1.8V supply
      .vssd_pad(vssd),  // Common digital ground		      .vssd_pad(vssd),  // Common digital ground
      .vdda_pad(vdda),  // Management analog 3.3V supply	      .vdda_pad(vdda),  // Management analog 3.3V supply
      .vssa_pad(vssa),  // Management analog ground		      .vssa_pad(vssa),  // Management analog ground
      .vdda1_pad(vdda1),  // User area 1 3.3V supply		      .vdda1_pad(vdda1),  // User area 1 3.3V supply
      .vdda1_pad2(vdda1_2),					      .vdda1_pad2(vdda1_2),
      .vdda2_pad(vdda2),  // User area 2 3.3V supply		      .vdda2_pad(vdda2),  // User area 2 3.3V supply
      .vssa1_pad(vssa1),  // User area 1 analog ground		      .vssa1_pad(vssa1),  // User area 1 analog ground
      .vssa1_pad2(vssa1_2),					      .vssa1_pad2(vssa1_2),
      .vssa2_pad(vssa2),  // User area 2 analog ground		      .vssa2_pad(vssa2),  // User area 2 analog ground
      .vccd1_pad(vccd1),  // User area 1 1.8V supply		      .vccd1_pad(vccd1),  // User area 1 1.8V supply
      .vccd2_pad(vccd2),  // User area 2 1.8V supply		      .vccd2_pad(vccd2),  // User area 2 1.8V supply
      .vssd1_pad(vssd1),  // User area 1 digital ground		      .vssd1_pad(vssd1),  // User area 1 digital ground
      .vssd2_pad(vssd2),  // User area 2 digital ground		      .vssd2_pad(vssd2),  // User area 2 digital ground
      .vddio(vddio_core),					      .vddio(vddio_core),
      .vssio(vssio_core),					      .vssio(vssio_core),
      .vdda(vdda_core),						      .vdda(vdda_core),
      .vssa(vssa_core),						      .vssa(vssa_core),
      .vccd(vccd_core),						      .vccd(vccd_core),
      .vssd(vssd_core),						      .vssd(vssd_core),
      .vdda1(vdda1_core),					      .vdda1(vdda1_core),
      .vdda2(vdda2_core),					      .vdda2(vdda2_core),
      .vssa1(vssa1_core),					      .vssa1(vssa1_core),
      .vssa2(vssa2_core),					      .vssa2(vssa2_core),
      .vccd1(vccd1_core),					      .vccd1(vccd1_core),
      .vccd2(vccd2_core),					      .vccd2(vccd2_core),
      .vssd1(vssd1_core),					      .vssd1(vssd1_core),
      .vssd2(vssd2_core),					      .vssd2(vssd2_core),
      								      
      // Core Side Pins						      // Core Side Pins
      .gpio(gpio),						      .gpio(gpio),
      .mprj_io(mprj_io),					      .mprj_io(mprj_io),
      .clock(clock),						      .clock(clock),
      .resetb(resetb),						      .resetb(resetb),
      .flash_csb(flash_csb),					      .flash_csb(flash_csb),
      .flash_clk(flash_clk),					      .flash_clk(flash_clk),
      .flash_io0(flash_io0),					      .flash_io0(flash_io0),
      .flash_io1(flash_io1),					      .flash_io1(flash_io1),
`endif								`endif

      // SoC Core Interface					      // SoC Core Interface
      .porb_h(porb_h),						      .porb_h(porb_h),
      .por(por_l),						      .por(por_l),
      .resetb_core_h(rstb_h),					      .resetb_core_h(rstb_h),
      .clock_core(clock_core),					      .clock_core(clock_core),
      .gpio_out_core(gpio_out_core),				      .gpio_out_core(gpio_out_core),
      .gpio_in_core(gpio_in_core),				      .gpio_in_core(gpio_in_core),
      .gpio_mode0_core(gpio_mode0_core),			      .gpio_mode0_core(gpio_mode0_core),
      .gpio_mode1_core(gpio_mode1_core),			      .gpio_mode1_core(gpio_mode1_core),
      .gpio_outenb_core(gpio_outenb_core),			      .gpio_outenb_core(gpio_outenb_core),
      .gpio_inenb_core(gpio_inenb_core),			      .gpio_inenb_core(gpio_inenb_core),
      .flash_csb_core(flash_csb_frame),				      .flash_csb_core(flash_csb_frame),
      .flash_clk_core(flash_clk_frame),				      .flash_clk_core(flash_clk_frame),
      .flash_csb_oeb_core(flash_csb_oeb),			      .flash_csb_oeb_core(flash_csb_oeb),
      .flash_clk_oeb_core(flash_clk_oeb),			      .flash_clk_oeb_core(flash_clk_oeb),
      .flash_io0_oeb_core(flash_io0_oeb),			      .flash_io0_oeb_core(flash_io0_oeb),
      .flash_io1_oeb_core(flash_io1_oeb),			      .flash_io1_oeb_core(flash_io1_oeb),
      .flash_io0_ieb_core(flash_io0_ieb),			      .flash_io0_ieb_core(flash_io0_ieb),
      .flash_io1_ieb_core(flash_io1_ieb),			      .flash_io1_ieb_core(flash_io1_ieb),
      .flash_io0_do_core(flash_io0_do),				      .flash_io0_do_core(flash_io0_do),
      .flash_io1_do_core(flash_io1_do),				      .flash_io1_do_core(flash_io1_do),
      .flash_io0_di_core(flash_io0_di),				      .flash_io0_di_core(flash_io0_di),
      .flash_io1_di_core(flash_io1_di),				      .flash_io1_di_core(flash_io1_di),
      .mprj_io_one(mprj_io_one),				      .mprj_io_one(mprj_io_one),
      .mprj_io_in(mprj_io_in),					      .mprj_io_in(mprj_io_in),
      .mprj_io_out(mprj_io_out),				      .mprj_io_out(mprj_io_out),
      .mprj_io_oeb(mprj_io_oeb),				      .mprj_io_oeb(mprj_io_oeb),
      .mprj_io_inp_dis(mprj_io_inp_dis),			      .mprj_io_inp_dis(mprj_io_inp_dis),
      .mprj_io_ib_mode_sel(mprj_io_ib_mode_sel),		      .mprj_io_ib_mode_sel(mprj_io_ib_mode_sel),
      .mprj_io_vtrip_sel(mprj_io_vtrip_sel),			      .mprj_io_vtrip_sel(mprj_io_vtrip_sel),
      .mprj_io_slow_sel(mprj_io_slow_sel),			      .mprj_io_slow_sel(mprj_io_slow_sel),
      .mprj_io_holdover(mprj_io_holdover),			      .mprj_io_holdover(mprj_io_holdover),
      .mprj_io_analog_en(mprj_io_analog_en),			      .mprj_io_analog_en(mprj_io_analog_en),
      .mprj_io_analog_sel(mprj_io_analog_sel),			      .mprj_io_analog_sel(mprj_io_analog_sel),
      .mprj_io_analog_pol(mprj_io_analog_pol),			      .mprj_io_analog_pol(mprj_io_analog_pol),
      .mprj_io_dm(mprj_io_dm),					      .mprj_io_dm(mprj_io_dm),
      .mprj_analog_io(user_analog_io)				      .mprj_analog_io(user_analog_io)
  );								  );

  caravel_core chip_core (					  caravel_core chip_core (
      // All top-level I/O are package-facing pins		      // All top-level I/O are package-facing pins
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
      .vddio(vddio_core),  // Common 3.3V padframe/ESD power	      .vddio(vddio_core),  // Common 3.3V padframe/ESD power
      .vssio(vssio_core),  // Common padframe/ESD ground	      .vssio(vssio_core),  // Common padframe/ESD ground
//    .vdda (vdda_core),   // Management 3.3V power		//    .vdda (vdda_core),   // Management 3.3V power
//    .vssa (vssa_core),   // Common analog ground		//    .vssa (vssa_core),   // Common analog ground
      .vccd (vccd_core),   // Management/Common 1.8V power	      .vccd (vccd_core),   // Management/Common 1.8V power
      .vssd (vssd_core),   // Common digital ground		      .vssd (vssd_core),   // Common digital ground
      .vdda1(vdda1_core),  // User area 1 3.3V power		      .vdda1(vdda1_core),  // User area 1 3.3V power
      .vdda2(vdda2_core),  // User area 2 3.3V power		      .vdda2(vdda2_core),  // User area 2 3.3V power
      .vssa1(vssa1_core),  // User area 1 analog ground		      .vssa1(vssa1_core),  // User area 1 analog ground
      .vssa2(vssa2_core),  // User area 2 analog ground		      .vssa2(vssa2_core),  // User area 2 analog ground
      .vccd1(vccd1_core),  // User area 1 1.8V power		      .vccd1(vccd1_core),  // User area 1 1.8V power
      .vccd2(vccd2_core),  // User area 2 1.8V power		      .vccd2(vccd2_core),  // User area 2 1.8V power
      .vssd1(vssd1_core),  // User area 1 digital ground	      .vssd1(vssd1_core),  // User area 1 digital ground
      .vssd2(vssd2_core),  // User area 2 digital ground	      .vssd2(vssd2_core),  // User area 2 digital ground
`endif								`endif

      // SoC Core Interface					      // SoC Core Interface
      .porb_h(porb_h),						      .porb_h(porb_h),
      .por_l(por_l),						      .por_l(por_l),
      .rstb_h(rstb_h),						      .rstb_h(rstb_h),
      .clock_core(clock_core),					      .clock_core(clock_core),
      .gpio_out_core(gpio_out_core),				      .gpio_out_core(gpio_out_core),
      .gpio_in_core(gpio_in_core),				      .gpio_in_core(gpio_in_core),
      .gpio_mode0_core(gpio_mode0_core),			      .gpio_mode0_core(gpio_mode0_core),
      .gpio_mode1_core(gpio_mode1_core),			      .gpio_mode1_core(gpio_mode1_core),
      .gpio_outenb_core(gpio_outenb_core),			      .gpio_outenb_core(gpio_outenb_core),
      .gpio_inenb_core(gpio_inenb_core),			      .gpio_inenb_core(gpio_inenb_core),

      // Flash SPI communication				      // Flash SPI communication
      .flash_csb_frame(flash_csb_frame),			      .flash_csb_frame(flash_csb_frame),
      .flash_clk_frame(flash_clk_frame),			      .flash_clk_frame(flash_clk_frame),
      .flash_csb_oeb(flash_csb_oeb),				      .flash_csb_oeb(flash_csb_oeb),
      .flash_clk_oeb(flash_clk_oeb),				      .flash_clk_oeb(flash_clk_oeb),
      .flash_io0_oeb(flash_io0_oeb),				      .flash_io0_oeb(flash_io0_oeb),
      .flash_io1_oeb(flash_io1_oeb),				      .flash_io1_oeb(flash_io1_oeb),
      .flash_io0_ieb(flash_io0_ieb),				      .flash_io0_ieb(flash_io0_ieb),
      .flash_io1_ieb(flash_io1_ieb),				      .flash_io1_ieb(flash_io1_ieb),
      .flash_io0_do(flash_io0_do),				      .flash_io0_do(flash_io0_do),
      .flash_io1_do(flash_io1_do),				      .flash_io1_do(flash_io1_do),
      .flash_io0_di(flash_io0_di),				      .flash_io0_di(flash_io0_di),
      .flash_io1_di(flash_io1_di),				      .flash_io1_di(flash_io1_di),

      // User project IOs					      // User project IOs
      .mprj_io_in(mprj_io_in),					      .mprj_io_in(mprj_io_in),
      .mprj_io_out(mprj_io_out),				      .mprj_io_out(mprj_io_out),
      .mprj_io_oeb(mprj_io_oeb),				      .mprj_io_oeb(mprj_io_oeb),
      .mprj_io_inp_dis(mprj_io_inp_dis),			      .mprj_io_inp_dis(mprj_io_inp_dis),
      .mprj_io_ib_mode_sel(mprj_io_ib_mode_sel),		      .mprj_io_ib_mode_sel(mprj_io_ib_mode_sel),
      .mprj_io_vtrip_sel(mprj_io_vtrip_sel),			      .mprj_io_vtrip_sel(mprj_io_vtrip_sel),
      .mprj_io_slow_sel(mprj_io_slow_sel),			      .mprj_io_slow_sel(mprj_io_slow_sel),
      .mprj_io_holdover(mprj_io_holdover),			      .mprj_io_holdover(mprj_io_holdover),
      .mprj_io_analog_en(mprj_io_analog_en),			      .mprj_io_analog_en(mprj_io_analog_en),
      .mprj_io_analog_sel(mprj_io_analog_sel),			      .mprj_io_analog_sel(mprj_io_analog_sel),
      .mprj_io_analog_pol(mprj_io_analog_pol),			      .mprj_io_analog_pol(mprj_io_analog_pol),
      .mprj_io_dm(mprj_io_dm),					      .mprj_io_dm(mprj_io_dm),

      // Loopbacks to constant value 1 in the 1.8V domain	      // Loopbacks to constant value 1 in the 1.8V domain
      .mprj_io_one(mprj_io_one),				      .mprj_io_one(mprj_io_one),

      // User project direct access to gpio pad connections f	      // User project direct access to gpio pad connections f
      // (all but the lowest-numbered 7 pads)			      // (all but the lowest-numbered 7 pads)
      .mprj_analog_io(user_analog_io)				      .mprj_analog_io(user_analog_io)
  );								  );

copyright_block copyright_block();				copyright_block copyright_block();
caravel_logo caravel_logo();					caravel_logo caravel_logo();
caravel_motto caravel_motto();					caravel_motto caravel_motto();
open_source open_source();					open_source open_source();
user_id_textblock user_id_textblock();				user_id_textblock user_id_textblock();

endmodule							endmodule
// `default_nettype wire					// `default_nettype wire
Only in verilog/rtl: chip_io_alt.v
Only in verilog/rtl: chip_io_openframe.v
diff -ry rtl/chip_io.v verilog/rtl/chip_io.v
// SPDX-FileCopyrightText: 2020 Efabless Corporation		// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

// `default_nettype none					// `default_nettype none
module chip_io(							module chip_io(
	// Package Pins							// Package Pins
	inout  vddio_pad,		// Common padframe/ES		inout  vddio_pad,		// Common padframe/ES
	inout  vddio_pad2,						inout  vddio_pad2,
	inout  vssio_pad,		// Common padframe/ES		inout  vssio_pad,		// Common padframe/ES
	inout  vssio_pad2,						inout  vssio_pad2,
	inout  vccd_pad,		// Common 1.8V supply		inout  vccd_pad,		// Common 1.8V supply
	inout  vssd_pad,		// Common digital gro		inout  vssd_pad,		// Common digital gro
	inout  vdda_pad,		// Management analog 		inout  vdda_pad,		// Management analog 
	inout  vssa_pad,		// Management analog 		inout  vssa_pad,		// Management analog 
	inout  vdda1_pad,		// User area 1 3.3V s		inout  vdda1_pad,		// User area 1 3.3V s
	inout  vdda1_pad2,						inout  vdda1_pad2,		
	inout  vdda2_pad,		// User area 2 3.3V s		inout  vdda2_pad,		// User area 2 3.3V s
	inout  vssa1_pad,		// User area 1 analog		inout  vssa1_pad,		// User area 1 analog
	inout  vssa1_pad2,						inout  vssa1_pad2,
	inout  vssa2_pad,		// User area 2 analog		inout  vssa2_pad,		// User area 2 analog
	inout  vccd1_pad,		// User area 1 1.8V s		inout  vccd1_pad,		// User area 1 1.8V s
	inout  vccd2_pad,		// User area 2 1.8V s		inout  vccd2_pad,		// User area 2 1.8V s
	inout  vssd1_pad,		// User area 1 digita		inout  vssd1_pad,		// User area 1 digita
	inout  vssd2_pad,		// User area 2 digita		inout  vssd2_pad,		// User area 2 digita

	// Core Side							// Core Side
	inout  vddio,		// Common padframe/ESD supply		inout  vddio,		// Common padframe/ESD supply
	inout  vssio,		// Common padframe/ESD ground		inout  vssio,		// Common padframe/ESD ground
	inout  vccd,		// Common 1.8V supply			inout  vccd,		// Common 1.8V supply
	inout  vssd,		// Common digital ground		inout  vssd,		// Common digital ground
	inout  vdda,		// Management analog 3.3V sup		inout  vdda,		// Management analog 3.3V sup
	inout  vssa,		// Management analog ground		inout  vssa,		// Management analog ground
	inout  vdda1,		// User area 1 3.3V supply		inout  vdda1,		// User area 1 3.3V supply
	inout  vdda2,		// User area 2 3.3V supply		inout  vdda2,		// User area 2 3.3V supply
	inout  vssa1,		// User area 1 analog ground		inout  vssa1,		// User area 1 analog ground
	inout  vssa2,		// User area 2 analog ground		inout  vssa2,		// User area 2 analog ground
	inout  vccd1,		// User area 1 1.8V supply		inout  vccd1,		// User area 1 1.8V supply
	inout  vccd2,		// User area 2 1.8V supply		inout  vccd2,		// User area 2 1.8V supply
	inout  vssd1,		// User area 1 digital ground		inout  vssd1,		// User area 1 digital ground
	inout  vssd2,		// User area 2 digital ground		inout  vssd2,		// User area 2 digital ground

	inout  gpio,							inout  gpio,
	input  clock,							input  clock,
	input  resetb,							input  resetb,
	output flash_csb,						output flash_csb,
	output flash_clk,						output flash_clk,
	inout  flash_io0,						inout  flash_io0,
	inout  flash_io1,						inout  flash_io1,
	// Chip Core Interface						// Chip Core Interface
	input  porb_h,							input  porb_h,
	input  por,							input  por,
	output resetb_core_h,						output resetb_core_h,
	output clock_core,						output clock_core,
	input  gpio_out_core,						input  gpio_out_core,
	output gpio_in_core,						output gpio_in_core,
	input  gpio_mode0_core,						input  gpio_mode0_core,
	input  gpio_mode1_core,						input  gpio_mode1_core,
	input  gpio_outenb_core,					input  gpio_outenb_core,
	input  gpio_inenb_core,						input  gpio_inenb_core,
	input  flash_csb_core,						input  flash_csb_core,
	input  flash_clk_core,						input  flash_clk_core,
	input  flash_csb_oeb_core,					input  flash_csb_oeb_core,
	input  flash_clk_oeb_core,					input  flash_clk_oeb_core,
	input  flash_io0_oeb_core,					input  flash_io0_oeb_core,
	input  flash_io1_oeb_core,					input  flash_io1_oeb_core,
	input  flash_io0_ieb_core,					input  flash_io0_ieb_core,
	input  flash_io1_ieb_core,					input  flash_io1_ieb_core,
	input  flash_io0_do_core,					input  flash_io0_do_core,
	input  flash_io1_do_core,					input  flash_io1_do_core,
	output flash_io0_di_core,					output flash_io0_di_core,
	output flash_io1_di_core,					output flash_io1_di_core,
	// User project IOs						// User project IOs
	inout [`MPRJ_IO_PADS-1:0] mprj_io,				inout [`MPRJ_IO_PADS-1:0] mprj_io,
	input [`MPRJ_IO_PADS-1:0] mprj_io_out,				input [`MPRJ_IO_PADS-1:0] mprj_io_out,
	input [`MPRJ_IO_PADS-1:0] mprj_io_oeb,				input [`MPRJ_IO_PADS-1:0] mprj_io_oeb,
	input [`MPRJ_IO_PADS-1:0] mprj_io_inp_dis,			input [`MPRJ_IO_PADS-1:0] mprj_io_inp_dis,
	input [`MPRJ_IO_PADS-1:0] mprj_io_ib_mode_sel,			input [`MPRJ_IO_PADS-1:0] mprj_io_ib_mode_sel,
	input [`MPRJ_IO_PADS-1:0] mprj_io_vtrip_sel,			input [`MPRJ_IO_PADS-1:0] mprj_io_vtrip_sel,
	input [`MPRJ_IO_PADS-1:0] mprj_io_slow_sel,			input [`MPRJ_IO_PADS-1:0] mprj_io_slow_sel,
	input [`MPRJ_IO_PADS-1:0] mprj_io_holdover,			input [`MPRJ_IO_PADS-1:0] mprj_io_holdover,
	input [`MPRJ_IO_PADS-1:0] mprj_io_analog_en,			input [`MPRJ_IO_PADS-1:0] mprj_io_analog_en,
	input [`MPRJ_IO_PADS-1:0] mprj_io_analog_sel,			input [`MPRJ_IO_PADS-1:0] mprj_io_analog_sel,
	input [`MPRJ_IO_PADS-1:0] mprj_io_analog_pol,			input [`MPRJ_IO_PADS-1:0] mprj_io_analog_pol,
	input [`MPRJ_IO_PADS*3-1:0] mprj_io_dm,				input [`MPRJ_IO_PADS*3-1:0] mprj_io_dm,
	output [`MPRJ_IO_PADS-1:0] mprj_io_in,				output [`MPRJ_IO_PADS-1:0] mprj_io_in,
	// Loopbacks to constant value 1 in the 1.8V domain		// Loopbacks to constant value 1 in the 1.8V domain
	input [`MPRJ_IO_PADS-1:0] mprj_io_one,				input [`MPRJ_IO_PADS-1:0] mprj_io_one,
	// User project direct access to gpio pad connections		// User project direct access to gpio pad connections
	// (all but the lowest-numbered 7 pads)				// (all but the lowest-numbered 7 pads)
	inout [`MPRJ_IO_PADS-10:0] mprj_analog_io			inout [`MPRJ_IO_PADS-10:0] mprj_analog_io
);								);

    // Note: analog_io connections are not supported in SCL18	    // Note: analog_io connections are not supported in SCL18
    // These remain as ports for compatibility but are not co	    // These remain as ports for compatibility but are not co

    wire [`MPRJ_IO_PADS-1:0] mprj_io_enh;			    wire [`MPRJ_IO_PADS-1:0] mprj_io_enh;
    assign mprj_io_enh = {`MPRJ_IO_PADS{porb_h}};		    assign mprj_io_enh = {`MPRJ_IO_PADS{porb_h}};
									
	wire analog_a, analog_b;					wire analog_a, analog_b;
	wire vddio_q, vssio_q;						wire vddio_q, vssio_q;

	// ==================================================		// ==================================================
	// SCL180 POWER PADS - Replacing Sky130 ESD Clamp Pad		// SCL180 POWER PADS - Replacing Sky130 ESD Clamp Pad
	// Note: SCL180 has no integrated ESD clamps - add ex		// Note: SCL180 has no integrated ESD clamps - add ex
	// ==================================================		// ==================================================

	// Management domain VDDIO pads (replacing hvclamp pa		// Management domain VDDIO pads (replacing hvclamp pa
    	pvda mgmt_vddio_pad_0 (.VDDO(vddio_pad));		    	pvda mgmt_vddio_pad_0 (.VDDO(vddio_pad));
    	pvda mgmt_vddio_pad_1 (.VDDO(vddio_pad2));		    	pvda mgmt_vddio_pad_1 (.VDDO(vddio_pad2));

	// Management domain VDDA pad					// Management domain VDDA pad
    	pvda mgmt_vdda_pad (.VDDO(vdda_pad));			    	pvda mgmt_vdda_pad (.VDDO(vdda_pad));

	// Management domain VCCD pad					// Management domain VCCD pad
    	pvdi mgmt_vccd_pad (.VDD(vccd_pad));			    	pvdi mgmt_vccd_pad (.VDD(vccd_pad));

	// Management domain VSSIO pads					// Management domain VSSIO pads
    	pv0a mgmt_vssio_pad_0 (.VSSO(vssio_pad));		    	pv0a mgmt_vssio_pad_0 (.VSSO(vssio_pad));
    	pv0a mgmt_vssio_pad_1 (.VSSO(vssio_pad2));		    	pv0a mgmt_vssio_pad_1 (.VSSO(vssio_pad2));

	// Management domain VSSA pad					// Management domain VSSA pad
    	pv0a mgmt_vssa_pad (.VSSO(vssa_pad));			    	pv0a mgmt_vssa_pad (.VSSO(vssa_pad));

	// Management domain VSSD pad					// Management domain VSSD pad
    	pv0i mgmt_vssd_pad (.VSS(vssd_pad));			    	pv0i mgmt_vssd_pad (.VSS(vssd_pad));

	// User area 1 VDDA pads					// User area 1 VDDA pads
    	pvda user1_vdda_pad_0 (.VDDO(vdda1_pad));		    	pvda user1_vdda_pad_0 (.VDDO(vdda1_pad));
	pvda user1_vdda_pad_1 (.VDDO(vdda1_pad2));			pvda user1_vdda_pad_1 (.VDDO(vdda1_pad2));

	// User area 1 VCCD pad						// User area 1 VCCD pad
    	pvdi user1_vccd_pad (.VDD(vccd1_pad));			    	pvdi user1_vccd_pad (.VDD(vccd1_pad));

	// User area 1 VSSA pads					// User area 1 VSSA pads
    	pv0a user1_vssa_pad_0 (.VSSO(vssa1_pad));		    	pv0a user1_vssa_pad_0 (.VSSO(vssa1_pad));
    	pv0a user1_vssa_pad_1 (.VSSO(vssa1_pad2));		    	pv0a user1_vssa_pad_1 (.VSSO(vssa1_pad2));

	// User area 1 VSSD pad						// User area 1 VSSD pad
    	pv0i user1_vssd_pad (.VSS(vssd1_pad));			    	pv0i user1_vssd_pad (.VSS(vssd1_pad));

	// User area 2 VDDA pad						// User area 2 VDDA pad
    	pvda user2_vdda_pad (.VDDO(vdda2_pad));			    	pvda user2_vdda_pad (.VDDO(vdda2_pad));

	// User area 2 VCCD pad						// User area 2 VCCD pad
    	pvdi user2_vccd_pad (.VDD(vccd2_pad));			    	pvdi user2_vccd_pad (.VDD(vccd2_pad));

	// User area 2 VSSA pad						// User area 2 VSSA pad
    	pv0a user2_vssa_pad (.VSSO(vssa2_pad));			    	pv0a user2_vssa_pad (.VSSO(vssa2_pad));

	// User area 2 VSSD pad						// User area 2 VSSD pad
    	pv0i user2_vssd_pad (.VSS(vssd2_pad));			    	pv0i user2_vssd_pad (.VSS(vssd2_pad));

	// ==================================================		// ==================================================
	// MODE CONTROL SIGNAL TRANSLATION				// MODE CONTROL SIGNAL TRANSLATION
	// Sky130 uses dm[2:0], SCL180 uses OEN (active low) 		// Sky130 uses dm[2:0], SCL180 uses OEN (active low) 
	// ==================================================		// ==================================================
									
	wire [2:0] dm_all = {gpio_mode1_core, gpio_mode1_core		wire [2:0] dm_all = {gpio_mode1_core, gpio_mode1_core
	wire[2:0] flash_io0_mode = {flash_io0_ieb_core, flash		wire[2:0] flash_io0_mode = {flash_io0_ieb_core, flash
	wire[2:0] flash_io1_mode = {flash_io1_ieb_core, flash		wire[2:0] flash_io1_mode = {flash_io1_ieb_core, flash

    	wire [6:0] vccd_const_one;	// Constant value for	    	wire [6:0] vccd_const_one;	// Constant value for
    	wire [6:0] vssd_const_zero;	// Constant value for	    	wire [6:0] vssd_const_zero;	// Constant value for

    	constant_block constant_value_inst [6:0] (		    	constant_block constant_value_inst [6:0] (
	`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
		.vccd(vccd),							.vccd(vccd),
		.vssd(vssd),							.vssd(vssd),
	`endif								`endif
		.one(vccd_const_one),						.one(vccd_const_one),
		.zero(vssd_const_zero)						.zero(vssd_const_zero)
    	);							    	);

	// ==================================================		// ==================================================
	// MANAGEMENT SIGNAL PADS - Using SCL180 I/O cells		// MANAGEMENT SIGNAL PADS - Using SCL180 I/O cells
	// ==================================================		// ==================================================

	// Management clock input pad					// Management clock input pad
	pc3d01 clock_pad (						pc3d01 clock_pad (
		.PAD(clock),							.PAD(clock),
		.CIN(clock_core)						.CIN(clock_core)
	);								);

	// Management GPIO pad (bidirectional)				// Management GPIO pad (bidirectional)
	pc3b03ed gpio_pad (						pc3b03ed gpio_pad (
		.PAD(gpio),							.PAD(gpio),
		.OEN(gpio_outenb_core),						.OEN(gpio_outenb_core),
		.RENB(1'b1),  // Pull-down disabled				.RENB(1'b1),  // Pull-down disabled
		.I(gpio_out_core),						.I(gpio_out_core),
		.CIN(gpio_in_core)						.CIN(gpio_in_core)
	);								);

	// Management Flash SPI pads					// Management Flash SPI pads
	pc3b03ed flash_io0_pad (					pc3b03ed flash_io0_pad (
		.PAD(flash_io0),						.PAD(flash_io0),
		.OEN(flash_io0_oeb_core),					.OEN(flash_io0_oeb_core),
		.RENB(1'b1),							.RENB(1'b1),
		.I(flash_io0_do_core),						.I(flash_io0_do_core),
		.CIN(flash_io0_di_core)						.CIN(flash_io0_di_core)
	);								);
									
	pc3b03ed flash_io1_pad (					pc3b03ed flash_io1_pad (
		.PAD(flash_io1),						.PAD(flash_io1),
		.OEN(flash_io1_oeb_core),					.OEN(flash_io1_oeb_core),
		.RENB(1'b1),							.RENB(1'b1),
		.I(flash_io1_do_core),						.I(flash_io1_do_core),
		.CIN(flash_io1_di_core)						.CIN(flash_io1_di_core)
	);								);

	pc3o01 flash_csb_pad (						pc3o01 flash_csb_pad (
		.PAD(flash_csb),						.PAD(flash_csb),
		.I(flash_csb_core)						.I(flash_csb_core)
	);								);

	pc3o01 flash_clk_pad (						pc3o01 flash_clk_pad (
		.PAD(flash_clk),						.PAD(flash_clk),
		.I(flash_clk_core)						.I(flash_clk_core)
	);								);

	// ==================================================		// ==================================================
	// RESET PAD							// RESET PAD
	// Note: SCL180 has no dedicated reset pad with glitc		// Note: SCL180 has no dedicated reset pad with glitc
	// Using simple input pad - add external RC filter on		// Using simple input pad - add external RC filter on
	// Recommended: 10k pull-up + 100nF cap to ground		// Recommended: 10k pull-up + 100nF cap to ground
	// ==================================================		// ==================================================
									
	pc3d01 resetb_pad (						pc3d01 resetb_pad (
		.PAD(resetb),							.PAD(resetb),
		.CIN(resetb_core_h)						.CIN(resetb_core_h)
	);								);

	// Corner cells removed - SCL180 has no corner pad ce		// Corner cells removed - SCL180 has no corner pad ce
	// Ensure power ring connectivity through proper meta		// Ensure power ring connectivity through proper meta

	// ==================================================		// ==================================================
	// USER PROJECT I/O PADS					// USER PROJECT I/O PADS
	// ==================================================		// ==================================================

	mprj_io mprj_pads(						mprj_io mprj_pads(
		.vddio(vddio),							.vddio(vddio),
		.vssio(vssio),							.vssio(vssio),
		.vccd(vccd),							.vccd(vccd),
		.vssd(vssd),							.vssd(vssd),
		.vdda1(vdda1),							.vdda1(vdda1),
		.vdda2(vdda2),							.vdda2(vdda2),
		.vssa1(vssa1),							.vssa1(vssa1),
		.vssa2(vssa2),							.vssa2(vssa2),
		.vddio_q(vddio_q),						.vddio_q(vddio_q),
		.vssio_q(vssio_q),						.vssio_q(vssio_q),
		.analog_a(analog_a),						.analog_a(analog_a),
		.analog_b(analog_b),						.analog_b(analog_b),
		.porb_h(porb_h),						.porb_h(porb_h),
		.vccd_conb(mprj_io_one),					.vccd_conb(mprj_io_one),
		.io(mprj_io),							.io(mprj_io),
		.io_out(mprj_io_out),						.io_out(mprj_io_out),
		.oeb(mprj_io_oeb),						.oeb(mprj_io_oeb),
		.enh(mprj_io_enh),						.enh(mprj_io_enh),
		.inp_dis(mprj_io_inp_dis),					.inp_dis(mprj_io_inp_dis),
		.ib_mode_sel(mprj_io_ib_mode_sel),				.ib_mode_sel(mprj_io_ib_mode_sel),
		.vtrip_sel(mprj_io_vtrip_sel),					.vtrip_sel(mprj_io_vtrip_sel),
		.holdover(mprj_io_holdover),					.holdover(mprj_io_holdover),
		.slow_sel(mprj_io_slow_sel),					.slow_sel(mprj_io_slow_sel),
		.analog_en(mprj_io_analog_en),					.analog_en(mprj_io_analog_en),
		.analog_sel(mprj_io_analog_sel),				.analog_sel(mprj_io_analog_sel),
		.analog_pol(mprj_io_analog_pol),				.analog_pol(mprj_io_analog_pol),
		.dm(mprj_io_dm),						.dm(mprj_io_dm),
		.io_in(mprj_io_in),						.io_in(mprj_io_in),
		.analog_io(mprj_analog_io)					.analog_io(mprj_analog_io)
	);								);

endmodule							endmodule
// `default_nettype wire					// `default_nettype wire
diff -ry rtl/clock_div.v verilog/rtl/clock_div.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

/* Integer-N clock divider */					/* Integer-N clock divider */
`default_nettype wire					      |	`default_nettype none
 `include "defines.v"					      |	 
module clock_div #(						module clock_div #(
    parameter SIZE = 3		// Number of bits for the div	    parameter SIZE = 3		// Number of bits for the div
) (								) (
    in, out, N, resetb						    in, out, N, resetb
);								);
    input in;			// input clock			    input in;			// input clock
    input [SIZE-1:0] N;		// the number to be divided b	    input [SIZE-1:0] N;		// the number to be divided b
    input resetb;		// asynchronous reset (sense 	    input resetb;		// asynchronous reset (sense 
    output out;			// divided output clock		    output out;			// divided output clock
 								 
    wire out_odd;		// output of odd divider	    wire out_odd;		// output of odd divider
    wire out_even;		// output of even divider	    wire out_even;		// output of even divider
    wire not_zero;		// signal to find divide by 0	    wire not_zero;		// signal to find divide by 0
    wire enable_even;		// enable of even divider	    wire enable_even;		// enable of even divider
    wire enable_odd;		// enable of odd divider	    wire enable_odd;		// enable of odd divider

    reg [SIZE-1:0] syncN;	// N synchronized to output c	    reg [SIZE-1:0] syncN;	// N synchronized to output c
    reg [SIZE-1:0] syncNp;	// N synchronized to output c	    reg [SIZE-1:0] syncNp;	// N synchronized to output c
 								 
    assign not_zero = | syncN[SIZE-1:1];			    assign not_zero = | syncN[SIZE-1:1];
 								 
    assign out = (out_odd & syncN[0] & not_zero) | (out_even 	    assign out = (out_odd & syncN[0] & not_zero) | (out_even 
    assign enable_odd = syncN[0] & not_zero;			    assign enable_odd = syncN[0] & not_zero;
    assign enable_even = !syncN[0];				    assign enable_even = !syncN[0];

    // Divider value synchronization (double-synchronized to 	    // Divider value synchronization (double-synchronized to 
    always @(posedge out or negedge resetb) begin		    always @(posedge out or negedge resetb) begin
	if (resetb == 1'b0) begin					if (resetb == 1'b0) begin
	    syncN <= `CLK_DIV;	// Default to divide-by-2 on 		    syncN <= `CLK_DIV;	// Default to divide-by-2 on 
	    syncNp <= `CLK_DIV;	// Default to divide-by-2 on 		    syncNp <= `CLK_DIV;	// Default to divide-by-2 on 
	end else begin							end else begin
	    syncNp <= N;						    syncNp <= N;
	    syncN <= syncNp;						    syncN <= syncNp;
	end								end
    end								    end
 								 
    // Even divider						    // Even divider
    even even_0(in, out_even, syncN, resetb, not_zero, enable	    even even_0(in, out_even, syncN, resetb, not_zero, enable
    // Odd divider						    // Odd divider
    odd odd_0(in, out_odd, syncN, resetb, enable_odd);		    odd odd_0(in, out_odd, syncN, resetb, enable_odd);
 								 
endmodule // clock_div						endmodule // clock_div
 								 
/* Odd divider */						/* Odd divider */

module odd #(							module odd #(
    parameter SIZE = 3						    parameter SIZE = 3
) (								) (
    clk, out, N, resetb, enable					    clk, out, N, resetb, enable
);								);
    input clk;			// slow clock			    input clk;			// slow clock
    output out;			// fast output clock		    output out;			// fast output clock
    input [SIZE-1:0] N;		// division factor		    input [SIZE-1:0] N;		// division factor
    input resetb;		// synchronous reset		    input resetb;		// synchronous reset
    input enable;		// odd enable			    input enable;		// odd enable
 								 
    reg [SIZE-1:0] counter;	// these 2 counters are used	    reg [SIZE-1:0] counter;	// these 2 counters are used
    reg [SIZE-1:0] counter2;	// to non-overlapping signals	    reg [SIZE-1:0] counter2;	// to non-overlapping signals
    reg out_counter;		// positive edge triggered co	    reg out_counter;		// positive edge triggered co
    reg out_counter2;		// negative edge triggered co	    reg out_counter2;		// negative edge triggered co
    reg rst_pulse;		// pulse generated when vecto	    reg rst_pulse;		// pulse generated when vecto
    reg [SIZE-1:0] old_N;	// gets set to old N when N i	    reg [SIZE-1:0] old_N;	// gets set to old N when N i
    wire not_zero;		// if !not_zero, we devide by	    wire not_zero;		// if !not_zero, we devide by
 								 
    // xor to generate 50% duty, half-period waves of final o	    // xor to generate 50% duty, half-period waves of final o
    assign out = out_counter2 ^ out_counter;			    assign out = out_counter2 ^ out_counter;

    // positive edge counter/divider				    // positive edge counter/divider
    always @(posedge clk or negedge resetb) begin		    always @(posedge clk or negedge resetb) begin
	if (resetb == 1'b0) begin					if (resetb == 1'b0) begin
	    counter <= `CLK_DIV;					    counter <= `CLK_DIV;
	    out_counter <= 1;						    out_counter <= 1;
	end else if (rst_pulse) begin					end else if (rst_pulse) begin
	    counter <= N;						    counter <= N;
	    out_counter <= 1;						    out_counter <= 1;
	end else if (enable) begin					end else if (enable) begin
	    if (counter == 1) begin					    if (counter == 1) begin
		counter <= N;							counter <= N;
		out_counter <= ~out_counter;					out_counter <= ~out_counter;
	    end else begin						    end else begin
		counter <= counter - 1'b1;					counter <= counter - 1'b1;
	    end								    end
	end								end
    end								    end
 								 
    reg [SIZE-1:0] initial_begin;	// this is used to of	    reg [SIZE-1:0] initial_begin;	// this is used to of
    wire [SIZE:0] interm_3;		// from the positive 	    wire [SIZE:0] interm_3;		// from the positive 
    assign interm_3 = {1'b0, N} + 2'b11;	// guarantee 	    assign interm_3 = {1'b0, N} + 2'b11;	// guarantee 

    localparam [SIZE:0] interm_init = {1'b0,`CLK_DIV} + 2'b11	    localparam [SIZE:0] interm_init = {1'b0,`CLK_DIV} + 2'b11

    // Counter driven by negative edge of clock.		    // Counter driven by negative edge of clock.

    always @(negedge clk or negedge resetb) begin		    always @(negedge clk or negedge resetb) begin
	if (resetb == 1'b0) begin					if (resetb == 1'b0) begin
	    // reset the counter at system reset			    // reset the counter at system reset
	    counter2 <= `CLK_DIV;					    counter2 <= `CLK_DIV;
	    initial_begin <= interm_init[SIZE:1];			    initial_begin <= interm_init[SIZE:1];
	    out_counter2 <= 1;						    out_counter2 <= 1;
	end else if (rst_pulse) begin					end else if (rst_pulse) begin
	    // reset the counter at change of N.			    // reset the counter at change of N.
	    counter2 <= N;						    counter2 <= N;
	    initial_begin <= interm_3[SIZE:1];				    initial_begin <= interm_3[SIZE:1];
	    out_counter2 <= 1;						    out_counter2 <= 1;
	end else if ((initial_begin <= 1) && enable) begin		end else if ((initial_begin <= 1) && enable) begin

	    // Do normal logic after odd calibration.			    // Do normal logic after odd calibration.
	    // This is the same as the even counter.			    // This is the same as the even counter.
	    if (counter2 == 1) begin					    if (counter2 == 1) begin
		counter2 <= N;							counter2 <= N;
		out_counter2 <= ~out_counter2;					out_counter2 <= ~out_counter2;
	    end else begin						    end else begin
		counter2 <= counter2 - 1'b1;					counter2 <= counter2 - 1'b1;
	    end								    end
	end else if (enable) begin					end else if (enable) begin
	    initial_begin <= initial_begin - 1'b1;			    initial_begin <= initial_begin - 1'b1;
	end								end
    end								    end
 								 
    //								    //
    // reset pulse generator:					    // reset pulse generator:
    //               __    __    __    __    _			    //               __    __    __    __    _
    // clk:       __/  \__/  \__/  \__/  \__/			    // clk:       __/  \__/  \__/  \__/  \__/
    //            _ __________________________			    //            _ __________________________
    // N:         _X__________________________			    // N:         _X__________________________
    //               _____					    //               _____
    // rst_pulse: __/     \___________________			    // rst_pulse: __/     \___________________
    //								    //
    // This block generates an internal reset for the odd div	    // This block generates an internal reset for the odd div
    // form of a single pulse signal when the odd divider is 	    // form of a single pulse signal when the odd divider is 

    always @(posedge clk or negedge resetb) begin		    always @(posedge clk or negedge resetb) begin
	if (resetb == 1'b0) begin					if (resetb == 1'b0) begin
	    rst_pulse <= 0;						    rst_pulse <= 0;
	end else if (enable) begin					end else if (enable) begin
	    if (N != old_N) begin					    if (N != old_N) begin
		// pulse when reset changes					// pulse when reset changes
		rst_pulse <= 1;							rst_pulse <= 1;
	    end else begin						    end else begin
		rst_pulse <= 0;							rst_pulse <= 0;
	    end								    end
	end								end
    end								    end
 								 
    always @(posedge clk) begin					    always @(posedge clk) begin
	// always save the old N value to guarante reset from		// always save the old N value to guarante reset from
	// an even-to-odd transition.					// an even-to-odd transition.
	old_N <= N;							old_N <= N;
    end								    end	
 								 
endmodule // odd						endmodule // odd

/* Even divider */						/* Even divider */

module even #(							module even #(
    parameter SIZE = 3						    parameter SIZE = 3
) (								) (
    clk, out, N, resetb, not_zero, enable			    clk, out, N, resetb, not_zero, enable
);								);
    input clk;		// fast input clock			    input clk;		// fast input clock
    output out;		// slower divided clock			    output out;		// slower divided clock
    input [SIZE-1:0] N;	// divide by factor 'N'			    input [SIZE-1:0] N;	// divide by factor 'N'
    input resetb;	// asynchronous reset			    input resetb;	// asynchronous reset
    input not_zero;	// if !not_zero divide by 1		    input not_zero;	// if !not_zero divide by 1
    input enable;	// enable the even divider		    input enable;	// enable the even divider
 								 
    reg [SIZE-1:0] counter;					    reg [SIZE-1:0] counter;
    reg out_counter;						    reg out_counter;
    wire [SIZE-1:0] div_2;					    wire [SIZE-1:0] div_2;
 								 
    // if N=0 just output the clock, otherwise, divide it.	    // if N=0 just output the clock, otherwise, divide it.
    assign out = (clk & !not_zero) | (out_counter & not_zero)	    assign out = (clk & !not_zero) | (out_counter & not_zero)
    assign div_2 = {1'b0, N[SIZE-1:1]};				    assign div_2 = {1'b0, N[SIZE-1:1]};
 								 
    // simple flip-flop even divider				    // simple flip-flop even divider
    always @(posedge clk or negedge resetb) begin		    always @(posedge clk or negedge resetb) begin
	if (resetb == 1'b0) begin					if (resetb == 1'b0) begin
	    counter <= 1;						    counter <= 1;
	    out_counter <= 1;						    out_counter <= 1;

	end else if (enable) begin					end else if (enable) begin
	    // only use switching power if enabled			    // only use switching power if enabled
	    if (counter == 1) begin					    if (counter == 1) begin
		// divide after counter has reached bottom			// divide after counter has reached bottom
		// of interval 'N' which will be value '1'			// of interval 'N' which will be value '1'
		counter <= div_2;						counter <= div_2;
		out_counter <= ~out_counter;					out_counter <= ~out_counter;
	    end else begin						    end else begin
		// decrement the counter and wait				// decrement the counter and wait
		counter <= counter-1;	// to start next tran			counter <= counter-1;	// to start next tran
	    end								    end
	end								end
    end								    end
 								 
endmodule //even						endmodule //even
`default_nettype wire						`default_nettype wire
diff -ry rtl/constant_block.v verilog/rtl/constant_block.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
/* 								/* 
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 * A simple module that generates buffered high and low outpu	 * A simple module that generates buffered high and low outpu
 * in the 1.8V domain.						 * in the 1.8V domain.
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 */								 */

module constant_block (						module constant_block (
    `ifdef USE_POWER_PINS					    `ifdef USE_POWER_PINS
         inout vccd,						         inout vccd,
         inout vssd,						         inout vssd,
    `endif							    `endif

    output	 one,						    output	 one,
    output	 zero						    output	 zero
);								);

    wire	one_unbuf;					    wire	one_unbuf;
    wire	zero_unbuf;					    wire	zero_unbuf;

    dummy_scl180_conb_1 const_source (			      |	    sky130_fd_sc_hd__conb_1 const_source (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
`endif								`endif
            .HI(one_unbuf),					            .HI(one_unbuf),
            .LO(zero_unbuf)					            .LO(zero_unbuf)
    );								    );

    /* Buffer the constant outputs (could be synthesized) */	    /* Buffer the constant outputs (could be synthesized) */
    /* NOTE:  Constant cell HI, LO outputs are connected to p	    /* NOTE:  Constant cell HI, LO outputs are connected to p
    /* rails through an approximately 120 ohm resistor, which	    /* rails through an approximately 120 ohm resistor, which
    /* enough to drive inputs in the I/O cells while ensuring	    /* enough to drive inputs in the I/O cells while ensuring
    /* requirements, without buffering.				    /* requirements, without buffering.			

    buffda const_one_buf (				      |	    sky130_fd_sc_hd__buf_16 const_one_buf (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
`endif								`endif
            .I(one_unbuf),				      |	            .A(one_unbuf),
            .Z(one)					      |	            .X(one)
    );								    );

    buffda const_zero_buf (				      |	    sky130_fd_sc_hd__buf_16 const_zero_buf (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
`endif								`endif
            .I(zero_unbuf),				      |	            .A(zero_unbuf),
            .Z(zero)					      |	            .X(zero)
    );								    );

endmodule							endmodule
`default_nettype wire						`default_nettype wire
diff -ry rtl/copyright_block_a.v verilog/rtl/copyright_block_a.v
module copyright_block_a ();					module copyright_block_a ();
endmodule							endmodule
diff -ry rtl/copyright_block.v verilog/rtl/copyright_block.v
module copyright_block ();					module copyright_block ();
endmodule							endmodule
diff -ry rtl/debug_regs.v verilog/rtl/debug_regs.v
`default_nettype wire					      <
// module that has registers used for debug			// module that has registers used for debug
module debug_regs (    						module debug_regs (    
    input wb_clk_i,						    input wb_clk_i,
    input wb_rst_i,						    input wb_rst_i,
    input wbs_stb_i,						    input wbs_stb_i,
    input wbs_cyc_i,						    input wbs_cyc_i,
    input wbs_we_i,						    input wbs_we_i,
    input [3:0] wbs_sel_i,					    input [3:0] wbs_sel_i,
    input [31:0] wbs_dat_i,					    input [31:0] wbs_dat_i,
    input [31:0] wbs_adr_i,					    input [31:0] wbs_adr_i,
    output reg wbs_ack_o,					    output reg wbs_ack_o,
    output reg [31:0] wbs_dat_o);				    output reg [31:0] wbs_dat_o);

    reg [31:0] debug_reg_1;					    reg [31:0] debug_reg_1;
    reg [31:0] debug_reg_2;					    reg [31:0] debug_reg_2;

    // write							    // write
    always @(posedge wb_clk_i or posedge wb_rst_i) begin	    always @(posedge wb_clk_i or posedge wb_rst_i) begin
        if (wb_rst_i) begin					        if (wb_rst_i) begin
            debug_reg_1 <=0;					            debug_reg_1 <=0;
            debug_reg_2 <=0;					            debug_reg_2 <=0;
            wbs_dat_o   <=0;					            wbs_dat_o   <=0;
            wbs_ack_o   <=0;					            wbs_ack_o   <=0;
        end else if (wbs_cyc_i && wbs_stb_i && wbs_we_i && !w	        end else if (wbs_cyc_i && wbs_stb_i && wbs_we_i && !w
            // write to reg1					            // write to reg1
            debug_reg_1[7:0]    <= ((wbs_adr_i[3:0]==4'h8) &&	            debug_reg_1[7:0]    <= ((wbs_adr_i[3:0]==4'h8) &&
            debug_reg_1[15:8]   <= ((wbs_adr_i[3:0]==4'h8) &&	            debug_reg_1[15:8]   <= ((wbs_adr_i[3:0]==4'h8) &&
            debug_reg_1[23:16]  <= ((wbs_adr_i[3:0]==4'h8) &&	            debug_reg_1[23:16]  <= ((wbs_adr_i[3:0]==4'h8) &&
            debug_reg_1[31:24]  <= ((wbs_adr_i[3:0]==4'h8) &&	            debug_reg_1[31:24]  <= ((wbs_adr_i[3:0]==4'h8) &&
            // write to reg2					            // write to reg2
            debug_reg_2[7:0]    <= ((wbs_adr_i[3:0]==4'hC) &&	            debug_reg_2[7:0]    <= ((wbs_adr_i[3:0]==4'hC) &&
            debug_reg_2[15:8]   <= ((wbs_adr_i[3:0]==4'hC) &&	            debug_reg_2[15:8]   <= ((wbs_adr_i[3:0]==4'hC) &&
            debug_reg_2[23:16]  <= ((wbs_adr_i[3:0]==4'hC) &&	            debug_reg_2[23:16]  <= ((wbs_adr_i[3:0]==4'hC) &&
            debug_reg_2[31:24]  <= ((wbs_adr_i[3:0]==4'hC) &&	            debug_reg_2[31:24]  <= ((wbs_adr_i[3:0]==4'hC) &&
            wbs_ack_o <= 1;					            wbs_ack_o <= 1;
        end else if (wbs_cyc_i && wbs_stb_i && !wbs_we_i && !	        end else if (wbs_cyc_i && wbs_stb_i && !wbs_we_i && !
            wbs_dat_o <= ((wbs_adr_i[3:0]==4'hC)) ? debug_reg	            wbs_dat_o <= ((wbs_adr_i[3:0]==4'hC)) ? debug_reg
            wbs_ack_o <= 1;					            wbs_ack_o <= 1;
        end else begin 						        end else begin 
            wbs_ack_o <= 0;					            wbs_ack_o <= 0;
            wbs_dat_o <= 0;					            wbs_dat_o <= 0;
        end							        end
    end								    end
endmodule							endmodule
`default_nettype wire					      /	`default_nettype wire
diff -ry rtl/defines.v verilog/rtl/defines.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

							      >	`default_nettype none

//`ifndef __GLOBAL_DEFINE_H				      |	`ifndef __GLOBAL_DEFINE_H
// Global parameters						// Global parameters
//`define __GLOBAL_DEFINE_H				      |	`define __GLOBAL_DEFINE_H

`define MPRJ_IO_PADS_1 19	/* number of user GPIO pads o	`define MPRJ_IO_PADS_1 19	/* number of user GPIO pads o
`define MPRJ_IO_PADS_2 19	/* number of user GPIO pads o	`define MPRJ_IO_PADS_2 19	/* number of user GPIO pads o
`define MPRJ_IO_PADS (`MPRJ_IO_PADS_1 + `MPRJ_IO_PADS_2)	`define MPRJ_IO_PADS (`MPRJ_IO_PADS_1 + `MPRJ_IO_PADS_2)

`define MPRJ_PWR_PADS_1 2	/* vdda1, vccd1 enable/disabl	`define MPRJ_PWR_PADS_1 2	/* vdda1, vccd1 enable/disabl
`define MPRJ_PWR_PADS_2 2	/* vdda2, vccd2 enable/disabl	`define MPRJ_PWR_PADS_2 2	/* vdda2, vccd2 enable/disabl
`define MPRJ_PWR_PADS (`MPRJ_PWR_PADS_1 + `MPRJ_PWR_PADS_2)	`define MPRJ_PWR_PADS (`MPRJ_PWR_PADS_1 + `MPRJ_PWR_PADS_2)

// Analog pads are only used by the "caravan" module and asso	// Analog pads are only used by the "caravan" module and asso
// modules such as user_analog_project_wrapper and chip_io_al	// modules such as user_analog_project_wrapper and chip_io_al

`define ANALOG_PADS_1 5						`define ANALOG_PADS_1 5
`define ANALOG_PADS_2 6						`define ANALOG_PADS_2 6

`define ANALOG_PADS (`ANALOG_PADS_1 + `ANALOG_PADS_2)		`define ANALOG_PADS (`ANALOG_PADS_1 + `ANALOG_PADS_2)

// Adding GPIO Pads for Caravel				      |	// Number of GPIO pads defined in the caravel openframe layou
`define OPENFRAME_IO_PADS 44					`define OPENFRAME_IO_PADS 44
							      >
// Size of soc_mem_synth					// Size of soc_mem_synth

// Type and size of soc_mem					// Type and size of soc_mem
// `define USE_OPENRAM						// `define USE_OPENRAM
`define USE_CUSTOM_DFFRAM					`define USE_CUSTOM_DFFRAM
// don't change the following without double checking addr wi	// don't change the following without double checking addr wi
`define MEM_WORDS 256						`define MEM_WORDS 256

// Number of columns in the custom memory; takes one of three	// Number of columns in the custom memory; takes one of three
// 1 column : 1 KB, 2 column: 2 KB, 4 column: 4KB		// 1 column : 1 KB, 2 column: 2 KB, 4 column: 4KB
`define DFFRAM_WSIZE 4						`define DFFRAM_WSIZE 4
`define DFFRAM_USE_LATCH 0					`define DFFRAM_USE_LATCH 0

// not really parameterized but just to easily keep track of 	// not really parameterized but just to easily keep track of 
// of ram_block across different modules			// of ram_block across different modules
`define RAM_BLOCKS 2					      |	`define RAM_BLOCKS 1

// Clock divisor default value					// Clock divisor default value
`define CLK_DIV 3'b010						`define CLK_DIV 3'b010

// GPIO control default mode and enable for most I/Os		// GPIO control default mode and enable for most I/Os
// Most I/Os set to be user bidirectional pins on power-up.   |	// Most I/Os set to be user input pins on startup.
							      >	// NOTE:  To be modified, with GPIOs 5 to 35 being set from a
							      >	// programmable block.
`define MGMT_INIT 1'b0						`define MGMT_INIT 1'b0
`define OENB_INIT 1'b0						`define OENB_INIT 1'b0
`define DM_INIT 3'b110					      |	`define DM_INIT 3'b001
							      <
							      <
`define LA_SIZE 'd128					      <
`define USER_SPACE_ADDR 32'h30000000 			      <
`define USER_SPACE_SIZE 'hFFFFC // sum with USER_SPACE_ADDR i <
`define IO_CTRL_BITS 'd13 // size of gpio_control_reg	      <
`define POWER_DOMAINS 'd3 // size of gpio_control_reg	      <

//`endif // __GLOBAL_DEFINE_H				      |	`endif // __GLOBAL_DEFINE_H
diff -ry rtl/digital_pll_controller.v verilog/rtl/digital_pll_controller.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
// (True) digital PLL						// (True) digital PLL
//								//
// Output goes to a trimmable ring oscillator (see documentat	// Output goes to a trimmable ring oscillator (see documentat
// Ring oscillator should be trimmable to above and below max	// Ring oscillator should be trimmable to above and below max
// ranges of the input.						// ranges of the input.
//								//
// Input "osc" comes from a fixed clock source (e.g., crystal	// Input "osc" comes from a fixed clock source (e.g., crystal
// output).							// output).
//								//
// Input "div" is the target number of clock cycles per oscil	// Input "div" is the target number of clock cycles per oscil
// e.g., if div == 8 then this is an 8X PLL.			// e.g., if div == 8 then this is an 8X PLL.
//								//
// Clock "clock" is the PLL output being trimmed.		// Clock "clock" is the PLL output being trimmed.
// (NOTE:  To be done:  Pass-through enable)			// (NOTE:  To be done:  Pass-through enable)
//								//
// Algorithm:							// Algorithm:
//								//
// 1) Trim is done by thermometer code.  Reset to the highest	// 1) Trim is done by thermometer code.  Reset to the highest
//    in case the fastest rate clock is too fast for the logi	//    in case the fastest rate clock is too fast for the logi
//								//
// 2) Count the number of contiguous 1s and 0s in "osc"		// 2) Count the number of contiguous 1s and 0s in "osc"
//    periods of the master clock.  If the count maxes out, i	//    periods of the master clock.  If the count maxes out, i
//    not roll over.						//    not roll over.
//								//
// 3) Add the two counts together.				// 3) Add the two counts together.
//								//
// 4) If the sum is less than div, then the clock is too slow	// 4) If the sum is less than div, then the clock is too slow
//    decrease the trim code.  If the sum is greater than div	//    decrease the trim code.  If the sum is greater than div
//    clock is too fast, so increase the trim code.  If the s	//    clock is too fast, so increase the trim code.  If the s
//    is equal to div, the the trim code does not change.	//    is equal to div, the the trim code does not change.
//								//

module digital_pll_controller(reset, clock, osc, div, trim);	module digital_pll_controller(reset, clock, osc, div, trim);
    input reset;						    input reset;
    input clock;						    input clock;
    input osc;							    input osc;
    input [4:0] div;						    input [4:0] div;
    output [25:0] trim;		// Use ring_osc2x13, with 26 	    output [25:0] trim;		// Use ring_osc2x13, with 26 

    wire [25:0] trim;						    wire [25:0] trim;
    reg [2:0] oscbuf;						    reg [2:0] oscbuf;
    reg [2:0] prep;						    reg [2:0] prep;

    reg [4:0] count0;						    reg [4:0] count0;
    reg [4:0] count1;						    reg [4:0] count1;
    reg [6:0] tval;	// Includes 2 bits fractional		    reg [6:0] tval;	// Includes 2 bits fractional
    wire [4:0] tint;	// Integer part of the above		    wire [4:0] tint;	// Integer part of the above

    wire [5:0] sum;						    wire [5:0] sum;

    assign sum = count0 + count1;				    assign sum = count0 + count1;
 								 
    // Integer to thermometer code (maybe there's an algorith	    // Integer to thermometer code (maybe there's an algorith
    assign tint = tval[6:2];					    assign tint = tval[6:2];
                                     // |<--second-->|<-- fir	                                     // |<--second-->|<-- fir
    assign trim = (tint == 5'd0)  ? 26'b0000000000000_0000000	    assign trim = (tint == 5'd0)  ? 26'b0000000000000_0000000
          (tint == 5'd1)  ? 26'b0000000000000_0000000000001 :	          (tint == 5'd1)  ? 26'b0000000000000_0000000000001 :
          (tint == 5'd2)  ? 26'b0000000000000_0000001000001 :	          (tint == 5'd2)  ? 26'b0000000000000_0000001000001 :
          (tint == 5'd3)  ? 26'b0000000000000_0010001000001 :	          (tint == 5'd3)  ? 26'b0000000000000_0010001000001 :
          (tint == 5'd4)  ? 26'b0000000000000_0010001001001 :	          (tint == 5'd4)  ? 26'b0000000000000_0010001001001 :
          (tint == 5'd5)  ? 26'b0000000000000_0010101001001 :	          (tint == 5'd5)  ? 26'b0000000000000_0010101001001 :
          (tint == 5'd6)  ? 26'b0000000000000_1010101001001 :	          (tint == 5'd6)  ? 26'b0000000000000_1010101001001 :
          (tint == 5'd7)  ? 26'b0000000000000_1010101101001 :	          (tint == 5'd7)  ? 26'b0000000000000_1010101101001 :
          (tint == 5'd8)  ? 26'b0000000000000_1010101101101 :	          (tint == 5'd8)  ? 26'b0000000000000_1010101101101 :
          (tint == 5'd9)  ? 26'b0000000000000_1011101101101 :	          (tint == 5'd9)  ? 26'b0000000000000_1011101101101 :
          (tint == 5'd10) ? 26'b0000000000000_1011101111101 :	          (tint == 5'd10) ? 26'b0000000000000_1011101111101 :
          (tint == 5'd11) ? 26'b0000000000000_1111101111101 :	          (tint == 5'd11) ? 26'b0000000000000_1111101111101 :
          (tint == 5'd12) ? 26'b0000000000000_1111101111111 :	          (tint == 5'd12) ? 26'b0000000000000_1111101111111 :
          (tint == 5'd13) ? 26'b0000000000000_1111111111111 :	          (tint == 5'd13) ? 26'b0000000000000_1111111111111 :
          (tint == 5'd14) ? 26'b0000000000001_1111111111111 :	          (tint == 5'd14) ? 26'b0000000000001_1111111111111 :
          (tint == 5'd15) ? 26'b0000001000001_1111111111111 :	          (tint == 5'd15) ? 26'b0000001000001_1111111111111 :
          (tint == 5'd16) ? 26'b0010001000001_1111111111111 :	          (tint == 5'd16) ? 26'b0010001000001_1111111111111 :
          (tint == 5'd17) ? 26'b0010001001001_1111111111111 :	          (tint == 5'd17) ? 26'b0010001001001_1111111111111 :
          (tint == 5'd18) ? 26'b0010101001001_1111111111111 :	          (tint == 5'd18) ? 26'b0010101001001_1111111111111 :
          (tint == 5'd19) ? 26'b1010101001001_1111111111111 :	          (tint == 5'd19) ? 26'b1010101001001_1111111111111 :
          (tint == 5'd20) ? 26'b1010101101001_1111111111111 :	          (tint == 5'd20) ? 26'b1010101101001_1111111111111 :
          (tint == 5'd21) ? 26'b1010101101101_1111111111111 :	          (tint == 5'd21) ? 26'b1010101101101_1111111111111 :
          (tint == 5'd22) ? 26'b1011101101101_1111111111111 :	          (tint == 5'd22) ? 26'b1011101101101_1111111111111 :
          (tint == 5'd23) ? 26'b1011101111101_1111111111111 :	          (tint == 5'd23) ? 26'b1011101111101_1111111111111 :
          (tint == 5'd24) ? 26'b1111101111101_1111111111111 :	          (tint == 5'd24) ? 26'b1111101111101_1111111111111 :
          (tint == 5'd25) ? 26'b1111101111111_1111111111111 :	          (tint == 5'd25) ? 26'b1111101111111_1111111111111 :
                    26'b1111111111111_1111111111111;		                    26'b1111111111111_1111111111111;
   								   
    always @(posedge clock or posedge reset) begin		    always @(posedge clock or posedge reset) begin
    if (reset == 1'b1) begin					    if (reset == 1'b1) begin
        tval <= 7'd0;	// Note:  trim[0] must be zero for st	        tval <= 7'd0;	// Note:  trim[0] must be zero for st
        oscbuf <= 3'd0;						        oscbuf <= 3'd0;
        prep <= 3'd0;						        prep <= 3'd0;
        count0 <= 5'd0;						        count0 <= 5'd0;
        count1 <= 5'd0;						        count1 <= 5'd0;

    end else begin						    end else begin
        oscbuf <= {oscbuf[1:0], osc};				        oscbuf <= {oscbuf[1:0], osc};

        if (oscbuf[2] != oscbuf[1]) begin			        if (oscbuf[2] != oscbuf[1]) begin
        count1 <= count0;					        count1 <= count0;
        count0 <= 5'b00001;					        count0 <= 5'b00001;
        prep <= {prep[1:0], 1'b1};				        prep <= {prep[1:0], 1'b1};

        if (prep == 3'b111) begin				        if (prep == 3'b111) begin
            if (sum > div) begin				            if (sum > div) begin
		if (tval < 127) begin						if (tval < 127) begin
            	    tval <= tval + 1;				            	    tval <= tval + 1;
		end								end
            end else if (sum < div) begin			            end else if (sum < div) begin
		if (tval > 0) begin						if (tval > 0) begin
            	    tval <= tval - 1;				            	    tval <= tval - 1;
		end								end
            end							            end
        end							        end
        end else begin						        end else begin
        if (count0 != 5'b11111) begin				        if (count0 != 5'b11111) begin
                count0 <= count0 + 1;				                count0 <= count0 + 1;
        end							        end
        end							        end
    end								    end
    end								    end

endmodule	// digital_pll_controller			endmodule	// digital_pll_controller
`default_nettype wire						`default_nettype wire
diff -ry rtl/digital_pll.v verilog/rtl/digital_pll.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype none						`default_nettype none
// Digital PLL (ring oscillator + controller)			// Digital PLL (ring oscillator + controller)
// Technically this is a frequency locked loop, not a phase l	// Technically this is a frequency locked loop, not a phase l

`ifndef SIM							`ifndef SIM
`include "digital_pll_controller.v"				`include "digital_pll_controller.v"
`include "ring_osc2x13.v"					`include "ring_osc2x13.v"
`endif								`endif

module digital_pll(						module digital_pll(
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
    VPWR,							    VPWR,
    VGND,							    VGND,
`endif */						      |	`endif
    resetb, enable, osc, clockp, div, dco, ext_trim);		    resetb, enable, osc, clockp, div, dco, ext_trim);

/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
    input VPWR;							    input VPWR;
    input VGND;							    input VGND;
`endif */						      |	`endif

    input	 resetb;	// Sense negative reset		    input	 resetb;	// Sense negative reset
    input	 enable;	// Enable PLL			    input	 enable;	// Enable PLL
    input	 osc;		// Input oscillator to match	    input	 osc;		// Input oscillator to match
    input [4:0]	 div;		// PLL feedback division rati	    input [4:0]	 div;		// PLL feedback division rati
    input 	 dco;		// Run in DCO mode		    input 	 dco;		// Run in DCO mode
    input [25:0] ext_trim;	// External trim for DCO mode	    input [25:0] ext_trim;	// External trim for DCO mode

    output [1:0] clockp;	// Two 90 degree clock phases	    output [1:0] clockp;	// Two 90 degree clock phases

    wire [1:0]   clockp_buffer_in;	// Input wires to clo	    wire [1:0]   clockp_buffer_in;	// Input wires to clo
    wire [25:0]  itrim;		// Internally generated trim 	    wire [25:0]  itrim;		// Internally generated trim 
    wire [25:0]  otrim;		// Trim bits applied to the r	    wire [25:0]  otrim;		// Trim bits applied to the r
    wire	 creset;	// Controller reset		    wire	 creset;	// Controller reset
    wire	 ireset;	// Internal reset (external r	    wire	 ireset;	// Internal reset (external r

    assign ireset = ~resetb | ~enable;				    assign ireset = ~resetb | ~enable;

    // In DCO mode: Hold controller in reset and apply extern	    // In DCO mode: Hold controller in reset and apply extern

    assign itrim = (dco == 1'b0) ? otrim : ext_trim;		    assign itrim = (dco == 1'b0) ? otrim : ext_trim;
    assign creset = (dco == 1'b0) ? ireset : 1'b1;		    assign creset = (dco == 1'b0) ? ireset : 1'b1;

    (* keep *)							    (* keep *)
    ring_osc2x13 ringosc (					    ring_osc2x13 ringosc (
        .reset(ireset),						        .reset(ireset),
        .trim(itrim),						        .trim(itrim),
        .clockp(clockp_buffer_in)				        .clockp(clockp_buffer_in)
    );								    );

    digital_pll_controller pll_control (			    digital_pll_controller pll_control (
        .reset(creset),						        .reset(creset),
        .clock(clockp_buffer_in[0]),				        .clock(clockp_buffer_in[0]),
        .osc(osc),						        .osc(osc),
        .div(div),						        .div(div),
        .trim(otrim)						        .trim(otrim)
    );								    );

    (* keep *)							    (* keep *)
    bufbdf clockp_buffer_0 (				      |	    sky130_fd_sc_hd__clkbuf_16 clockp_buffer_0 (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
        .VPWR(VPWR),						        .VPWR(VPWR),
        .VGND(VGND),						        .VGND(VGND),
        .VPB(VPWR),						        .VPB(VPWR),
        .VNB(VGND),						        .VNB(VGND),
`endif								`endif
        .I(clockp_buffer_in[0]),			      |	        .A(clockp_buffer_in[0]),
        .Z(clockp[0])					      |	        .X(clockp[0])
    );								    );

    (* keep *)							    (* keep *)
    bufbdf clockp_buffer_1 (				      |	    sky130_fd_sc_hd__clkbuf_16 clockp_buffer_1 (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
        .VPWR(VPWR),						        .VPWR(VPWR),
        .VGND(VGND),						        .VGND(VGND),
        .VPB(VPWR),						        .VPB(VPWR),
        .VNB(VGND),						        .VNB(VGND),
`endif								`endif
        .I(clockp_buffer_in[1]),			      |	        .A(clockp_buffer_in[1]),
        .Z(clockp[1])					      |	        .X(clockp[1])
    );								    );

endmodule							endmodule
`default_nettype wire						`default_nettype wire
Only in verilog/rtl: dummy_por.v
Only in rtl: dummy_schmittbuf.v
Only in rtl: dummy_scl180_conb_1.v
diff -ry rtl/empty_macro.v verilog/rtl/empty_macro.v
module empty_macro ();						module empty_macro ();
endmodule							endmodule
Only in rtl: files_list_with_gate_level.txt
diff -ry rtl/gpio_control_block.v verilog/rtl/gpio_control_block.v
`include "scl180_macro_sparecell.v"			      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      <
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
/* 								/* 
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 * See gpio_control_block for description.  This module is li	 * See gpio_control_block for description.  This module is li
 * gpio_contro_block except that it has an additional two man	 * gpio_contro_block except that it has an additional two man
 * Soc-facing pins, which are the out_enb line and the output	 * Soc-facing pins, which are the out_enb line and the output
 * If the chip is configured for output with the oeb control	 * If the chip is configured for output with the oeb control
 * register = 1, then the oeb line is controlled by the addit	 * register = 1, then the oeb line is controlled by the addit
 * signal from the management SoC.  If the oeb control regist	 * signal from the management SoC.  If the oeb control regist
 * then the output is disabled completely.  The "io" line is 	 * then the output is disabled completely.  The "io" line is 
 * only in this module.						 * only in this module.
 *								 *
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 */								 */

/*								/*
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 *								 *
 * This module instantiates a shift register chain that passe	 * This module instantiates a shift register chain that passe
 * each gpio cell.  These are connected end-to-end around the	 * each gpio cell.  These are connected end-to-end around the
 * periphery.  The purpose is to avoid a massive number of co	 * periphery.  The purpose is to avoid a massive number of co
 * wires between the digital core and I/O, passing through th	 * wires between the digital core and I/O, passing through th
 *								 *
 * See mprj_ctrl.v for the module that registers the data for	 * See mprj_ctrl.v for the module that registers the data for
 * I/O and drives the input to the shift register.		 * I/O and drives the input to the shift register.
 *								 *
 * Modified 7/24/2022 by Tim Edwards				 * Modified 7/24/2022 by Tim Edwards
 * Replaced the data delay with a negative edge-triggered flo	 * Replaced the data delay with a negative edge-triggered flo
 * so that the serial data bit out from the module only chang	 * so that the serial data bit out from the module only chang
 * the clock half cycle.  This avoids the need to fine-tune t	 * the clock half cycle.  This avoids the need to fine-tune t
 * skew between GPIO blocks.					 * skew between GPIO blocks.
 *								 *
 * Modified 10/05/2022 by Tim Edwards				 * Modified 10/05/2022 by Tim Edwards
 *								 *
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 */								 */

module gpio_control_block #(					module gpio_control_block #(
    parameter PAD_CTRL_BITS = 13				    parameter PAD_CTRL_BITS = 13
) (								) (
    `ifdef USE_POWER_PINS					    `ifdef USE_POWER_PINS
         inout vccd,						         inout vccd,
         inout vssd,						         inout vssd,
         inout vccd1,						         inout vccd1,
         inout vssd1,						         inout vssd1,
    `endif							    `endif

    // Power-on defaults					    // Power-on defaults
    input [PAD_CTRL_BITS-1:0] gpio_defaults,			    input [PAD_CTRL_BITS-1:0] gpio_defaults,

    // Management Soc-facing signals				    // Management Soc-facing signals
    input  	 resetn,		// Global reset, loca	    input  	 resetn,		// Global reset, loca
    output       resetn_out,					    output       resetn_out,
    input  	 serial_clock,		// Global clock, loca	    input  	 serial_clock,		// Global clock, loca
    output  	 serial_clock_out,				    output  	 serial_clock_out,
    input	 serial_load,		// Register load stro	    input	 serial_load,		// Register load stro
    output	 serial_load_out,				    output	 serial_load_out,

    output       mgmt_gpio_in,		// Management from pa	    output       mgmt_gpio_in,		// Management from pa
    input        mgmt_gpio_out,		// Management to pad 	    input        mgmt_gpio_out,		// Management to pad 
    input        mgmt_gpio_oeb,		// Management to pad 	    input        mgmt_gpio_oeb,		// Management to pad 

    // Serial data chain for pad configuration			    // Serial data chain for pad configuration
    input  	 serial_data_in,				    input  	 serial_data_in,
    output reg   serial_data_out,				    output reg   serial_data_out,

    // User-facing signals					    // User-facing signals
    input        user_gpio_out,		// User space to pad	    input        user_gpio_out,		// User space to pad
    input        user_gpio_oeb,		// Output enable (use	    input        user_gpio_oeb,		// Output enable (use
    output	 user_gpio_in,		// Pad to user space	    output	 user_gpio_in,		// Pad to user space

    // Pad-facing signals (Pad GPIOv2)				    // Pad-facing signals (Pad GPIOv2)
    output	 pad_gpio_holdover,				    output	 pad_gpio_holdover,
    output	 pad_gpio_slow_sel,				    output	 pad_gpio_slow_sel,
    output	 pad_gpio_vtrip_sel,				    output	 pad_gpio_vtrip_sel,
    output       pad_gpio_inenb,				    output       pad_gpio_inenb,
    output       pad_gpio_ib_mode_sel,				    output       pad_gpio_ib_mode_sel,
    output	 pad_gpio_ana_en,				    output	 pad_gpio_ana_en,
    output	 pad_gpio_ana_sel,				    output	 pad_gpio_ana_sel,
    output	 pad_gpio_ana_pol,				    output	 pad_gpio_ana_pol,
    output [2:0] pad_gpio_dm,					    output [2:0] pad_gpio_dm,
    output       pad_gpio_outenb,				    output       pad_gpio_outenb,
    output	 pad_gpio_out,					    output	 pad_gpio_out,
    input	 pad_gpio_in,					    input	 pad_gpio_in,

    // to provide a way to automatically disable/enable outpu	    // to provide a way to automatically disable/enable outpu
    // from the outside with needing a conb cell		    // from the outside with needing a conb cell
    output	 one,						    output	 one,
    output	 zero						    output	 zero
);								);

    /* Parameters defining the bit offset of each function in	    /* Parameters defining the bit offset of each function in
    localparam MGMT_EN = 0;					    localparam MGMT_EN = 0;
    localparam OEB = 1;						    localparam OEB = 1;
    localparam HLDH = 2;					    localparam HLDH = 2;
    localparam INP_DIS = 3;					    localparam INP_DIS = 3;
    localparam MOD_SEL = 4;					    localparam MOD_SEL = 4;
    localparam AN_EN = 5;					    localparam AN_EN = 5;
    localparam AN_SEL = 6;					    localparam AN_SEL = 6;
    localparam AN_POL = 7;					    localparam AN_POL = 7;
    localparam SLOW = 8;					    localparam SLOW = 8;
    localparam TRIP = 9;					    localparam TRIP = 9;
    localparam DM = 10;						    localparam DM = 10;

    /* Internally registered signals */				    /* Internally registered signals */
    reg	 	mgmt_ena;		// Enable management 	    reg	 	mgmt_ena;		// Enable management 
    reg	 	gpio_holdover;					    reg	 	gpio_holdover;
    reg	 	gpio_slow_sel;					    reg	 	gpio_slow_sel;
    reg	  	gpio_vtrip_sel;					    reg	  	gpio_vtrip_sel;
    reg  	gpio_inenb;					    reg  	gpio_inenb;
    reg	 	gpio_ib_mode_sel;				    reg	 	gpio_ib_mode_sel;
    reg  	gpio_outenb;					    reg  	gpio_outenb;
    reg [2:0] 	gpio_dm;					    reg [2:0] 	gpio_dm;
    reg	 	gpio_ana_en;					    reg	 	gpio_ana_en;
    reg	 	gpio_ana_sel;					    reg	 	gpio_ana_sel;
    reg	 	gpio_ana_pol;					    reg	 	gpio_ana_pol;

    wire	one_unbuf;					    wire	one_unbuf;
    wire	zero_unbuf;					    wire	zero_unbuf;

    wire gpio_logic1;						    wire gpio_logic1;

    /* Serial shift for the above (latched) values */		    /* Serial shift for the above (latched) values */
    reg [PAD_CTRL_BITS-1:0] shift_register;			    reg [PAD_CTRL_BITS-1:0] shift_register;

    /* Latch the output on the clock negative edge */		    /* Latch the output on the clock negative edge */
    always @(negedge serial_clock or negedge resetn) begin	    always @(negedge serial_clock or negedge resetn) begin
	if (resetn == 1'b0) begin					if (resetn == 1'b0) begin
	    /* Clear the shift register output */			    /* Clear the shift register output */
	    serial_data_out <= 1'b0;					    serial_data_out <= 1'b0;
        end else begin						        end else begin
	    serial_data_out <= shift_register[PAD_CTRL_BITS-1		    serial_data_out <= shift_register[PAD_CTRL_BITS-1
	end								end
    end								    end

    /* Propagate the clock and reset signals so that they are	    /* Propagate the clock and reset signals so that they are
    /* all over the chip, but are just wired between the bloc	    /* all over the chip, but are just wired between the bloc
    (* keep *) bufbd7 BUF[2:0] (			      |	    (* keep *) sky130_fd_sc_hd__clkbuf_8 BUF[2:0] (
    `ifndef USE_POWER_PINS				      |	    `ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
    `endif							    `endif
        .I({serial_clock, resetn, serial_load}),	      |	        .A({serial_clock, resetn, serial_load}),
        .Z({serial_clock_out, resetn_out, serial_load_out})   |	        .X({serial_clock_out, resetn_out, serial_load_out})
    );								    );

    always @(posedge serial_clock or negedge resetn) begin	    always @(posedge serial_clock or negedge resetn) begin
	if (resetn == 1'b0) begin					if (resetn == 1'b0) begin
	    /* Clear shift register */					    /* Clear shift register */
	    shift_register <= 'd0;					    shift_register <= 'd0;
	end else begin							end else begin
	    /* Shift data in */						    /* Shift data in */
	    shift_register <= {shift_register[PAD_CTRL_BITS-2		    shift_register <= {shift_register[PAD_CTRL_BITS-2
	end								end
    end								    end

    always @(posedge serial_load or negedge resetn) begin	    always @(posedge serial_load or negedge resetn) begin
	if (resetn == 1'b0) begin					if (resetn == 1'b0) begin
	    /* Initial state on reset depends on applied defa		    /* Initial state on reset depends on applied defa
	    mgmt_ena <= gpio_defaults[MGMT_EN];				    mgmt_ena <= gpio_defaults[MGMT_EN];
	    gpio_holdover <= gpio_defaults[HLDH];			    gpio_holdover <= gpio_defaults[HLDH];
	    gpio_slow_sel <= gpio_defaults[SLOW];			    gpio_slow_sel <= gpio_defaults[SLOW];
	    gpio_vtrip_sel <= gpio_defaults[TRIP];			    gpio_vtrip_sel <= gpio_defaults[TRIP];
            gpio_ib_mode_sel <= gpio_defaults[MOD_SEL];		            gpio_ib_mode_sel <= gpio_defaults[MOD_SEL];
	    gpio_inenb <= gpio_defaults[INP_DIS];			    gpio_inenb <= gpio_defaults[INP_DIS];
	    gpio_outenb <= gpio_defaults[OEB];				    gpio_outenb <= gpio_defaults[OEB];
	    gpio_dm <= gpio_defaults[DM+2:DM];				    gpio_dm <= gpio_defaults[DM+2:DM];
	    gpio_ana_en <= gpio_defaults[AN_EN];			    gpio_ana_en <= gpio_defaults[AN_EN];
	    gpio_ana_sel <= gpio_defaults[AN_SEL];			    gpio_ana_sel <= gpio_defaults[AN_SEL];
	    gpio_ana_pol <= gpio_defaults[AN_POL];			    gpio_ana_pol <= gpio_defaults[AN_POL];
	end else begin							end else begin
	    /* Load data */						    /* Load data */
	    mgmt_ena 	     <= shift_register[MGMT_EN];		    mgmt_ena 	     <= shift_register[MGMT_EN];
	    gpio_outenb      <= shift_register[OEB];			    gpio_outenb      <= shift_register[OEB];
	    gpio_holdover    <= shift_register[HLDH]; 			    gpio_holdover    <= shift_register[HLDH]; 
	    gpio_inenb 	     <= shift_register[INP_DIS];		    gpio_inenb 	     <= shift_register[INP_DIS];
	    gpio_ib_mode_sel <= shift_register[MOD_SEL];		    gpio_ib_mode_sel <= shift_register[MOD_SEL];
	    gpio_ana_en      <= shift_register[AN_EN];			    gpio_ana_en      <= shift_register[AN_EN];
	    gpio_ana_sel     <= shift_register[AN_SEL];			    gpio_ana_sel     <= shift_register[AN_SEL];
	    gpio_ana_pol     <= shift_register[AN_POL];			    gpio_ana_pol     <= shift_register[AN_POL];
	    gpio_slow_sel    <= shift_register[SLOW];			    gpio_slow_sel    <= shift_register[SLOW];
	    gpio_vtrip_sel   <= shift_register[TRIP];			    gpio_vtrip_sel   <= shift_register[TRIP];
	    gpio_dm 	     <= shift_register[DM+2:DM];		    gpio_dm 	     <= shift_register[DM+2:DM];

	end								end
    end								    end

    /* These pad configuration signals are static and do not 	    /* These pad configuration signals are static and do not 
    /* after setup.						    /* after setup.					

    assign pad_gpio_holdover 	= gpio_holdover;		    assign pad_gpio_holdover 	= gpio_holdover;
    assign pad_gpio_slow_sel 	= gpio_slow_sel;		    assign pad_gpio_slow_sel 	= gpio_slow_sel;
    assign pad_gpio_vtrip_sel	= gpio_vtrip_sel;		    assign pad_gpio_vtrip_sel	= gpio_vtrip_sel;
    assign pad_gpio_ib_mode_sel	= gpio_ib_mode_sel;		    assign pad_gpio_ib_mode_sel	= gpio_ib_mode_sel;
    assign pad_gpio_ana_en	= gpio_ana_en;			    assign pad_gpio_ana_en	= gpio_ana_en;
    assign pad_gpio_ana_sel	= gpio_ana_sel;			    assign pad_gpio_ana_sel	= gpio_ana_sel;
    assign pad_gpio_ana_pol	= gpio_ana_pol;			    assign pad_gpio_ana_pol	= gpio_ana_pol;
    assign pad_gpio_dm		= gpio_dm;			    assign pad_gpio_dm		= gpio_dm;
    assign pad_gpio_inenb 	= gpio_inenb;			    assign pad_gpio_inenb 	= gpio_inenb;

    /* Implement pad control behavior depending on state of m	    /* Implement pad control behavior depending on state of m

    /* The pad value always goes back to the housekeeping mod	    /* The pad value always goes back to the housekeeping mod

    assign mgmt_gpio_in = pad_gpio_in;				    assign mgmt_gpio_in = pad_gpio_in;

    /* For 2-wire interfaces, the mgmt_gpio_oeb line is tied 	    /* For 2-wire interfaces, the mgmt_gpio_oeb line is tied 
    /* the control block.  In this case, the output enable st	    /* the control block.  In this case, the output enable st
    /* determined by the OEB configuration bit.			    /* determined by the OEB configuration bit.		

    assign pad_gpio_outenb = (mgmt_ena) ? ((mgmt_gpio_oeb == 	    assign pad_gpio_outenb = (mgmt_ena) ? ((mgmt_gpio_oeb == 
			gpio_outenb : 1'b0) : user_gpio_oeb;				gpio_outenb : 1'b0) : user_gpio_oeb;

    /* For 2-wire interfaces, if the pad is configured for pu	    /* For 2-wire interfaces, if the pad is configured for pu
    /* pull-down, drive the output value locally to achieve t	    /* pull-down, drive the output value locally to achieve t
    /* expected pull.						    /* expected pull.					

    assign pad_gpio_out = (mgmt_ena) ? ((mgmt_gpio_oeb == 1'b	    assign pad_gpio_out = (mgmt_ena) ? ((mgmt_gpio_oeb == 1'b
			((gpio_dm[2:1] == 2'b01) ? ~gpio_dm[0				((gpio_dm[2:1] == 2'b01) ? ~gpio_dm[0
			mgmt_gpio_out) : user_gpio_out; 				mgmt_gpio_out) : user_gpio_out; 

    /* Buffer user_gpio_in with an enable that is set by the 	    /* Buffer user_gpio_in with an enable that is set by the 

    gpio_logic_high gpio_logic_high (				    gpio_logic_high gpio_logic_high (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
            .vccd1(vccd1),					            .vccd1(vccd1),
            .vssd1(vssd1),					            .vssd1(vssd1),
`endif								`endif
            .gpio_logic1(gpio_logic1)				            .gpio_logic1(gpio_logic1)
    );								    );

    /* If user project area is powered down, zero the pad inp	    /* If user project area is powered down, zero the pad inp
    /* going to the user project.				    /* going to the user project.			
    assign user_gpio_in = pad_gpio_in & gpio_logic1;		    assign user_gpio_in = pad_gpio_in & gpio_logic1;

    (* keep *)							    (* keep *)
    scl180_marco_sparecell spare_cell (			      |	    sky130_fd_sc_hd__macro_sparecell spare_cell (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
							      >	            .VPB(vccd),
							      >	            .VNB(vssd)
`endif								`endif
    );								    );

    dummy_scl180_conb_1 const_source (			      |	    sky130_fd_sc_hd__conb_1 const_source (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
`endif								`endif
            .HI(one_unbuf),					            .HI(one_unbuf),
            .LO(zero_unbuf)					            .LO(zero_unbuf)
    );								    );

    assign zero = zero_unbuf;					    assign zero = zero_unbuf;
    assign one = one_unbuf;					    assign one = one_unbuf;

endmodule							endmodule
`default_nettype wire						`default_nettype wire
diff -ry rtl/gpio_defaults_block.v verilog/rtl/gpio_defaults_block.v
//`include "dummy_scl180_conb_1.v"			      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      <
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none

// This module represents an unprogrammed set of GPIO pad def	// This module represents an unprogrammed set of GPIO pad def
// values that is configured with via programming on the chip	// values that is configured with via programming on the chip
// level.  This value is passed as a set of parameters (forme	// level.  This value is passed as a set of parameters (forme
// part of gpio_control_block.v).				// part of gpio_control_block.v).

/// sta-blackbox						/// sta-blackbox
module gpio_defaults_block #(					module gpio_defaults_block #(
    // Parameterized initial startup state of the pad.  The d	    // Parameterized initial startup state of the pad.  The d
    // parameters if unspecified is for the pad to be a user 	    // parameters if unspecified is for the pad to be a user 
    // with no pull-up or pull-down, so that it is disconnect	    // with no pull-up or pull-down, so that it is disconnect
    // from the outside world.  See defs.h for configuration 	    // from the outside world.  See defs.h for configuration 
    // definitions.						    // definitions.
    parameter GPIO_CONFIG_INIT = 13'h0402			    parameter GPIO_CONFIG_INIT = 13'h0402
) (								) (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    inout VPWR,							    inout VPWR,
    inout VGND,							    inout VGND,
`endif								`endif
    output [12:0] gpio_defaults					    output [12:0] gpio_defaults
);								);
    wire [12:0] gpio_defaults_high;				    wire [12:0] gpio_defaults_high;
    wire [12:0] gpio_defaults_low;				    wire [12:0] gpio_defaults_low;

    // For the mask revision input, use an array of digital c	    // For the mask revision input, use an array of digital c

    dummy_scl180_conb_1 gpio_default_value [12:0] (	      |	    sky130_fd_sc_hd__conb_1 gpio_default_value [12:0] (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
            .VPWR(VPWR),					            .VPWR(VPWR),
            .VPB(VPWR),						            .VPB(VPWR),
            .VNB(VGND),						            .VNB(VGND),
            .VGND(VGND),					            .VGND(VGND),
`endif								`endif
            .HI(gpio_defaults_high),				            .HI(gpio_defaults_high),
            .LO(gpio_defaults_low)				            .LO(gpio_defaults_low)
    );								    );

    genvar i;							    genvar i;
    generate							    generate
        for (i = 0; i < 13; i = i+1) begin			        for (i = 0; i < 13; i = i+1) begin
    	    assign gpio_defaults[i] = (GPIO_CONFIG_INIT & (13	    	    assign gpio_defaults[i] = (GPIO_CONFIG_INIT & (13
			gpio_defaults_high[i] : gpio_defaults				gpio_defaults_high[i] : gpio_defaults
	end								end
    endgenerate							    endgenerate

endmodule							endmodule
`default_nettype wire						`default_nettype wire
diff -ry rtl/gpio_logic_high.v verilog/rtl/gpio_logic_high.v
module gpio_logic_high(						module gpio_logic_high(
 `ifdef USE_POWER_PINS						 `ifdef USE_POWER_PINS
         inout vccd1,						         inout vccd1,
         inout vssd1,						         inout vssd1,
  `endif							  `endif

   output wire gpio_logic1					   output wire gpio_logic1
);								);

 dummy_scl180_conb_1 gpio_logic_high (			      |	 sky130_fd_sc_hd__conb_1 gpio_logic_high (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
            .VPWR(vccd1),					            .VPWR(vccd1),
            .VGND(vssd1),					            .VGND(vssd1),
            .VPB(vccd1),					            .VPB(vccd1),
            .VNB(vssd1),					            .VNB(vssd1),
`endif								`endif
            .HI(gpio_logic1),					            .HI(gpio_logic1),
            .LO()						            .LO()
    );								    );

endmodule							endmodule
diff -ry rtl/gpio_signal_buffering_alt.v verilog/rtl/gpio_signal_buffering_alt.v
// SPDX-FileCopyrightText: 2022 Efabless Corporation		// SPDX-FileCopyrightText: 2022 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//	http://www.apache.org/licenses/LICENSE-2.0		//	http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

/*								/*
 * gpio_signal_buffering_alt ---				 * gpio_signal_buffering_alt ---
 *								 *
 * This macro buffers long wires between housekeeping and the	 * This macro buffers long wires between housekeeping and the
 * blocks at the top level of caravan.  The rule of thumb is 	 * blocks at the top level of caravan.  The rule of thumb is 
 * single wire length to approximately 1.3mm.  The physical (	 * single wire length to approximately 1.3mm.  The physical (
 * distances and required buffering are as follows:		 * distances and required buffering are as follows:
 *								 *
 * Breakpoints: 1.3, 2.6, 3.9, 5.2, 6.5, 7.8	(mm)		 * Breakpoints: 1.3, 2.6, 3.9, 5.2, 6.5, 7.8	(mm)
 * # buffers:     1,   2,   3,   4,   5,   6			 * # buffers:     1,   2,   3,   4,   5,   6
 *								 *
 * GPIO #    	wire length (mm)	# buffers		 * GPIO #    	wire length (mm)	# buffers
 *------------------------------------------------------	 *------------------------------------------------------
 * GPIO 0	0.4			0			 * GPIO 0	0.4			0
 * GPIO 1	0.2			0			 * GPIO 1	0.2			0
 * GPIO 2	0.0			0			 * GPIO 2	0.0			0
 * GPIO 3	0.3			0			 * GPIO 3	0.3			0
 * GPIO 4	0.5			0			 * GPIO 4	0.5			0
 * GPIO 5	0.7			0			 * GPIO 5	0.7			0
 * GPIO 6	1.0			0			 * GPIO 6	1.0			0
 * GPIO 7	1.4			1			 * GPIO 7	1.4			1	
 * GPIO 8	1.6			1			 * GPIO 8	1.6			1
 * GPIO 9	1.8			1			 * GPIO 9	1.8			1
 * GPIO 10	2.1			1			 * GPIO 10	2.1			1
 * GPIO 11	2.3			1			 * GPIO 11	2.3			1
 * GPIO 12	2.5			1			 * GPIO 12	2.5			1
 * GPIO 13	2.7			2	   RHS		 * GPIO 13	2.7			2	   RHS	
 *-------------------------------------------------------	 *-------------------------------------------------------
 * GPIO 25	6.1			4	   LHS		 * GPIO 25	6.1			4	   LHS
 * GPIO 26	5.9			4			 * GPIO 26	5.9			4
 * GPIO 27	5.7			4			 * GPIO 27	5.7			4
 * GPIO 28	5.5			4			 * GPIO 28	5.5			4
 * GPIO 29	5.3			4			 * GPIO 29	5.3			4
 * GPIO 30	5.1			3			 * GPIO 30	5.1			3
 * GPIO 31	4.8			3			 * GPIO 31	4.8			3
 * GPIO 32	4.2			3			 * GPIO 32	4.2			3
 * GPIO 33	4.0			3			 * GPIO 33	4.0			3
 * GPIO 34	3.8			2			 * GPIO 34	3.8			2
 * GPIO 35	3.5			2			 * GPIO 35	3.5			2
 * GPIO 36	3.3			2			 * GPIO 36	3.3			2
 * GPIO 37	3.4			2			 * GPIO 37	3.4			2
 *------------------------------------------------------	 *------------------------------------------------------
 *	       total number of buffers: 48 (x2 for input and 	 *	       total number of buffers: 48 (x2 for input and 
 *								 *
 * OEB lines go to GPIO 0 and 1 (no buffers needed) and GPIO 	 * OEB lines go to GPIO 0 and 1 (no buffers needed) and GPIO 
 * (2 buffers needed), so OEB lines need 6 additional buffers	 * (2 buffers needed), so OEB lines need 6 additional buffers
 *								 *
 * The assumption is that all GPIOs on the left-hand side of 	 * The assumption is that all GPIOs on the left-hand side of 
 * routed by taking wires left from the housekeeping across t	 * routed by taking wires left from the housekeeping across t
 * SoC to the left side, and then up to the destination.  Rig	 * SoC to the left side, and then up to the destination.  Rig
 * connections go directly up the right side from the houseke	 * connections go directly up the right side from the houseke
 *								 *
 * Note that signal names are related to the signal being pas	 * Note that signal names are related to the signal being pas
 * "in" and "out" refer to the direction of the signal relati	 * "in" and "out" refer to the direction of the signal relati
 * housekeeping block in the top level.  For this macro, unbu	 * housekeeping block in the top level.  For this macro, unbu
 * "unbuf" are the inputs, and buffered signals "buf" are the	 * "unbuf" are the inputs, and buffered signals "buf" are the
 */								 */

module gpio_signal_buffering_alt (				module gpio_signal_buffering_alt (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    vccd,							    vccd,
    vssd,							    vssd,
`endif								`endif
    mgmt_io_in_unbuf,						    mgmt_io_in_unbuf,
    mgmt_io_out_unbuf,						    mgmt_io_out_unbuf,
    mgmt_io_oeb_buf,						    mgmt_io_oeb_buf,
    mgmt_io_in_buf,						    mgmt_io_in_buf,
    mgmt_io_out_buf,						    mgmt_io_out_buf,
    mgmt_io_oeb_unbuf						    mgmt_io_oeb_unbuf
);								);

`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    input  vccd;						    input  vccd;
    input  vssd;						    input  vssd;
`endif								`endif

    /* NOTE:  To match the indices of the same signals in the	    /* NOTE:  To match the indices of the same signals in the
     * top level, add 35 to all OEB lines and add 7 to all in	     * top level, add 35 to all OEB lines and add 7 to all in
     * and out lines up to 14, and add 18 to all in and out	     * and out lines up to 14, and add 18 to all in and out
     * lines above that.					     * lines above that.
     */								     */
    input  [19:0] mgmt_io_in_unbuf;				    input  [19:0] mgmt_io_in_unbuf;
    input  [19:0] mgmt_io_out_unbuf;				    input  [19:0] mgmt_io_out_unbuf;
    input  [2:0] mgmt_io_oeb_unbuf;				    input  [2:0] mgmt_io_oeb_unbuf;
    output [2:0] mgmt_io_oeb_buf;				    output [2:0] mgmt_io_oeb_buf;
    output [19:0] mgmt_io_in_buf;				    output [19:0] mgmt_io_in_buf;
    output [19:0] mgmt_io_out_buf;				    output [19:0] mgmt_io_out_buf;

    /* Instantiate 48 + 48 + 6 = 101 buffers of size 8 */	    /* Instantiate 48 + 48 + 6 = 101 buffers of size 8 */

    wire [101:0] buf_in;					    wire [101:0] buf_in;
    wire [101:0] buf_out;					    wire [101:0] buf_out;

    sky130_fd_sc_hd__buf_8 signal_buffers [101:0] (		    sky130_fd_sc_hd__buf_8 signal_buffers [101:0] (
        `ifdef USE_POWER_PINS					        `ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
	    .VPB(vccd),							    .VPB(vccd),
	    .VNB(vssd),							    .VNB(vssd),
	`endif								`endif
	.A(buf_in),							.A(buf_in),
	.X(buf_out)							.X(buf_out)
    );								    );

    /* Now chain them all together */				    /* Now chain them all together */

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_in, right-hand side				    // mgmt_io_in, right-hand side
    //----------------------------------------			    //----------------------------------------

    assign buf_in[0] = mgmt_io_in_unbuf[0];			    assign buf_in[0] = mgmt_io_in_unbuf[0];
    assign mgmt_io_in_buf[0] = buf_out[0];			    assign mgmt_io_in_buf[0] = buf_out[0];

    assign buf_in[1] = mgmt_io_in_unbuf[1];			    assign buf_in[1] = mgmt_io_in_unbuf[1];
    assign mgmt_io_in_buf[1] = buf_out[1];			    assign mgmt_io_in_buf[1] = buf_out[1];

    assign buf_in[2] = mgmt_io_in_unbuf[2];			    assign buf_in[2] = mgmt_io_in_unbuf[2];
    assign mgmt_io_in_buf[2] = buf_out[2];			    assign mgmt_io_in_buf[2] = buf_out[2];

    assign buf_in[3] = mgmt_io_in_unbuf[3];			    assign buf_in[3] = mgmt_io_in_unbuf[3];
    assign mgmt_io_in_buf[3] = buf_out[3];			    assign mgmt_io_in_buf[3] = buf_out[3];

    assign buf_in[4] = mgmt_io_in_unbuf[4];			    assign buf_in[4] = mgmt_io_in_unbuf[4];
    assign mgmt_io_in_buf[4] = buf_out[4];			    assign mgmt_io_in_buf[4] = buf_out[4];

    assign buf_in[5] = mgmt_io_in_unbuf[5];			    assign buf_in[5] = mgmt_io_in_unbuf[5];
    assign mgmt_io_in_buf[5] = buf_out[5];			    assign mgmt_io_in_buf[5] = buf_out[5];

    assign buf_in[6] = mgmt_io_in_unbuf[6];			    assign buf_in[6] = mgmt_io_in_unbuf[6];
    assign buf_in[7] = buf_out[6];				    assign buf_in[7] = buf_out[6];
    assign mgmt_io_in_buf[6] = buf_out[7];			    assign mgmt_io_in_buf[6] = buf_out[7];

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_in, left-hand side				    // mgmt_io_in, left-hand side
    //----------------------------------------			    //----------------------------------------

    assign buf_in[8] = mgmt_io_in_unbuf[7];			    assign buf_in[8] = mgmt_io_in_unbuf[7];
    assign buf_in[9] = buf_out[8];				    assign buf_in[9] = buf_out[8];
    assign buf_in[10] = buf_out[9];				    assign buf_in[10] = buf_out[9];
    assign buf_in[11] = buf_out[10];				    assign buf_in[11] = buf_out[10];
    assign mgmt_io_in_buf[7] = buf_out[11];			    assign mgmt_io_in_buf[7] = buf_out[11];

    assign buf_in[12] = mgmt_io_in_unbuf[8];			    assign buf_in[12] = mgmt_io_in_unbuf[8];
    assign buf_in[13] = buf_out[12];				    assign buf_in[13] = buf_out[12];
    assign buf_in[14] = buf_out[13];				    assign buf_in[14] = buf_out[13];
    assign buf_in[15] = buf_out[14];				    assign buf_in[15] = buf_out[14];
    assign mgmt_io_in_buf[8] = buf_out[15];			    assign mgmt_io_in_buf[8] = buf_out[15];

    assign buf_in[16] = mgmt_io_in_unbuf[9];			    assign buf_in[16] = mgmt_io_in_unbuf[9];
    assign buf_in[17] = buf_out[16];				    assign buf_in[17] = buf_out[16];
    assign buf_in[18] = buf_out[17];				    assign buf_in[18] = buf_out[17];
    assign buf_in[19] = buf_out[18];				    assign buf_in[19] = buf_out[18];
    assign mgmt_io_in_buf[9] = buf_out[19];			    assign mgmt_io_in_buf[9] = buf_out[19];

    assign buf_in[20] = mgmt_io_in_unbuf[10];			    assign buf_in[20] = mgmt_io_in_unbuf[10];
    assign buf_in[21] = buf_out[20];				    assign buf_in[21] = buf_out[20];
    assign buf_in[22] = buf_out[21];				    assign buf_in[22] = buf_out[21];
    assign buf_in[23] = buf_out[22];				    assign buf_in[23] = buf_out[22];
    assign mgmt_io_in_buf[10] = buf_out[23];			    assign mgmt_io_in_buf[10] = buf_out[23];

    assign buf_in[24] = mgmt_io_in_unbuf[11];			    assign buf_in[24] = mgmt_io_in_unbuf[11];
    assign buf_in[25] = buf_out[24];				    assign buf_in[25] = buf_out[24];
    assign buf_in[26] = buf_out[25];				    assign buf_in[26] = buf_out[25];
    assign buf_in[27] = buf_out[26];				    assign buf_in[27] = buf_out[26];
    assign mgmt_io_in_buf[11] = buf_out[27];			    assign mgmt_io_in_buf[11] = buf_out[27];

    assign buf_in[28] = mgmt_io_in_unbuf[12];			    assign buf_in[28] = mgmt_io_in_unbuf[12];
    assign buf_in[29] = buf_out[28];				    assign buf_in[29] = buf_out[28];
    assign buf_in[30] = buf_out[29];				    assign buf_in[30] = buf_out[29];
    assign mgmt_io_in_buf[12] = buf_out[30];			    assign mgmt_io_in_buf[12] = buf_out[30];

    assign buf_in[31] = mgmt_io_in_unbuf[13];			    assign buf_in[31] = mgmt_io_in_unbuf[13];
    assign buf_in[32] = buf_out[31];				    assign buf_in[32] = buf_out[31];
    assign buf_in[33] = buf_out[32];				    assign buf_in[33] = buf_out[32];
    assign mgmt_io_in_buf[13] = buf_out[33];			    assign mgmt_io_in_buf[13] = buf_out[33];

    assign buf_in[34] = mgmt_io_in_unbuf[14];			    assign buf_in[34] = mgmt_io_in_unbuf[14];
    assign buf_in[35] = buf_out[34];				    assign buf_in[35] = buf_out[34];
    assign buf_in[36] = buf_out[35];				    assign buf_in[36] = buf_out[35];
    assign mgmt_io_in_buf[14] = buf_out[36];			    assign mgmt_io_in_buf[14] = buf_out[36];

    assign buf_in[37] = mgmt_io_in_unbuf[15];			    assign buf_in[37] = mgmt_io_in_unbuf[15];
    assign buf_in[38] = buf_out[37];				    assign buf_in[38] = buf_out[37];
    assign buf_in[39] = buf_out[38];				    assign buf_in[39] = buf_out[38];
    assign mgmt_io_in_buf[15] = buf_out[39];			    assign mgmt_io_in_buf[15] = buf_out[39];

    assign buf_in[40] = mgmt_io_in_unbuf[16];			    assign buf_in[40] = mgmt_io_in_unbuf[16];
    assign buf_in[41] = buf_out[40];				    assign buf_in[41] = buf_out[40];
    assign mgmt_io_in_buf[16] = buf_out[41];			    assign mgmt_io_in_buf[16] = buf_out[41];

    assign buf_in[42] = mgmt_io_in_unbuf[17];			    assign buf_in[42] = mgmt_io_in_unbuf[17];
    assign buf_in[43] = buf_out[42];				    assign buf_in[43] = buf_out[42];
    assign mgmt_io_in_buf[17] = buf_out[43];			    assign mgmt_io_in_buf[17] = buf_out[43];

    assign buf_in[44] = mgmt_io_in_unbuf[18];			    assign buf_in[44] = mgmt_io_in_unbuf[18];
    assign buf_in[45] = buf_out[44];				    assign buf_in[45] = buf_out[44];
    assign mgmt_io_in_buf[18] = buf_out[45];			    assign mgmt_io_in_buf[18] = buf_out[45];

    assign buf_in[46] = mgmt_io_in_unbuf[19];			    assign buf_in[46] = mgmt_io_in_unbuf[19];
    assign buf_in[47] = buf_out[46];				    assign buf_in[47] = buf_out[46];
    assign mgmt_io_in_buf[19] = buf_out[47];			    assign mgmt_io_in_buf[19] = buf_out[47];

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_out, right-hand side				    // mgmt_io_out, right-hand side
    //----------------------------------------			    //----------------------------------------

    assign buf_in[48] = mgmt_io_out_unbuf[0];			    assign buf_in[48] = mgmt_io_out_unbuf[0];
    assign mgmt_io_out_buf[0] = buf_out[48];			    assign mgmt_io_out_buf[0] = buf_out[48];

    assign buf_in[49] = mgmt_io_out_unbuf[1];			    assign buf_in[49] = mgmt_io_out_unbuf[1];
    assign mgmt_io_out_buf[1] = buf_out[49];			    assign mgmt_io_out_buf[1] = buf_out[49];

    assign buf_in[50] = mgmt_io_out_unbuf[2];			    assign buf_in[50] = mgmt_io_out_unbuf[2];
    assign mgmt_io_out_buf[2] = buf_out[50];			    assign mgmt_io_out_buf[2] = buf_out[50];

    assign buf_in[51] = mgmt_io_out_unbuf[3];			    assign buf_in[51] = mgmt_io_out_unbuf[3];
    assign mgmt_io_out_buf[3] = buf_out[51];			    assign mgmt_io_out_buf[3] = buf_out[51];

    assign buf_in[52] = mgmt_io_out_unbuf[4];			    assign buf_in[52] = mgmt_io_out_unbuf[4];
    assign mgmt_io_out_buf[4] = buf_out[52];			    assign mgmt_io_out_buf[4] = buf_out[52];

    assign buf_in[53] = mgmt_io_out_unbuf[5];			    assign buf_in[53] = mgmt_io_out_unbuf[5];
    assign mgmt_io_out_buf[5] = buf_out[53];			    assign mgmt_io_out_buf[5] = buf_out[53];

    assign buf_in[54] = mgmt_io_out_unbuf[6];			    assign buf_in[54] = mgmt_io_out_unbuf[6];
    assign buf_in[55] = buf_out[54];				    assign buf_in[55] = buf_out[54];
    assign mgmt_io_out_buf[6] = buf_out[55];			    assign mgmt_io_out_buf[6] = buf_out[55];

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_out, left-hand side				    // mgmt_io_out, left-hand side
    //----------------------------------------			    //----------------------------------------

    assign buf_in[56] = mgmt_io_out_unbuf[7];			    assign buf_in[56] = mgmt_io_out_unbuf[7];
    assign buf_in[57] = buf_out[56];				    assign buf_in[57] = buf_out[56];
    assign buf_in[58] = buf_out[57];				    assign buf_in[58] = buf_out[57];
    assign buf_in[59] = buf_out[58];				    assign buf_in[59] = buf_out[58];
    assign mgmt_io_out_buf[7] = buf_out[59];			    assign mgmt_io_out_buf[7] = buf_out[59];

    assign buf_in[60] = mgmt_io_out_unbuf[8];			    assign buf_in[60] = mgmt_io_out_unbuf[8];
    assign buf_in[61] = buf_out[60];				    assign buf_in[61] = buf_out[60];
    assign buf_in[62] = buf_out[61];				    assign buf_in[62] = buf_out[61];
    assign buf_in[63] = buf_out[62];				    assign buf_in[63] = buf_out[62];
    assign mgmt_io_out_buf[8] = buf_out[63];			    assign mgmt_io_out_buf[8] = buf_out[63];

    assign buf_in[64] = mgmt_io_out_unbuf[9];			    assign buf_in[64] = mgmt_io_out_unbuf[9];
    assign buf_in[65] = buf_out[64];				    assign buf_in[65] = buf_out[64];
    assign buf_in[66] = buf_out[65];				    assign buf_in[66] = buf_out[65];
    assign buf_in[67] = buf_out[66];				    assign buf_in[67] = buf_out[66];
    assign mgmt_io_out_buf[9] = buf_out[67];			    assign mgmt_io_out_buf[9] = buf_out[67];

    assign buf_in[68] = mgmt_io_out_unbuf[10];			    assign buf_in[68] = mgmt_io_out_unbuf[10];
    assign buf_in[69] = buf_out[68];				    assign buf_in[69] = buf_out[68];
    assign buf_in[70] = buf_out[69];				    assign buf_in[70] = buf_out[69];
    assign buf_in[71] = buf_out[70];				    assign buf_in[71] = buf_out[70];
    assign mgmt_io_out_buf[10] = buf_out[71];			    assign mgmt_io_out_buf[10] = buf_out[71];

    assign buf_in[72] = mgmt_io_out_unbuf[11];			    assign buf_in[72] = mgmt_io_out_unbuf[11];
    assign buf_in[73] = buf_out[72];				    assign buf_in[73] = buf_out[72];
    assign buf_in[74] = buf_out[73];				    assign buf_in[74] = buf_out[73];
    assign buf_in[75] = buf_out[74];				    assign buf_in[75] = buf_out[74];
    assign mgmt_io_out_buf[11] = buf_out[75];			    assign mgmt_io_out_buf[11] = buf_out[75];

    assign buf_in[76] = mgmt_io_out_unbuf[12];			    assign buf_in[76] = mgmt_io_out_unbuf[12];
    assign buf_in[77] = buf_out[76];				    assign buf_in[77] = buf_out[76];
    assign buf_in[78] = buf_out[77];				    assign buf_in[78] = buf_out[77];
    assign mgmt_io_out_buf[12] = buf_out[78];			    assign mgmt_io_out_buf[12] = buf_out[78];

    assign buf_in[79] = mgmt_io_out_unbuf[13];			    assign buf_in[79] = mgmt_io_out_unbuf[13];
    assign buf_in[80] = buf_out[79];				    assign buf_in[80] = buf_out[79];
    assign buf_in[81] = buf_out[80];				    assign buf_in[81] = buf_out[80];
    assign mgmt_io_out_buf[13] = buf_out[81];			    assign mgmt_io_out_buf[13] = buf_out[81];

    assign buf_in[82] = mgmt_io_out_unbuf[14];			    assign buf_in[82] = mgmt_io_out_unbuf[14];
    assign buf_in[83] = buf_out[82];				    assign buf_in[83] = buf_out[82];
    assign buf_in[84] = buf_out[83];				    assign buf_in[84] = buf_out[83];
    assign mgmt_io_out_buf[14] = buf_out[84];			    assign mgmt_io_out_buf[14] = buf_out[84];

    assign buf_in[85] = mgmt_io_out_unbuf[15];			    assign buf_in[85] = mgmt_io_out_unbuf[15];
    assign buf_in[86] = buf_out[85];				    assign buf_in[86] = buf_out[85];
    assign buf_in[87] = buf_out[86];				    assign buf_in[87] = buf_out[86];
    assign mgmt_io_out_buf[15] = buf_out[87];			    assign mgmt_io_out_buf[15] = buf_out[87];

    assign buf_in[88] = mgmt_io_out_unbuf[16];			    assign buf_in[88] = mgmt_io_out_unbuf[16];
    assign buf_in[89] = buf_out[88];				    assign buf_in[89] = buf_out[88];
    assign mgmt_io_out_buf[16] = buf_out[89];			    assign mgmt_io_out_buf[16] = buf_out[89];

    assign buf_in[90] = mgmt_io_out_unbuf[17];			    assign buf_in[90] = mgmt_io_out_unbuf[17];
    assign buf_in[91] = buf_out[90];				    assign buf_in[91] = buf_out[90];
    assign mgmt_io_out_buf[17] = buf_out[91];			    assign mgmt_io_out_buf[17] = buf_out[91];

    assign buf_in[92] = mgmt_io_out_unbuf[18];			    assign buf_in[92] = mgmt_io_out_unbuf[18];
    assign buf_in[93] = buf_out[92];				    assign buf_in[93] = buf_out[92];
    assign mgmt_io_out_buf[18] = buf_out[93];			    assign mgmt_io_out_buf[18] = buf_out[93];

    assign buf_in[94] = mgmt_io_out_unbuf[19];			    assign buf_in[94] = mgmt_io_out_unbuf[19];
    assign buf_in[95] = buf_out[94];				    assign buf_in[95] = buf_out[94];
    assign mgmt_io_out_buf[19] = buf_out[95];			    assign mgmt_io_out_buf[19] = buf_out[95];

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_oeb, left-hand side (only)			    // mgmt_io_oeb, left-hand side (only)
    //----------------------------------------			    //----------------------------------------

    assign buf_in[96] = mgmt_io_oeb_unbuf[0];			    assign buf_in[96] = mgmt_io_oeb_unbuf[0];
    assign buf_in[97] = buf_out[96];				    assign buf_in[97] = buf_out[96];
    assign mgmt_io_oeb_buf[0] = buf_out[97];			    assign mgmt_io_oeb_buf[0] = buf_out[97];

    assign buf_in[98] = mgmt_io_oeb_unbuf[1];			    assign buf_in[98] = mgmt_io_oeb_unbuf[1];
    assign buf_in[99] = buf_out[98];				    assign buf_in[99] = buf_out[98];
    assign mgmt_io_oeb_buf[1] = buf_out[99];			    assign mgmt_io_oeb_buf[1] = buf_out[99];

    assign buf_in[100] = mgmt_io_oeb_unbuf[2];			    assign buf_in[100] = mgmt_io_oeb_unbuf[2];
    assign buf_in[101] = buf_out[100];				    assign buf_in[101] = buf_out[100];
    assign mgmt_io_oeb_buf[2] = buf_out[101];			    assign mgmt_io_oeb_buf[2] = buf_out[101];

    sky130_ef_sc_hd__decap_12 sigbuf_decaps [59:0] (		    sky130_ef_sc_hd__decap_12 sigbuf_decaps [59:0] (
    `ifdef USE_POWER_PINS					    `ifdef USE_POWER_PINS
        .VPWR(vccd),						        .VPWR(vccd),
        .VGND(vssd),						        .VGND(vssd),
        .VPB(vccd),						        .VPB(vccd),
        .VNB(vssd)						        .VNB(vssd)
    `endif							    `endif
    );								    );

endmodule							endmodule
diff -ry rtl/gpio_signal_buffering.v verilog/rtl/gpio_signal_buffering.v
// SPDX-FileCopyrightText: 2022 Efabless Corporation		// SPDX-FileCopyrightText: 2022 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//	http://www.apache.org/licenses/LICENSE-2.0		//	http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

/*								/*
 * gpio_signal_buffering ---					 * gpio_signal_buffering ---
 *								 *
 * This macro buffers long wires between housekeeping and the	 * This macro buffers long wires between housekeeping and the
 * blocks at the top level of caravel.  The rule of thumb is 	 * blocks at the top level of caravel.  The rule of thumb is 
 * single wire length to approximately 1.3mm.  The physical (	 * single wire length to approximately 1.3mm.  The physical (
 * distances and required buffering are as follows:		 * distances and required buffering are as follows:
 *								 *
 * Breakpoints: 1.3, 2.6, 3.9, 5.2, 6.5, 7.8	(mm)		 * Breakpoints: 1.3, 2.6, 3.9, 5.2, 6.5, 7.8	(mm)
 * # buffers:     1,   2,   3,   4,   5,   6			 * # buffers:     1,   2,   3,   4,   5,   6
 *								 *
 * GPIO #    	wire length (mm)	# buffers		 * GPIO #    	wire length (mm)	# buffers
 *------------------------------------------------------	 *------------------------------------------------------
 * GPIO 0	0.4			0			 * GPIO 0	0.4			0
 * GPIO 1	0.2			0			 * GPIO 1	0.2			0
 * GPIO 2	0.0			0			 * GPIO 2	0.0			0
 * GPIO 3	0.3			0			 * GPIO 3	0.3			0
 * GPIO 4	0.5			0			 * GPIO 4	0.5			0
 * GPIO 5	0.7			0			 * GPIO 5	0.7			0
 * GPIO 6	1.0			0			 * GPIO 6	1.0			0
 * GPIO 7	1.4			1			 * GPIO 7	1.4			1	
 * GPIO 8	1.6			1			 * GPIO 8	1.6			1
 * GPIO 9	1.8			1			 * GPIO 9	1.8			1
 * GPIO 10	2.1			1			 * GPIO 10	2.1			1
 * GPIO 11	2.3			1			 * GPIO 11	2.3			1
 * GPIO 12	2.5			1			 * GPIO 12	2.5			1
 * GPIO 13	2.7			2			 * GPIO 13	2.7			2		
 * GPIO 14	3.6			2			 * GPIO 14	3.6			2		
 * GPIO 15	4.5			3			 * GPIO 15	4.5			3		
 * GPIO 16	4.7			3			 * GPIO 16	4.7			3		
 * GPIO 17	5.1			3			 * GPIO 17	5.1			3		
 * GPIO 18	5.4			4	   RHS		 * GPIO 18	5.4			4	   RHS
 *-------------------------------------------------------	 *-------------------------------------------------------
 * GPIO 19	8.4			6	   LHS		 * GPIO 19	8.4			6	   LHS
 * GPIO 20	8.2			6			 * GPIO 20	8.2			6
 * GPIO 21	7.9			6			 * GPIO 21	7.9			6
 * GPIO 22	7.7			5			 * GPIO 22	7.7			5
 * GPIO 23	7.4			5			 * GPIO 23	7.4			5
 * GPIO 24	6.4			4			 * GPIO 24	6.4			4
 * GPIO 25	6.1			4			 * GPIO 25	6.1			4
 * GPIO 26	5.9			4			 * GPIO 26	5.9			4
 * GPIO 27	5.7			4			 * GPIO 27	5.7			4
 * GPIO 28	5.5			4			 * GPIO 28	5.5			4
 * GPIO 29	5.3			4			 * GPIO 29	5.3			4
 * GPIO 30	5.1			3			 * GPIO 30	5.1			3
 * GPIO 31	4.8			3			 * GPIO 31	4.8			3
 * GPIO 32	4.2			3			 * GPIO 32	4.2			3
 * GPIO 33	4.0			3			 * GPIO 33	4.0			3
 * GPIO 34	3.8			2			 * GPIO 34	3.8			2
 * GPIO 35	3.5			2			 * GPIO 35	3.5			2
 * GPIO 36	3.3			2			 * GPIO 36	3.3			2
 * GPIO 37	3.4			2			 * GPIO 37	3.4			2
 *------------------------------------------------------	 *------------------------------------------------------
 *	       total number of buffers: 95 (x2 for input and 	 *	       total number of buffers: 95 (x2 for input and 
 *								 *
 * OEB lines go to GPIO 0 and 1 (no buffers needed) and GPIO 	 * OEB lines go to GPIO 0 and 1 (no buffers needed) and GPIO 
 * (2 buffers needed), so OEB lines need 6 additional buffers	 * (2 buffers needed), so OEB lines need 6 additional buffers
 *								 *
 * The assumption is that all GPIOs on the left-hand side of 	 * The assumption is that all GPIOs on the left-hand side of 
 * routed by taking wires left from the housekeeping across t	 * routed by taking wires left from the housekeeping across t
 * SoC to the left side, and then up to the destination.  Rig	 * SoC to the left side, and then up to the destination.  Rig
 * connections go directly up the right side from the houseke	 * connections go directly up the right side from the houseke
 *								 *
 * Note that signal names are related to the signal being pas	 * Note that signal names are related to the signal being pas
 * "in" and "out" refer to the direction of the signal relati	 * "in" and "out" refer to the direction of the signal relati
 * housekeeping block in the top level.  For this macro, unbu	 * housekeeping block in the top level.  For this macro, unbu
 * "unbuf" are the inputs, and buffered signals "buf" are the	 * "unbuf" are the inputs, and buffered signals "buf" are the
 */								 */

module gpio_signal_buffering (					module gpio_signal_buffering (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
	vccd,								vccd,
	vssd,								vssd,
`endif								`endif
    mgmt_io_in_unbuf,						    mgmt_io_in_unbuf,
    mgmt_io_out_unbuf,						    mgmt_io_out_unbuf,
    mgmt_io_oeb_buf,						    mgmt_io_oeb_buf,
    mgmt_io_in_buf,						    mgmt_io_in_buf,
    mgmt_io_out_buf,						    mgmt_io_out_buf,
    mgmt_io_oeb_unbuf						    mgmt_io_oeb_unbuf
);								);

`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
	input  vccd;							input  vccd;
	input  vssd;							input  vssd;
`endif								`endif

    /* NOTE:  To match the indices of the same signals in the	    /* NOTE:  To match the indices of the same signals in the
     * top level, add 35 to all OEB lines and add 7 to all in	     * top level, add 35 to all OEB lines and add 7 to all in
     */								     */
    input  [30:0] mgmt_io_in_unbuf;				    input  [30:0] mgmt_io_in_unbuf;
    input  [30:0] mgmt_io_out_unbuf;				    input  [30:0] mgmt_io_out_unbuf;
    input  [2:0] mgmt_io_oeb_unbuf;				    input  [2:0] mgmt_io_oeb_unbuf;
    output [2:0] mgmt_io_oeb_buf;				    output [2:0] mgmt_io_oeb_buf;
    output [30:0] mgmt_io_in_buf;				    output [30:0] mgmt_io_in_buf;
    output [30:0] mgmt_io_out_buf;				    output [30:0] mgmt_io_out_buf;

    /* Instantiate 95 + 95 + 6 = 196 buffers of size 8 */	    /* Instantiate 95 + 95 + 6 = 196 buffers of size 8 */

    wire [195:0] buf_in;					    wire [195:0] buf_in;
    wire [195:0] buf_out;					    wire [195:0] buf_out;

    buffd7 signal_buffers [195:0] (			      |	    sky130_fd_sc_hd__buf_8 signal_buffers [195:0] (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
	    .VPB(vccd),							    .VPB(vccd),
	    .VNB(vssd),							    .VNB(vssd),
	`endif								`endif
	.I(buf_in),					      |		.A(buf_in),
	.Z(buf_out)					      |		.X(buf_out)
    );								    );

    /* Now chain them all together */				    /* Now chain them all together */

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_in, right-hand side				    // mgmt_io_in, right-hand side
    //----------------------------------------			    //----------------------------------------

    assign buf_in[0] = mgmt_io_in_unbuf[0];			    assign buf_in[0] = mgmt_io_in_unbuf[0];
    assign mgmt_io_in_buf[0] = buf_out[0];			    assign mgmt_io_in_buf[0] = buf_out[0];

    assign buf_in[1] = mgmt_io_in_unbuf[1];			    assign buf_in[1] = mgmt_io_in_unbuf[1];
    assign mgmt_io_in_buf[1] = buf_out[1];			    assign mgmt_io_in_buf[1] = buf_out[1];

    assign buf_in[2] = mgmt_io_in_unbuf[2];			    assign buf_in[2] = mgmt_io_in_unbuf[2];
    assign mgmt_io_in_buf[2] = buf_out[2];			    assign mgmt_io_in_buf[2] = buf_out[2];

    assign buf_in[3] = mgmt_io_in_unbuf[3];			    assign buf_in[3] = mgmt_io_in_unbuf[3];
    assign mgmt_io_in_buf[3] = buf_out[3];			    assign mgmt_io_in_buf[3] = buf_out[3];

    assign buf_in[4] = mgmt_io_in_unbuf[4];			    assign buf_in[4] = mgmt_io_in_unbuf[4];
    assign mgmt_io_in_buf[4] = buf_out[4];			    assign mgmt_io_in_buf[4] = buf_out[4];

    assign buf_in[5] = mgmt_io_in_unbuf[5];			    assign buf_in[5] = mgmt_io_in_unbuf[5];
    assign mgmt_io_in_buf[5] = buf_out[5];			    assign mgmt_io_in_buf[5] = buf_out[5];

    assign buf_in[6] = mgmt_io_in_unbuf[6];			    assign buf_in[6] = mgmt_io_in_unbuf[6];
    assign buf_in[7] = buf_out[6];				    assign buf_in[7] = buf_out[6];
    assign mgmt_io_in_buf[6] = buf_out[7];			    assign mgmt_io_in_buf[6] = buf_out[7];

    assign buf_in[8] = mgmt_io_in_unbuf[7];			    assign buf_in[8] = mgmt_io_in_unbuf[7];
    assign buf_in[9] = buf_out[8];				    assign buf_in[9] = buf_out[8];
    assign mgmt_io_in_buf[7] = buf_out[9];			    assign mgmt_io_in_buf[7] = buf_out[9];

    assign buf_in[10] = mgmt_io_in_unbuf[8];			    assign buf_in[10] = mgmt_io_in_unbuf[8];
    assign buf_in[11] = buf_out[10];				    assign buf_in[11] = buf_out[10];
    assign buf_in[12] = buf_out[11];				    assign buf_in[12] = buf_out[11];
    assign mgmt_io_in_buf[8] = buf_out[12];			    assign mgmt_io_in_buf[8] = buf_out[12];

    assign buf_in[13] = mgmt_io_in_unbuf[9];			    assign buf_in[13] = mgmt_io_in_unbuf[9];
    assign buf_in[14] = buf_out[13];				    assign buf_in[14] = buf_out[13];
    assign buf_in[15] = buf_out[14];				    assign buf_in[15] = buf_out[14];
    assign mgmt_io_in_buf[9] = buf_out[15];			    assign mgmt_io_in_buf[9] = buf_out[15];

    assign buf_in[16] = mgmt_io_in_unbuf[10];			    assign buf_in[16] = mgmt_io_in_unbuf[10];
    assign buf_in[17] = buf_out[16];				    assign buf_in[17] = buf_out[16];
    assign buf_in[18] = buf_out[17];				    assign buf_in[18] = buf_out[17];
    assign mgmt_io_in_buf[10] = buf_out[18];			    assign mgmt_io_in_buf[10] = buf_out[18];

    assign buf_in[19] = mgmt_io_in_unbuf[11];			    assign buf_in[19] = mgmt_io_in_unbuf[11];
    assign buf_in[20] = buf_out[19];				    assign buf_in[20] = buf_out[19];
    assign buf_in[21] = buf_out[20];				    assign buf_in[21] = buf_out[20];
    assign buf_in[22] = buf_out[21];				    assign buf_in[22] = buf_out[21];
    assign mgmt_io_in_buf[11] = buf_out[22];			    assign mgmt_io_in_buf[11] = buf_out[22];

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_in, left-hand side				    // mgmt_io_in, left-hand side
    //----------------------------------------			    //----------------------------------------

    assign buf_in[23] = mgmt_io_in_unbuf[12];			    assign buf_in[23] = mgmt_io_in_unbuf[12];
    assign buf_in[24] = buf_out[23];				    assign buf_in[24] = buf_out[23];
    assign buf_in[25] = buf_out[24];				    assign buf_in[25] = buf_out[24];
    assign buf_in[26] = buf_out[25];				    assign buf_in[26] = buf_out[25];
    assign buf_in[27] = buf_out[26];				    assign buf_in[27] = buf_out[26];
    assign buf_in[28] = buf_out[27];				    assign buf_in[28] = buf_out[27];
    assign mgmt_io_in_buf[12] = buf_out[28];			    assign mgmt_io_in_buf[12] = buf_out[28];

    assign buf_in[29] = mgmt_io_in_unbuf[13];			    assign buf_in[29] = mgmt_io_in_unbuf[13];
    assign buf_in[30] = buf_out[29];				    assign buf_in[30] = buf_out[29];
    assign buf_in[31] = buf_out[30];				    assign buf_in[31] = buf_out[30];
    assign buf_in[32] = buf_out[31];				    assign buf_in[32] = buf_out[31];
    assign buf_in[33] = buf_out[32];				    assign buf_in[33] = buf_out[32];
    assign buf_in[34] = buf_out[33];				    assign buf_in[34] = buf_out[33];
    assign mgmt_io_in_buf[13] = buf_out[34];			    assign mgmt_io_in_buf[13] = buf_out[34];

    assign buf_in[35] = mgmt_io_in_unbuf[14];			    assign buf_in[35] = mgmt_io_in_unbuf[14];
    assign buf_in[36] = buf_out[35];				    assign buf_in[36] = buf_out[35];
    assign buf_in[37] = buf_out[36];				    assign buf_in[37] = buf_out[36];
    assign buf_in[38] = buf_out[37];				    assign buf_in[38] = buf_out[37];
    assign buf_in[39] = buf_out[38];				    assign buf_in[39] = buf_out[38];
    assign buf_in[40] = buf_out[39];				    assign buf_in[40] = buf_out[39];
    assign mgmt_io_in_buf[14] = buf_out[40];			    assign mgmt_io_in_buf[14] = buf_out[40];

    assign buf_in[41] = mgmt_io_in_unbuf[15];			    assign buf_in[41] = mgmt_io_in_unbuf[15];
    assign buf_in[42] = buf_out[41];				    assign buf_in[42] = buf_out[41];
    assign buf_in[43] = buf_out[42];				    assign buf_in[43] = buf_out[42];
    assign buf_in[44] = buf_out[43];				    assign buf_in[44] = buf_out[43];
    assign buf_in[45] = buf_out[44];				    assign buf_in[45] = buf_out[44];
    assign mgmt_io_in_buf[15] = buf_out[45];			    assign mgmt_io_in_buf[15] = buf_out[45];

    assign buf_in[46] = mgmt_io_in_unbuf[16];			    assign buf_in[46] = mgmt_io_in_unbuf[16];
    assign buf_in[47] = buf_out[46];				    assign buf_in[47] = buf_out[46];
    assign buf_in[48] = buf_out[47];				    assign buf_in[48] = buf_out[47];
    assign buf_in[49] = buf_out[48];				    assign buf_in[49] = buf_out[48];
    assign buf_in[50] = buf_out[49];				    assign buf_in[50] = buf_out[49];
    assign mgmt_io_in_buf[16] = buf_out[50];			    assign mgmt_io_in_buf[16] = buf_out[50];

    assign buf_in[51] = mgmt_io_in_unbuf[17];			    assign buf_in[51] = mgmt_io_in_unbuf[17];
    assign buf_in[52] = buf_out[51];				    assign buf_in[52] = buf_out[51];
    assign buf_in[53] = buf_out[52];				    assign buf_in[53] = buf_out[52];
    assign buf_in[54] = buf_out[53];				    assign buf_in[54] = buf_out[53];
    assign mgmt_io_in_buf[17] = buf_out[54];			    assign mgmt_io_in_buf[17] = buf_out[54];

    assign buf_in[55] = mgmt_io_in_unbuf[18];			    assign buf_in[55] = mgmt_io_in_unbuf[18];
    assign buf_in[56] = buf_out[55];				    assign buf_in[56] = buf_out[55];
    assign buf_in[57] = buf_out[56];				    assign buf_in[57] = buf_out[56];
    assign buf_in[58] = buf_out[57];				    assign buf_in[58] = buf_out[57];
    assign mgmt_io_in_buf[18] = buf_out[58];			    assign mgmt_io_in_buf[18] = buf_out[58];

    assign buf_in[59] = mgmt_io_in_unbuf[19];			    assign buf_in[59] = mgmt_io_in_unbuf[19];
    assign buf_in[60] = buf_out[59];				    assign buf_in[60] = buf_out[59];
    assign buf_in[61] = buf_out[60];				    assign buf_in[61] = buf_out[60];
    assign buf_in[62] = buf_out[61];				    assign buf_in[62] = buf_out[61];
    assign mgmt_io_in_buf[19] = buf_out[62];			    assign mgmt_io_in_buf[19] = buf_out[62];

    assign buf_in[63] = mgmt_io_in_unbuf[20];			    assign buf_in[63] = mgmt_io_in_unbuf[20];
    assign buf_in[64] = buf_out[63];				    assign buf_in[64] = buf_out[63];
    assign buf_in[65] = buf_out[64];				    assign buf_in[65] = buf_out[64];
    assign buf_in[66] = buf_out[65];				    assign buf_in[66] = buf_out[65];
    assign mgmt_io_in_buf[20] = buf_out[66];			    assign mgmt_io_in_buf[20] = buf_out[66];

    assign buf_in[67] = mgmt_io_in_unbuf[21];			    assign buf_in[67] = mgmt_io_in_unbuf[21];
    assign buf_in[68] = buf_out[67];				    assign buf_in[68] = buf_out[67];
    assign buf_in[69] = buf_out[68];				    assign buf_in[69] = buf_out[68];
    assign buf_in[70] = buf_out[69];				    assign buf_in[70] = buf_out[69];
    assign mgmt_io_in_buf[21] = buf_out[70];			    assign mgmt_io_in_buf[21] = buf_out[70];

    assign buf_in[71] = mgmt_io_in_unbuf[22];			    assign buf_in[71] = mgmt_io_in_unbuf[22];
    assign buf_in[72] = buf_out[71];				    assign buf_in[72] = buf_out[71];
    assign buf_in[73] = buf_out[72];				    assign buf_in[73] = buf_out[72];
    assign buf_in[74] = buf_out[73];				    assign buf_in[74] = buf_out[73];
    assign mgmt_io_in_buf[22] = buf_out[74];			    assign mgmt_io_in_buf[22] = buf_out[74];

    assign buf_in[75] = mgmt_io_in_unbuf[23];			    assign buf_in[75] = mgmt_io_in_unbuf[23];
    assign buf_in[76] = buf_out[75];				    assign buf_in[76] = buf_out[75];
    assign buf_in[77] = buf_out[76];				    assign buf_in[77] = buf_out[76];
    assign mgmt_io_in_buf[23] = buf_out[77];			    assign mgmt_io_in_buf[23] = buf_out[77];

    assign buf_in[78] = mgmt_io_in_unbuf[24];			    assign buf_in[78] = mgmt_io_in_unbuf[24];
    assign buf_in[79] = buf_out[78];				    assign buf_in[79] = buf_out[78];
    assign buf_in[80] = buf_out[79];				    assign buf_in[80] = buf_out[79];
    assign mgmt_io_in_buf[24] = buf_out[80];			    assign mgmt_io_in_buf[24] = buf_out[80];

    assign buf_in[81] = mgmt_io_in_unbuf[25];			    assign buf_in[81] = mgmt_io_in_unbuf[25];
    assign buf_in[82] = buf_out[81];				    assign buf_in[82] = buf_out[81];
    assign buf_in[83] = buf_out[82];				    assign buf_in[83] = buf_out[82];
    assign mgmt_io_in_buf[25] = buf_out[83];			    assign mgmt_io_in_buf[25] = buf_out[83];

    assign buf_in[84] = mgmt_io_in_unbuf[26];			    assign buf_in[84] = mgmt_io_in_unbuf[26];
    assign buf_in[85] = buf_out[84];				    assign buf_in[85] = buf_out[84];
    assign buf_in[86] = buf_out[85];				    assign buf_in[86] = buf_out[85];
    assign mgmt_io_in_buf[26] = buf_out[86];			    assign mgmt_io_in_buf[26] = buf_out[86];

    assign buf_in[87] = mgmt_io_in_unbuf[27];			    assign buf_in[87] = mgmt_io_in_unbuf[27];
    assign buf_in[88] = buf_out[87];				    assign buf_in[88] = buf_out[87];
    assign mgmt_io_in_buf[27] = buf_out[88];			    assign mgmt_io_in_buf[27] = buf_out[88];

    assign buf_in[89] = mgmt_io_in_unbuf[28];			    assign buf_in[89] = mgmt_io_in_unbuf[28];
    assign buf_in[90] = buf_out[89];				    assign buf_in[90] = buf_out[89];
    assign mgmt_io_in_buf[28] = buf_out[90];			    assign mgmt_io_in_buf[28] = buf_out[90];

    assign buf_in[91] = mgmt_io_in_unbuf[29];			    assign buf_in[91] = mgmt_io_in_unbuf[29];
    assign buf_in[92] = buf_out[91];				    assign buf_in[92] = buf_out[91];
    assign mgmt_io_in_buf[29] = buf_out[92];			    assign mgmt_io_in_buf[29] = buf_out[92];

    assign buf_in[93] = mgmt_io_in_unbuf[30];			    assign buf_in[93] = mgmt_io_in_unbuf[30];
    assign buf_in[94] = buf_out[93];				    assign buf_in[94] = buf_out[93];
    assign mgmt_io_in_buf[30] = buf_out[94];			    assign mgmt_io_in_buf[30] = buf_out[94];

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_out, right-hand side				    // mgmt_io_out, right-hand side
    //----------------------------------------			    //----------------------------------------

    assign buf_in[95] = mgmt_io_out_unbuf[0];			    assign buf_in[95] = mgmt_io_out_unbuf[0];
    assign mgmt_io_out_buf[0] = buf_out[95];			    assign mgmt_io_out_buf[0] = buf_out[95];

    assign buf_in[96] = mgmt_io_out_unbuf[1];			    assign buf_in[96] = mgmt_io_out_unbuf[1];
    assign mgmt_io_out_buf[1] = buf_out[96];			    assign mgmt_io_out_buf[1] = buf_out[96];

    assign buf_in[97] = mgmt_io_out_unbuf[2];			    assign buf_in[97] = mgmt_io_out_unbuf[2];
    assign mgmt_io_out_buf[2] = buf_out[97];			    assign mgmt_io_out_buf[2] = buf_out[97];

    assign buf_in[98] = mgmt_io_out_unbuf[3];			    assign buf_in[98] = mgmt_io_out_unbuf[3];
    assign mgmt_io_out_buf[3] = buf_out[98];			    assign mgmt_io_out_buf[3] = buf_out[98];

    assign buf_in[99] = mgmt_io_out_unbuf[4];			    assign buf_in[99] = mgmt_io_out_unbuf[4];
    assign mgmt_io_out_buf[4] = buf_out[99];			    assign mgmt_io_out_buf[4] = buf_out[99];

    assign buf_in[100] = mgmt_io_out_unbuf[5];			    assign buf_in[100] = mgmt_io_out_unbuf[5];
    assign mgmt_io_out_buf[5] = buf_out[100];			    assign mgmt_io_out_buf[5] = buf_out[100];

    assign buf_in[101] = mgmt_io_out_unbuf[6];			    assign buf_in[101] = mgmt_io_out_unbuf[6];
    assign buf_in[102] = buf_out[101];				    assign buf_in[102] = buf_out[101];
    assign mgmt_io_out_buf[6] = buf_out[102];			    assign mgmt_io_out_buf[6] = buf_out[102];

    assign buf_in[103] = mgmt_io_out_unbuf[7];			    assign buf_in[103] = mgmt_io_out_unbuf[7];
    assign buf_in[104] = buf_out[103];				    assign buf_in[104] = buf_out[103];
    assign mgmt_io_out_buf[7] = buf_out[104];			    assign mgmt_io_out_buf[7] = buf_out[104];

    assign buf_in[105] = mgmt_io_out_unbuf[8];			    assign buf_in[105] = mgmt_io_out_unbuf[8];
    assign buf_in[106] = buf_out[105];				    assign buf_in[106] = buf_out[105];
    assign buf_in[107] = buf_out[106];				    assign buf_in[107] = buf_out[106];
    assign mgmt_io_out_buf[8] = buf_out[107];			    assign mgmt_io_out_buf[8] = buf_out[107];

    assign buf_in[108] = mgmt_io_out_unbuf[9];			    assign buf_in[108] = mgmt_io_out_unbuf[9];
    assign buf_in[109] = buf_out[108];				    assign buf_in[109] = buf_out[108];
    assign buf_in[110] = buf_out[109];				    assign buf_in[110] = buf_out[109];
    assign mgmt_io_out_buf[9] = buf_out[110];			    assign mgmt_io_out_buf[9] = buf_out[110];

    assign buf_in[111] = mgmt_io_out_unbuf[10];			    assign buf_in[111] = mgmt_io_out_unbuf[10];
    assign buf_in[112] = buf_out[111];				    assign buf_in[112] = buf_out[111];
    assign buf_in[113] = buf_out[112];				    assign buf_in[113] = buf_out[112];
    assign mgmt_io_out_buf[10] = buf_out[113];			    assign mgmt_io_out_buf[10] = buf_out[113];

    assign buf_in[114] = mgmt_io_out_unbuf[11];			    assign buf_in[114] = mgmt_io_out_unbuf[11];
    assign buf_in[115] = buf_out[114];				    assign buf_in[115] = buf_out[114];
    assign buf_in[116] = buf_out[115];				    assign buf_in[116] = buf_out[115];
    assign buf_in[117] = buf_out[116];				    assign buf_in[117] = buf_out[116];
    assign mgmt_io_out_buf[11] = buf_out[117];			    assign mgmt_io_out_buf[11] = buf_out[117];

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_out, left-hand side				    // mgmt_io_out, left-hand side
    //----------------------------------------			    //----------------------------------------

    assign buf_in[118] = mgmt_io_out_unbuf[12];			    assign buf_in[118] = mgmt_io_out_unbuf[12];
    assign buf_in[119] = buf_out[118];				    assign buf_in[119] = buf_out[118];
    assign buf_in[120] = buf_out[119];				    assign buf_in[120] = buf_out[119];
    assign buf_in[121] = buf_out[120];				    assign buf_in[121] = buf_out[120];
    assign buf_in[122] = buf_out[121];				    assign buf_in[122] = buf_out[121];
    assign buf_in[123] = buf_out[122];				    assign buf_in[123] = buf_out[122];
    assign mgmt_io_out_buf[12] = buf_out[123];			    assign mgmt_io_out_buf[12] = buf_out[123];

    assign buf_in[124] = mgmt_io_out_unbuf[13];			    assign buf_in[124] = mgmt_io_out_unbuf[13];
    assign buf_in[125] = buf_out[124];				    assign buf_in[125] = buf_out[124];
    assign buf_in[126] = buf_out[125];				    assign buf_in[126] = buf_out[125];
    assign buf_in[127] = buf_out[126];				    assign buf_in[127] = buf_out[126];
    assign buf_in[128] = buf_out[127];				    assign buf_in[128] = buf_out[127];
    assign buf_in[129] = buf_out[128];				    assign buf_in[129] = buf_out[128];
    assign mgmt_io_out_buf[13] = buf_out[129];			    assign mgmt_io_out_buf[13] = buf_out[129];

    assign buf_in[130] = mgmt_io_out_unbuf[14];			    assign buf_in[130] = mgmt_io_out_unbuf[14];
    assign buf_in[131] = buf_out[130];				    assign buf_in[131] = buf_out[130];
    assign buf_in[132] = buf_out[131];				    assign buf_in[132] = buf_out[131];
    assign buf_in[133] = buf_out[132];				    assign buf_in[133] = buf_out[132];
    assign buf_in[134] = buf_out[133];				    assign buf_in[134] = buf_out[133];
    assign buf_in[135] = buf_out[134];				    assign buf_in[135] = buf_out[134];
    assign mgmt_io_out_buf[14] = buf_out[135];			    assign mgmt_io_out_buf[14] = buf_out[135];

    assign buf_in[136] = mgmt_io_out_unbuf[15];			    assign buf_in[136] = mgmt_io_out_unbuf[15];
    assign buf_in[137] = buf_out[136];				    assign buf_in[137] = buf_out[136];
    assign buf_in[138] = buf_out[137];				    assign buf_in[138] = buf_out[137];
    assign buf_in[139] = buf_out[138];				    assign buf_in[139] = buf_out[138];
    assign buf_in[140] = buf_out[139];				    assign buf_in[140] = buf_out[139];
    assign mgmt_io_out_buf[15] = buf_out[140];			    assign mgmt_io_out_buf[15] = buf_out[140];

    assign buf_in[141] = mgmt_io_out_unbuf[16];			    assign buf_in[141] = mgmt_io_out_unbuf[16];
    assign buf_in[142] = buf_out[141];				    assign buf_in[142] = buf_out[141];
    assign buf_in[143] = buf_out[142];				    assign buf_in[143] = buf_out[142];
    assign buf_in[144] = buf_out[143];				    assign buf_in[144] = buf_out[143];
    assign buf_in[145] = buf_out[144];				    assign buf_in[145] = buf_out[144];
    assign mgmt_io_out_buf[16] = buf_out[145];			    assign mgmt_io_out_buf[16] = buf_out[145];

    assign buf_in[146] = mgmt_io_out_unbuf[17];			    assign buf_in[146] = mgmt_io_out_unbuf[17];
    assign buf_in[147] = buf_out[146];				    assign buf_in[147] = buf_out[146];
    assign buf_in[148] = buf_out[147];				    assign buf_in[148] = buf_out[147];
    assign buf_in[149] = buf_out[148];				    assign buf_in[149] = buf_out[148];
    assign mgmt_io_out_buf[17] = buf_out[149];			    assign mgmt_io_out_buf[17] = buf_out[149];

    assign buf_in[150] = mgmt_io_out_unbuf[18];			    assign buf_in[150] = mgmt_io_out_unbuf[18];
    assign buf_in[151] = buf_out[150];				    assign buf_in[151] = buf_out[150];
    assign buf_in[152] = buf_out[151];				    assign buf_in[152] = buf_out[151];
    assign buf_in[153] = buf_out[152];				    assign buf_in[153] = buf_out[152];
    assign mgmt_io_out_buf[18] = buf_out[153];			    assign mgmt_io_out_buf[18] = buf_out[153];

    assign buf_in[154] = mgmt_io_out_unbuf[19];			    assign buf_in[154] = mgmt_io_out_unbuf[19];
    assign buf_in[155] = buf_out[154];				    assign buf_in[155] = buf_out[154];
    assign buf_in[156] = buf_out[155];				    assign buf_in[156] = buf_out[155];
    assign buf_in[157] = buf_out[156];				    assign buf_in[157] = buf_out[156];
    assign mgmt_io_out_buf[19] = buf_out[157];			    assign mgmt_io_out_buf[19] = buf_out[157];

    assign buf_in[158] = mgmt_io_out_unbuf[20];			    assign buf_in[158] = mgmt_io_out_unbuf[20];
    assign buf_in[159] = buf_out[158];				    assign buf_in[159] = buf_out[158];
    assign buf_in[160] = buf_out[159];				    assign buf_in[160] = buf_out[159];
    assign buf_in[161] = buf_out[160];				    assign buf_in[161] = buf_out[160];
    assign mgmt_io_out_buf[20] = buf_out[161];			    assign mgmt_io_out_buf[20] = buf_out[161];

    assign buf_in[162] = mgmt_io_out_unbuf[21];			    assign buf_in[162] = mgmt_io_out_unbuf[21];
    assign buf_in[163] = buf_out[162];				    assign buf_in[163] = buf_out[162];
    assign buf_in[164] = buf_out[163];				    assign buf_in[164] = buf_out[163];
    assign buf_in[165] = buf_out[164];				    assign buf_in[165] = buf_out[164];
    assign mgmt_io_out_buf[21] = buf_out[165];			    assign mgmt_io_out_buf[21] = buf_out[165];

    assign buf_in[166] = mgmt_io_out_unbuf[22];			    assign buf_in[166] = mgmt_io_out_unbuf[22];
    assign buf_in[167] = buf_out[166];				    assign buf_in[167] = buf_out[166];
    assign buf_in[168] = buf_out[167];				    assign buf_in[168] = buf_out[167];
    assign buf_in[169] = buf_out[168];				    assign buf_in[169] = buf_out[168];
    assign mgmt_io_out_buf[22] = buf_out[169];			    assign mgmt_io_out_buf[22] = buf_out[169];

    assign buf_in[170] = mgmt_io_out_unbuf[23];			    assign buf_in[170] = mgmt_io_out_unbuf[23];
    assign buf_in[171] = buf_out[170];				    assign buf_in[171] = buf_out[170];
    assign buf_in[172] = buf_out[171];				    assign buf_in[172] = buf_out[171];
    assign mgmt_io_out_buf[23] = buf_out[172];			    assign mgmt_io_out_buf[23] = buf_out[172];

    assign buf_in[173] = mgmt_io_out_unbuf[24];			    assign buf_in[173] = mgmt_io_out_unbuf[24];
    assign buf_in[174] = buf_out[173];				    assign buf_in[174] = buf_out[173];
    assign buf_in[175] = buf_out[174];				    assign buf_in[175] = buf_out[174];
    assign mgmt_io_out_buf[24] = buf_out[175];			    assign mgmt_io_out_buf[24] = buf_out[175];

    assign buf_in[176] = mgmt_io_out_unbuf[25];			    assign buf_in[176] = mgmt_io_out_unbuf[25];
    assign buf_in[177] = buf_out[176];				    assign buf_in[177] = buf_out[176];
    assign buf_in[178] = buf_out[177];				    assign buf_in[178] = buf_out[177];
    assign mgmt_io_out_buf[25] = buf_out[178];			    assign mgmt_io_out_buf[25] = buf_out[178];

    assign buf_in[179] = mgmt_io_out_unbuf[26];			    assign buf_in[179] = mgmt_io_out_unbuf[26];
    assign buf_in[180] = buf_out[179];				    assign buf_in[180] = buf_out[179];
    assign buf_in[181] = buf_out[180];				    assign buf_in[181] = buf_out[180];
    assign mgmt_io_out_buf[26] = buf_out[181];			    assign mgmt_io_out_buf[26] = buf_out[181];

    assign buf_in[182] = mgmt_io_out_unbuf[27];			    assign buf_in[182] = mgmt_io_out_unbuf[27];
    assign buf_in[183] = buf_out[182];				    assign buf_in[183] = buf_out[182];
    assign mgmt_io_out_buf[27] = buf_out[183];			    assign mgmt_io_out_buf[27] = buf_out[183];

    assign buf_in[184] = mgmt_io_out_unbuf[28];			    assign buf_in[184] = mgmt_io_out_unbuf[28];
    assign buf_in[185] = buf_out[184];				    assign buf_in[185] = buf_out[184];
    assign mgmt_io_out_buf[28] = buf_out[185];			    assign mgmt_io_out_buf[28] = buf_out[185];

    assign buf_in[186] = mgmt_io_out_unbuf[29];			    assign buf_in[186] = mgmt_io_out_unbuf[29];
    assign buf_in[187] = buf_out[186];				    assign buf_in[187] = buf_out[186];
    assign mgmt_io_out_buf[29] = buf_out[187];			    assign mgmt_io_out_buf[29] = buf_out[187];

    assign buf_in[188] = mgmt_io_out_unbuf[30];			    assign buf_in[188] = mgmt_io_out_unbuf[30];
    assign buf_in[189] = buf_out[188];				    assign buf_in[189] = buf_out[188];
    assign mgmt_io_out_buf[30] = buf_out[189];			    assign mgmt_io_out_buf[30] = buf_out[189];

    //----------------------------------------			    //----------------------------------------
    // mgmt_io_oeb, left-hand side (only)			    // mgmt_io_oeb, left-hand side (only)
    //----------------------------------------			    //----------------------------------------

    assign buf_in[190] = mgmt_io_oeb_unbuf[0];			    assign buf_in[190] = mgmt_io_oeb_unbuf[0];
    assign buf_in[191] = buf_out[190];				    assign buf_in[191] = buf_out[190];
    assign mgmt_io_oeb_buf[0] = buf_out[191];			    assign mgmt_io_oeb_buf[0] = buf_out[191];

    assign buf_in[192] = mgmt_io_oeb_unbuf[1];			    assign buf_in[192] = mgmt_io_oeb_unbuf[1];
    assign buf_in[193] = buf_out[192];				    assign buf_in[193] = buf_out[192];
    assign mgmt_io_oeb_buf[1] = buf_out[193];			    assign mgmt_io_oeb_buf[1] = buf_out[193];

    assign buf_in[194] = mgmt_io_oeb_unbuf[2];			    assign buf_in[194] = mgmt_io_oeb_unbuf[2];
    assign buf_in[195] = buf_out[194];				    assign buf_in[195] = buf_out[194];
    assign mgmt_io_oeb_buf[2] = buf_out[195];			    assign mgmt_io_oeb_buf[2] = buf_out[195];

/* sky130_ef_sc_hd__decap_12 sigbuf_decaps [100:0] (	      |	  sky130_ef_sc_hd__decap_12 sigbuf_decaps [100:0] (
	`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
	    .VPWR(vccd),						    .VPWR(vccd),
	    .VGND(vssd),						    .VGND(vssd),
	    .VPB(vccd),							    .VPB(vccd),
	    .VNB(vssd)							    .VNB(vssd)
	`endif								`endif
  );								  );
*/							      <
// Need to understand why decap cells have been included here <

endmodule							endmodule
Only in verilog/rtl: housekeeping_alt.v
Only in verilog/rtl: housekeeping_spi_o.v
diff -ry rtl/housekeeping_spi.v verilog/rtl/housekeeping_spi.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none

//-----------------------------------------------------------	//-----------------------------------------------------------
// SPI controller for vsdCaravel			      |	// SPI controller for Caravel
//-----------------------------------------------------------	//-----------------------------------------------------------
// housekeeping_spi.v						// housekeeping_spi.v
//------------------------------------------------------	//------------------------------------------------------
// General purpose SPI module for the Caravel chip		// General purpose SPI module for the Caravel chip
//------------------------------------------------------	//------------------------------------------------------
// Written by Tim Edwards					// Written by Tim Edwards
// efabless, inc., September 28, 2020				// efabless, inc., September 28, 2020
//------------------------------------------------		//------------------------------------------------
// This file is distributed free and open source		// This file is distributed free and open source
//------------------------------------------------		//------------------------------------------------

// SCK ---   Clock input					// SCK ---   Clock input
// SDI ---   Data  input					// SDI ---   Data  input
// SDO ---   Data  output					// SDO ---   Data  output
// CSB ---   Chip  select (sense negative)			// CSB ---   Chip  select (sense negative)
// idata --- Data from chip to transmit out, in 8 bits		// idata --- Data from chip to transmit out, in 8 bits
// odata --- Input data to chip, in 8 bits			// odata --- Input data to chip, in 8 bits
// addr  --- Decoded address to upstream circuits		// addr  --- Decoded address to upstream circuits
// rdstb --- Read strobe, tells upstream circuit that data wi	// rdstb --- Read strobe, tells upstream circuit that data wi
// wrstb --- Write strobe, tells upstream circuit to latch od	// wrstb --- Write strobe, tells upstream circuit to latch od

// Data format (general purpose):				// Data format (general purpose):
// 8 bit format							// 8 bit format
// 1st byte:   Command word (see below)				// 1st byte:   Command word (see below)
// 2nd byte:   Address word (register 0 to 255)			// 2nd byte:   Address word (register 0 to 255)
// 3rd byte:   Data word    (value 0 to 255)			// 3rd byte:   Data word    (value 0 to 255)

// Command format:						// Command format:
// 00000000  No operation					// 00000000  No operation
// 10000000  Write until CSB raised				// 10000000  Write until CSB raised
// 01000000  Read  until CSB raised				// 01000000  Read  until CSB raised
// 11000000  Simultaneous read/write until CSB raised		// 11000000  Simultaneous read/write until CSB raised
// 11000100  Pass-through read/write to management area flash	// 11000100  Pass-through read/write to management area flash
// 11000010  Pass-through read/write to user area flash SPI u	// 11000010  Pass-through read/write to user area flash SPI u
// wrnnn000  Read/write as above, for nnn = 1 to 7 bytes, the	// wrnnn000  Read/write as above, for nnn = 1 to 7 bytes, the

// Lower three bits are reserved for future use.		// Lower three bits are reserved for future use.
// All serial bytes are read and written msb first.		// All serial bytes are read and written msb first.

// Fixed control and status registers				// Fixed control and status registers

// Address 0 is reserved and contains flags for SPI mode.  Th	// Address 0 is reserved and contains flags for SPI mode.  Th
// currently undefined and is always value 0.			// currently undefined and is always value 0.
// Address 1 is reserved and contains manufacturer ID low 8 b	// Address 1 is reserved and contains manufacturer ID low 8 b
// Address 2 is reserved and contains manufacturer ID high 4 	// Address 2 is reserved and contains manufacturer ID high 4 
// Address 3 is reserved and contains product ID (8 bits).	// Address 3 is reserved and contains product ID (8 bits).
// Addresses 4 to 7 are reserved and contain the mask ID (32 	// Addresses 4 to 7 are reserved and contain the mask ID (32 
// Addresses 8 to 255 are available for general purpose use.	// Addresses 8 to 255 are available for general purpose use.

`define COMMAND  3'b000						`define COMMAND  3'b000
`define ADDRESS  3'b001						`define ADDRESS  3'b001
`define DATA     3'b010						`define DATA     3'b010
`define USERPASS 3'b100						`define USERPASS 3'b100
`define MGMTPASS 3'b101						`define MGMTPASS 3'b101

module housekeeping_spi(reset, SCK, SDI, CSB, SDO,		module housekeeping_spi(reset, SCK, SDI, CSB, SDO,
	sdoenb, idata, odata, oaddr, rdstb, wrstb,			sdoenb, idata, odata, oaddr, rdstb, wrstb,
	pass_thru_mgmt, pass_thru_mgmt_delay,				pass_thru_mgmt, pass_thru_mgmt_delay,
	pass_thru_user, pass_thru_user_delay,				pass_thru_user, pass_thru_user_delay,
	pass_thru_mgmt_reset, pass_thru_user_reset);			pass_thru_mgmt_reset, pass_thru_user_reset);

    input reset;						    input reset;
    input SCK;							    input SCK;
    input SDI;							    input SDI;
    input CSB;							    input CSB;
    output SDO;							    output SDO;
    output sdoenb;						    output sdoenb;
    input [7:0] idata;						    input [7:0] idata;
    output [7:0] odata;						    output [7:0] odata;
    output [7:0] oaddr;						    output [7:0] oaddr;
    output rdstb;						    output rdstb;
    output wrstb; 						    output wrstb; 
    output pass_thru_mgmt;					    output pass_thru_mgmt;
    output pass_thru_mgmt_delay;				    output pass_thru_mgmt_delay;
    output pass_thru_user;					    output pass_thru_user;
    output pass_thru_user_delay;				    output pass_thru_user_delay;
    output pass_thru_mgmt_reset;				    output pass_thru_mgmt_reset;
    output pass_thru_user_reset;				    output pass_thru_user_reset;

    reg  [7:0]  addr;						    reg  [7:0]  addr;
    reg		wrstb;						    reg		wrstb;
    reg		rdstb;						    reg		rdstb;
    reg		sdoenb;						    reg		sdoenb;
    reg  [2:0]  state;						    reg  [2:0]  state;
    reg  [2:0]  count;						    reg  [2:0]  count;
    reg		writemode;					    reg		writemode;
    reg		readmode;					    reg		readmode;
    reg  [2:0]	fixed;						    reg  [2:0]	fixed;
    wire [7:0]  odata;						    wire [7:0]  odata;
    reg  [6:0]  predata;					    reg  [6:0]  predata;
    wire [7:0]  oaddr;						    wire [7:0]  oaddr;
    reg  [7:0]  ldata;						    reg  [7:0]  ldata;
    reg		pass_thru_mgmt;					    reg		pass_thru_mgmt;
    reg		pass_thru_mgmt_delay;				    reg		pass_thru_mgmt_delay;
    reg		pre_pass_thru_mgmt;				    reg		pre_pass_thru_mgmt;
    reg		pass_thru_user;					    reg		pass_thru_user;
    reg		pass_thru_user_delay;				    reg		pass_thru_user_delay;
    reg		pre_pass_thru_user;				    reg		pre_pass_thru_user;
    wire	csb_reset;					    wire	csb_reset;

    assign odata = {predata, SDI};				    assign odata = {predata, SDI};
    assign oaddr = (state == `ADDRESS) ? {addr[6:0], SDI} : a	    assign oaddr = (state == `ADDRESS) ? {addr[6:0], SDI} : a
    assign SDO = ldata[7];					    assign SDO = ldata[7];
    assign csb_reset = CSB | reset;				    assign csb_reset = CSB | reset;
    assign pass_thru_mgmt_reset = pass_thru_mgmt_delay | pre_	    assign pass_thru_mgmt_reset = pass_thru_mgmt_delay | pre_
    assign pass_thru_user_reset = pass_thru_user_delay | pre_	    assign pass_thru_user_reset = pass_thru_user_delay | pre_

    // Readback data is captured on the falling edge of SCK s	    // Readback data is captured on the falling edge of SCK s
    // it is guaranteed valid at the next rising edge.		    // it is guaranteed valid at the next rising edge.
    always @(negedge SCK or posedge csb_reset) begin		    always @(negedge SCK or posedge csb_reset) begin
        if (csb_reset == 1'b1) begin				        if (csb_reset == 1'b1) begin
            wrstb <= 1'b0;					            wrstb <= 1'b0;
            ldata  <= 8'b00000000;				            ldata  <= 8'b00000000;
            sdoenb <= 1'b1;					            sdoenb <= 1'b1;
        end else begin						        end else begin

            // After CSB low, 1st SCK starts command		            // After CSB low, 1st SCK starts command

            if (state == `DATA) begin				            if (state == `DATA) begin
            	if (readmode == 1'b1) begin			            	if (readmode == 1'b1) begin
                    sdoenb <= 1'b0;				                    sdoenb <= 1'b0;
                    if (count == 3'b000) begin			                    if (count == 3'b000) begin
                	ldata <= idata;				                	ldata <= idata;
                    end else begin				                    end else begin
                	ldata <= {ldata[6:0], 1'b0};	// Sh	                	ldata <= {ldata[6:0], 1'b0};	// Sh
                    end						                    end
                end else begin					                end else begin
                    sdoenb <= 1'b1;				                    sdoenb <= 1'b1;
                end						                end

                // Apply write strobe on SCK negative edge on	                // Apply write strobe on SCK negative edge on
                // data bit so that it updates data on the ri	                // data bit so that it updates data on the ri
                // on the last data bit.			                // on the last data bit.
 								 
                if (count == 3'b111) begin			                if (count == 3'b111) begin
                    if (writemode == 1'b1) begin		                    if (writemode == 1'b1) begin
                        wrstb <= 1'b1;				                        wrstb <= 1'b1;
                    end						                    end
                end else begin					                end else begin
                    wrstb <= 1'b0;				                    wrstb <= 1'b0;
                end						                end

	    end else if (state == `MGMTPASS || state == `USER		    end else if (state == `MGMTPASS || state == `USER
		wrstb <= 1'b0;							wrstb <= 1'b0;
		sdoenb <= 1'b0;							sdoenb <= 1'b0;
            end else begin					            end else begin
                wrstb <= 1'b0;					                wrstb <= 1'b0;
                sdoenb <= 1'b1;					                sdoenb <= 1'b1;
            end		// ! state `DATA			            end		// ! state `DATA
        end		// ! csb_reset				        end		// ! csb_reset
    end			// always @ ~SCK			    end			// always @ ~SCK

    always @(posedge SCK or posedge csb_reset) begin		    always @(posedge SCK or posedge csb_reset) begin
        if (csb_reset == 1'b1) begin				        if (csb_reset == 1'b1) begin
            // Default state on reset				            // Default state on reset
            addr <= 8'h00;					            addr <= 8'h00;
	    rdstb <= 1'b0;						    rdstb <= 1'b0;
            predata <= 7'b0000000;				            predata <= 7'b0000000;
            state  <= `COMMAND;					            state  <= `COMMAND;
            count  <= 3'b000;					            count  <= 3'b000;
            readmode <= 1'b0;					            readmode <= 1'b0;
            writemode <= 1'b0;					            writemode <= 1'b0;
            fixed <= 3'b000;					            fixed <= 3'b000;
	    pass_thru_mgmt <= 1'b0;					    pass_thru_mgmt <= 1'b0;
	    pass_thru_mgmt_delay <= 1'b0;				    pass_thru_mgmt_delay <= 1'b0;
	    pre_pass_thru_mgmt <= 1'b0;					    pre_pass_thru_mgmt <= 1'b0;
	    pass_thru_user <= 1'b0;					    pass_thru_user <= 1'b0;
	    pass_thru_user_delay <= 1'b0;				    pass_thru_user_delay <= 1'b0;
	    pre_pass_thru_user <= 1'b0;					    pre_pass_thru_user <= 1'b0;
        end else begin						        end else begin
            // After csb_reset low, 1st SCK starts command	            // After csb_reset low, 1st SCK starts command
            if (state == `COMMAND) begin			            if (state == `COMMAND) begin
		rdstb <= 1'b0;							rdstb <= 1'b0;
                count <= count + 1;				                count <= count + 1;
        	if (count == 3'b000) begin			        	if (count == 3'b000) begin
	            writemode <= SDI;					            writemode <= SDI;
	        end else if (count == 3'b001) begin			        end else if (count == 3'b001) begin
	            readmode <= SDI;					            readmode <= SDI;
	        end else if (count < 3'b101) begin			        end else if (count < 3'b101) begin
	            fixed <= {fixed[1:0], SDI}; 			            fixed <= {fixed[1:0], SDI}; 
	        end else if (count == 3'b101) begin			        end else if (count == 3'b101) begin
		    pre_pass_thru_mgmt <= SDI;					    pre_pass_thru_mgmt <= SDI;
	        end else if (count == 3'b110) begin			        end else if (count == 3'b110) begin
		    pre_pass_thru_user <= SDI;					    pre_pass_thru_user <= SDI;
		    pass_thru_mgmt_delay <= pre_pass_thru_mgm			    pass_thru_mgmt_delay <= pre_pass_thru_mgm
	        end else if (count == 3'b111) begin			        end else if (count == 3'b111) begin
		    pass_thru_user_delay <= pre_pass_thru_use			    pass_thru_user_delay <= pre_pass_thru_use
		    if (pre_pass_thru_mgmt == 1'b1) begin			    if (pre_pass_thru_mgmt == 1'b1) begin
			state <= `MGMTPASS;						state <= `MGMTPASS;
			pre_pass_thru_mgmt <= 1'b0;					pre_pass_thru_mgmt <= 1'b0;
		    end else if (pre_pass_thru_user == 1'b1) 			    end else if (pre_pass_thru_user == 1'b1) 
			state <= `USERPASS;						state <= `USERPASS;
			pre_pass_thru_user <= 1'b0;					pre_pass_thru_user <= 1'b0;
		    end else begin						    end else begin
	                state <= `ADDRESS;				                state <= `ADDRESS;
		    end								    end
	        end							        end
            end else if (state == `ADDRESS) begin		            end else if (state == `ADDRESS) begin
	        count <= count + 1;					        count <= count + 1;
	        addr <= {addr[6:0], SDI};				        addr <= {addr[6:0], SDI};
	        if (count == 3'b111) begin				        if (count == 3'b111) begin
	            state <= `DATA;					            state <= `DATA;
		    if (readmode == 1'b1) begin					    if (readmode == 1'b1) begin
			rdstb <= 1'b1;							rdstb <= 1'b1;
		    end								    end
	        end else begin						        end else begin
		    rdstb <= 1'b0;						    rdstb <= 1'b0;
		end								end

            end else if (state == `DATA) begin			            end else if (state == `DATA) begin
	        predata <= {predata[6:0], SDI};				        predata <= {predata[6:0], SDI};
	        count <= count + 1;					        count <= count + 1;
	        if (count == 3'b111) begin				        if (count == 3'b111) begin
	            if (fixed == 3'b001) begin				            if (fixed == 3'b001) begin
	                state <= `COMMAND;				                state <= `COMMAND;
	            end else if (fixed != 3'b000) begin			            end else if (fixed != 3'b000) begin
	                fixed <= fixed - 1;				                fixed <= fixed - 1;
	                addr <= addr + 1;	// Auto incre		                addr <= addr + 1;	// Auto incre
	            end else begin					            end else begin	
	                addr <= addr + 1;	// Auto incre		                addr <= addr + 1;	// Auto incre
	            end							            end
		    if (readmode == 1'b1) begin					    if (readmode == 1'b1) begin
			rdstb <= 1'b1;							rdstb <= 1'b1;
		    end								    end
	        end else begin						        end else begin
		    rdstb <= 1'b0;						    rdstb <= 1'b0;
		end								end
	    end else if (state == `MGMTPASS) begin			    end else if (state == `MGMTPASS) begin
		pass_thru_mgmt <= 1'b1;						pass_thru_mgmt <= 1'b1;
	    end else if (state == `USERPASS) begin			    end else if (state == `USERPASS) begin
		pass_thru_user <= 1'b1;						pass_thru_user <= 1'b1;
            end		// ! state `DATA | `MGMTPASS | `USERP	            end		// ! state `DATA | `MGMTPASS | `USERP
        end		// ! csb_reset 				        end		// ! csb_reset 
    end			// always @ SCK				    end			// always @ SCK

endmodule // housekeeping_spi					endmodule // housekeeping_spi
`default_nettype wire						`default_nettype wire
diff -ry rtl/housekeeping.v verilog/rtl/housekeeping.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
							      <

//-----------------------------------------------------------	//-----------------------------------------------------------
// Housekeeping interface for Caravel				// Housekeeping interface for Caravel
//-----------------------------------------------------------	//-----------------------------------------------------------
// Written by Tim Edwards					// Written by Tim Edwards
// efabless, inc. September 27, 2020				// efabless, inc. September 27, 2020
//-----------------------------------------------------------	//-----------------------------------------------------------

//-----------------------------------------------------------	//-----------------------------------------------------------
// This is a standalone slave SPI for the caravel chip that i	// This is a standalone slave SPI for the caravel chip that i
// intended to be independent of the picosoc and independent	// intended to be independent of the picosoc and independent
// of all IP blocks except the power-on-reset.  This SPI has	// of all IP blocks except the power-on-reset.  This SPI has
// register outputs controlling the functions that critically	// register outputs controlling the functions that critically
// affect operation of the picosoc and so cannot be accessed	// affect operation of the picosoc and so cannot be accessed
// from the picosoc itself.  This includes the PLL enables,	// from the picosoc itself.  This includes the PLL enables,
// mode, and trim.  It also has a general reset for the picos	// mode, and trim.  It also has a general reset for the picos
// an IRQ input, a bypass for the entire crystal oscillator	// an IRQ input, a bypass for the entire crystal oscillator
// and PLL chain, the manufacturer and product IDs and produc	// and PLL chain, the manufacturer and product IDs and produc
// revision number.						// revision number.
//								//
// Updated and revised, 10/13/2021:				// Updated and revised, 10/13/2021:
// This module now comprises what was previously split into	// This module now comprises what was previously split into
// the housekeeping SPI, the mprj_ctrl block (control over	// the housekeeping SPI, the mprj_ctrl block (control over
// the GPIO), and sysctrl (redirection of certain internal	// the GPIO), and sysctrl (redirection of certain internal
// signals to the GPIO);  and additionally manages the SPI	// signals to the GPIO);  and additionally manages the SPI
// flash signals and pass-through mode.  Essentially all	// flash signals and pass-through mode.  Essentially all
// aspects of the system related to the use and configuration	// aspects of the system related to the use and configuration
// of the GPIO has been shifted to this module.  This allows	// of the GPIO has been shifted to this module.  This allows
// GPIO to be configured from either the management SoC		// GPIO to be configured from either the management SoC
// through the wishbone interface, or externally through the	// through the wishbone interface, or externally through the
// SPI interface.  It allows essentially any processor to	// SPI interface.  It allows essentially any processor to
// take the place of the PicoRV32 as long as that processor	// take the place of the PicoRV32 as long as that processor
// can access memory-mapped space via the wishbone bus.		// can access memory-mapped space via the wishbone bus.
//-----------------------------------------------------------	//-----------------------------------------------------------

//-----------------------------------------------------------	//-----------------------------------------------------------
// Caravel defined registers (by SPI address):			// Caravel defined registers (by SPI address):
// See:  doc/memory_map.txt					// See:  doc/memory_map.txt
//-----------------------------------------------------------	//-----------------------------------------------------------

module housekeeping #(						module housekeeping #(
    parameter GPIO_BASE_ADR = 32'h2600_0000,			    parameter GPIO_BASE_ADR = 32'h2600_0000,
    parameter SPI_BASE_ADR = 32'h2610_0000,			    parameter SPI_BASE_ADR = 32'h2610_0000,
    parameter SYS_BASE_ADR = 32'h2620_0000,			    parameter SYS_BASE_ADR = 32'h2620_0000,
    parameter IO_CTRL_BITS = 13					    parameter IO_CTRL_BITS = 13
) (								) (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    inout VPWR,							    inout VPWR,
    inout VGND, 						    inout VGND, 
`endif								`endif

    // Wishbone interface to management SoC			    // Wishbone interface to management SoC
    input wb_clk_i,						    input wb_clk_i,
    input wb_rstn_i,						    input wb_rstn_i,
    input [31:0] wb_adr_i,					    input [31:0] wb_adr_i,
    input [31:0] wb_dat_i,					    input [31:0] wb_dat_i,
    input [3:0] wb_sel_i,					    input [3:0] wb_sel_i,
    input wb_we_i,						    input wb_we_i,
    input wb_cyc_i,						    input wb_cyc_i,
    input wb_stb_i,						    input wb_stb_i,
    output reg wb_ack_o,					    output reg wb_ack_o,
    output reg [31:0] wb_dat_o,					    output reg [31:0] wb_dat_o,

    // Primary reset						    // Primary reset
    input porb,							    input porb,

    // Clocking control parameters				    // Clocking control parameters
    output reg pll_ena,						    output reg pll_ena,
    output reg pll_dco_ena,					    output reg pll_dco_ena,
    output reg [4:0] pll_div,					    output reg [4:0] pll_div,
    output reg [2:0] pll_sel,					    output reg [2:0] pll_sel,
    output reg [2:0] pll90_sel,					    output reg [2:0] pll90_sel,
    output reg [25:0] pll_trim,					    output reg [25:0] pll_trim,
    output reg pll_bypass,					    output reg pll_bypass,

    // Module enable status from SoC				    // Module enable status from SoC
    input  qspi_enabled,	// Flash SPI is in quad mode	    input  qspi_enabled,	// Flash SPI is in quad mode
    input  uart_enabled,	// UART is enabled		    input  uart_enabled,	// UART is enabled
    input  spi_enabled,		// SPI master is enabled	    input  spi_enabled,		// SPI master is enabled
    input  debug_mode,		// Debug mode enabled		    input  debug_mode,		// Debug mode enabled

    // UART interface to/from SoC				    // UART interface to/from SoC
    input  ser_tx,						    input  ser_tx,
    output ser_rx,						    output ser_rx,

    // SPI master interface to/from SoC				    // SPI master interface to/from SoC
    output spi_sdi,						    output spi_sdi,
    input  spi_csb,						    input  spi_csb,
    input  spi_sck,						    input  spi_sck,
    input  spi_sdo,						    input  spi_sdo,
    input  spi_sdoenb,						    input  spi_sdoenb,

    // External (originating from SPI and pad) IRQ and reset	    // External (originating from SPI and pad) IRQ and reset
    output [2:0] irq,						    output [2:0] irq,
    output reset,						    output reset,

    // GPIO serial loader programming interface			    // GPIO serial loader programming interface
    output serial_clock,					    output serial_clock,
    output serial_load,						    output serial_load,
    output serial_resetn,					    output serial_resetn,
    output serial_data_1,					    output serial_data_1,
    output serial_data_2,					    output serial_data_2,

    // GPIO data management (to padframe)---three-pin interfa	    // GPIO data management (to padframe)---three-pin interfa
    input  [`MPRJ_IO_PADS-1:0] mgmt_gpio_in,			    input  [`MPRJ_IO_PADS-1:0] mgmt_gpio_in,
    output [`MPRJ_IO_PADS-1:0] mgmt_gpio_out,			    output [`MPRJ_IO_PADS-1:0] mgmt_gpio_out,
    output [`MPRJ_IO_PADS-1:0] mgmt_gpio_oeb,			    output [`MPRJ_IO_PADS-1:0] mgmt_gpio_oeb,

    // Power control output (reserved for future use with LDO	    // Power control output (reserved for future use with LDO
    output reg [`MPRJ_PWR_PADS-1:0] pwr_ctrl_out,		    output reg [`MPRJ_PWR_PADS-1:0] pwr_ctrl_out,

    // CPU trap state status (for system monitoring)		    // CPU trap state status (for system monitoring)
    input trap,							    input trap,

    // User clock (for system monitoring)			    // User clock (for system monitoring)
    input user_clock,						    input user_clock,

    // Mask revision/User project ID				    // Mask revision/User project ID
    input [31:0] mask_rev_in,					    input [31:0] mask_rev_in,

    // SPI flash management (management SoC side)		    // SPI flash management (management SoC side)
    input spimemio_flash_csb,					    input spimemio_flash_csb,
    input spimemio_flash_clk,					    input spimemio_flash_clk,
    input spimemio_flash_io0_oeb,				    input spimemio_flash_io0_oeb,
    input spimemio_flash_io1_oeb,				    input spimemio_flash_io1_oeb,
    input spimemio_flash_io2_oeb,				    input spimemio_flash_io2_oeb,
    input spimemio_flash_io3_oeb,				    input spimemio_flash_io3_oeb,
    input spimemio_flash_io0_do,				    input spimemio_flash_io0_do,
    input spimemio_flash_io1_do,				    input spimemio_flash_io1_do,
    input spimemio_flash_io2_do,				    input spimemio_flash_io2_do,
    input spimemio_flash_io3_do,				    input spimemio_flash_io3_do,
    output spimemio_flash_io0_di,				    output spimemio_flash_io0_di,
    output spimemio_flash_io1_di,				    output spimemio_flash_io1_di,
    output spimemio_flash_io2_di,				    output spimemio_flash_io2_di,
    output spimemio_flash_io3_di,				    output spimemio_flash_io3_di,

    // Debug interface (routes to first GPIO) from management	    // Debug interface (routes to first GPIO) from management
    output debug_in,						    output debug_in,
    input debug_out,						    input debug_out,
    input debug_oeb,						    input debug_oeb,

    // SPI flash management (padframe side)			    // SPI flash management (padframe side)
    // (io2 and io3 are part of GPIO array, not dedicated pad	    // (io2 and io3 are part of GPIO array, not dedicated pad
    output pad_flash_csb,					    output pad_flash_csb,
    output pad_flash_csb_oeb,					    output pad_flash_csb_oeb,
    output pad_flash_clk,					    output pad_flash_clk,
    output pad_flash_clk_oeb,					    output pad_flash_clk_oeb,
    output pad_flash_io0_oeb,					    output pad_flash_io0_oeb,
    output pad_flash_io1_oeb,					    output pad_flash_io1_oeb,
    output pad_flash_io0_ieb,					    output pad_flash_io0_ieb,
    output pad_flash_io1_ieb,					    output pad_flash_io1_ieb,
    output pad_flash_io0_do,					    output pad_flash_io0_do,
    output pad_flash_io1_do,					    output pad_flash_io1_do,
    input pad_flash_io0_di,					    input pad_flash_io0_di,
    input pad_flash_io1_di,					    input pad_flash_io1_di,

`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
    output sram_ro_clk,						    output sram_ro_clk,
    output sram_ro_csb,						    output sram_ro_csb,
    output [7:0] sram_ro_addr,					    output [7:0] sram_ro_addr,
    input [31:0] sram_ro_data,					    input [31:0] sram_ro_data,
`endif								`endif

    // System signal monitoring					    // System signal monitoring
    input  usr1_vcc_pwrgood,					    input  usr1_vcc_pwrgood,
    input  usr2_vcc_pwrgood,					    input  usr2_vcc_pwrgood,
    input  usr1_vdd_pwrgood,					    input  usr1_vdd_pwrgood,
    input  usr2_vdd_pwrgood					    input  usr2_vdd_pwrgood
);								);

    localparam OEB = 1;		// Offset of output enable (b	    localparam OEB = 1;		// Offset of output enable (b
    localparam INP_DIS = 3;	// Offset of input disable in	    localparam INP_DIS = 3;	// Offset of input disable in

    reg reset_reg;						    reg reset_reg;
    reg irq_spi;						    reg irq_spi;
    reg serial_bb_clock;					    reg serial_bb_clock;
    reg serial_bb_load;						    reg serial_bb_load;
    reg serial_bb_resetn;					    reg serial_bb_resetn;
    reg serial_bb_data_1;					    reg serial_bb_data_1;
    reg serial_bb_data_2;					    reg serial_bb_data_2;
    reg serial_bb_enable;					    reg serial_bb_enable;
    reg serial_xfer;						    reg serial_xfer;
    reg hkspi_disable;						    reg hkspi_disable;

`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
    reg sram_ro_clk;						    reg sram_ro_clk;
    reg sram_ro_csb;						    reg sram_ro_csb;
    reg [7:0] sram_ro_addr;					    reg [7:0] sram_ro_addr;
`endif								`endif

    reg clk1_output_dest;					    reg clk1_output_dest;
    reg clk2_output_dest;					    reg clk2_output_dest;
    reg trap_output_dest;					    reg trap_output_dest;
    reg irq_1_inputsrc;						    reg irq_1_inputsrc;
    reg irq_2_inputsrc;						    reg irq_2_inputsrc;

    reg [IO_CTRL_BITS-1:0] gpio_configure [`MPRJ_IO_PADS-1:0]	    reg [IO_CTRL_BITS-1:0] gpio_configure [`MPRJ_IO_PADS-1:0]
    reg [`MPRJ_IO_PADS-1:0] mgmt_gpio_data;			    reg [`MPRJ_IO_PADS-1:0] mgmt_gpio_data;

    /* mgmt_gpio_data_buf holds the lower bits during a back-	    /* mgmt_gpio_data_buf holds the lower bits during a back-
     * write to GPIO data so that all 32 bits can update at o	     * write to GPIO data so that all 32 bits can update at o
     */								     */
    reg [23:0] mgmt_gpio_data_buf;				    reg [23:0] mgmt_gpio_data_buf;


    wire [7:0] odata;						    wire [7:0] odata;
    wire [7:0] idata;						    wire [7:0] idata;
    wire [7:0] iaddr;						    wire [7:0] iaddr;

    wire rdstb;							    wire rdstb;
    wire wrstb;							    wire wrstb;
    wire pass_thru_mgmt;		// Mode detected by h	    wire pass_thru_mgmt;		// Mode detected by h
    wire pass_thru_mgmt_delay;					    wire pass_thru_mgmt_delay;
    wire pass_thru_user;		// Mode detected by h	    wire pass_thru_user;		// Mode detected by h
    wire pass_thru_user_delay;					    wire pass_thru_user_delay;
    wire pass_thru_mgmt_reset;					    wire pass_thru_mgmt_reset;
    wire pass_thru_user_reset;					    wire pass_thru_user_reset;
    wire sdo;							    wire sdo;
    wire sdo_enb;						    wire sdo_enb;

    wire [7:0]	caddr;	// Combination of SPI address and bac	    wire [7:0]	caddr;	// Combination of SPI address and bac
    wire [7:0]	cdata;	// Combination of SPI data and back d	    wire [7:0]	cdata;	// Combination of SPI data and back d
    wire	cwstb;	// Combination of SPI write strobe an	    wire	cwstb;	// Combination of SPI write strobe an
    wire	csclk;	// Combination of SPI SCK and back do	    wire	csclk;	// Combination of SPI SCK and back do


// Output clock signals buffer wires				// Output clock signals buffer wires
wire mgmt_gpio_out_9_prebuff, mgmt_gpio_out_14_prebuff, mgmt_	wire mgmt_gpio_out_9_prebuff, mgmt_gpio_out_14_prebuff, mgmt_


`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
    wire [31:0] sram_ro_data;					    wire [31:0] sram_ro_data;
`endif								`endif

    // Pass-through mode handling.  Signals may only be appli	    // Pass-through mode handling.  Signals may only be appli
    // core processor is in reset.				    // core processor is in reset.

    assign reset = (pass_thru_mgmt_reset) ? 1'b1 : reset_reg;	    assign reset = (pass_thru_mgmt_reset) ? 1'b1 : reset_reg;

	// Invert wb_rstn_i						// Invert wb_rstn_i
	wire wb_rst_i;							wire wb_rst_i;
	assign wb_rst_i = ~wb_rstn_i;					assign wb_rst_i = ~wb_rstn_i;
									
    // Pass-through mode.  Housekeeping SPI signals get inser	    // Pass-through mode.  Housekeeping SPI signals get inser
    // between the management SoC and the flash SPI I/O.	    // between the management SoC and the flash SPI I/O.

    assign pad_flash_csb = (pass_thru_mgmt_delay) ? mgmt_gpio	    assign pad_flash_csb = (pass_thru_mgmt_delay) ? mgmt_gpio
    assign pad_flash_csb_oeb = (pass_thru_mgmt_delay) ? 1'b0 	    assign pad_flash_csb_oeb = (pass_thru_mgmt_delay) ? 1'b0 
    assign pad_flash_clk_prebuff = (pass_thru_mgmt) ? mgmt_gp	    assign pad_flash_clk_prebuff = (pass_thru_mgmt) ? mgmt_gp
    assign pad_flash_clk_oeb = (pass_thru_mgmt) ? 1'b0 : (~po	    assign pad_flash_clk_oeb = (pass_thru_mgmt) ? 1'b0 : (~po
    assign pad_flash_io0_oeb = (pass_thru_mgmt_delay) ? 1'b0 	    assign pad_flash_io0_oeb = (pass_thru_mgmt_delay) ? 1'b0 
    assign pad_flash_io1_oeb = (pass_thru_mgmt) ? 1'b1 : spim	    assign pad_flash_io1_oeb = (pass_thru_mgmt) ? 1'b1 : spim
    assign pad_flash_io0_ieb = (pass_thru_mgmt_delay) ? 1'b1 	    assign pad_flash_io0_ieb = (pass_thru_mgmt_delay) ? 1'b1 
    assign pad_flash_io1_ieb = (pass_thru_mgmt) ? 1'b0 : ~spi	    assign pad_flash_io1_ieb = (pass_thru_mgmt) ? 1'b0 : ~spi
    assign pad_flash_io0_do = (pass_thru_mgmt_delay) ? mgmt_g	    assign pad_flash_io0_do = (pass_thru_mgmt_delay) ? mgmt_g
    assign pad_flash_io1_do = spimemio_flash_io1_do;		    assign pad_flash_io1_do = spimemio_flash_io1_do;
    assign spimemio_flash_io0_di = (pass_thru_mgmt_delay) ? 1	    assign spimemio_flash_io0_di = (pass_thru_mgmt_delay) ? 1
    assign spimemio_flash_io1_di = (pass_thru_mgmt) ? 1'b0 : 	    assign spimemio_flash_io1_di = (pass_thru_mgmt) ? 1'b0 : 

(* keep *) bufbd7 pad_flashh_clk_buff_inst (		      |	(* keep *) sky130_fd_sc_hd__clkbuf_8 pad_flashh_clk_buff_inst
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
        .VPWR(VPWR),						        .VPWR(VPWR),
        .VGND(VGND),						        .VGND(VGND),
        .VPB(VPWR),						        .VPB(VPWR),
        .VNB(VGND),						        .VNB(VGND),
`endif								`endif
	.I(pad_flash_clk_prebuff),			      |		.A(pad_flash_clk_prebuff),
    .Z(pad_flash_clk));					      |	    .X(pad_flash_clk));

    wire [11:0] mfgr_id;					    wire [11:0] mfgr_id;
    wire [7:0]  prod_id;					    wire [7:0]  prod_id;
    wire [31:0] mask_rev;					    wire [31:0] mask_rev;

    reg serial_busy;						    reg serial_busy;

    // Wishbone bus "back door" to SPI registers.  This secti	    // Wishbone bus "back door" to SPI registers.  This secti
    // (1) Maps SPI byte addresses to memory map 32-bit addre	    // (1) Maps SPI byte addresses to memory map 32-bit addre
    // (2) Applies signals to the housekeeping SPI to mux in 	    // (2) Applies signals to the housekeeping SPI to mux in 
    //	   clock, and write strobe.  This is done carefully a	    //	   clock, and write strobe.  This is done carefully a
    //	   avoid glitching on the SCK line and to avoid forci	    //	   avoid glitching on the SCK line and to avoid forci
    //	   housekeeping module to keep up with the core clock	    //	   housekeeping module to keep up with the core clock

    wire      	sys_select;	// System monitoring memory m	    wire      	sys_select;	// System monitoring memory m
    wire      	gpio_select;	// GPIO configuration memory 	    wire      	gpio_select;	// GPIO configuration memory 
    wire      	spi_select;	// SPI back door memory map a	    wire      	spi_select;	// SPI back door memory map a

    // Wishbone Back Door.  This is a simple interface making	    // Wishbone Back Door.  This is a simple interface making
    // housekeeping SPI protocol.  The housekeeping SPI uses 	    // housekeeping SPI protocol.  The housekeeping SPI uses 
    // data, so this interface will stall the processor by ho	    // data, so this interface will stall the processor by ho
    // low until all bytes have been transferred between the 	    // low until all bytes have been transferred between the 
    // housekeeping SPI.					    // housekeeping SPI.

    reg [3:0] 	wbbd_state;					    reg [3:0] 	wbbd_state;
    reg [7:0] 	wbbd_addr;	/* SPI address translated fro	    reg [7:0] 	wbbd_addr;	/* SPI address translated fro
    reg [7:0] 	wbbd_data;	/* SPI data translated from W	    reg [7:0] 	wbbd_data;	/* SPI data translated from W
    reg  	wbbd_sck;	/* wishbone access trigger (b	    reg  	wbbd_sck;	/* wishbone access trigger (b
    reg  	wbbd_write;	/* wishbone write trigger (ba	    reg  	wbbd_write;	/* wishbone write trigger (ba
    reg		wbbd_busy;	/* Raised during a wishbone r	    reg		wbbd_busy;	/* Raised during a wishbone r

    // This defines a state machine that accesses the SPI reg	    // This defines a state machine that accesses the SPI reg
    // the back door wishbone interface.  The process is rela	    // the back door wishbone interface.  The process is rela
    // since the SPI data are byte-wide, so four individual a	    // since the SPI data are byte-wide, so four individual a
    // made to read 4 bytes from the SPI to fill data on the 	    // made to read 4 bytes from the SPI to fill data on the 
    // before sending ACK and letting the processor continue.	    // before sending ACK and letting the processor continue.

    `define WBBD_IDLE	4'h0	/* Back door access is idle *	    `define WBBD_IDLE	4'h0	/* Back door access is idle *
    `define WBBD_SETUP0	4'h1	/* Apply address and data for	    `define WBBD_SETUP0	4'h1	/* Apply address and data for
    `define WBBD_RW0	4'h2	/* Latch data for byte 1 of 4	    `define WBBD_RW0	4'h2	/* Latch data for byte 1 of 4
    `define WBBD_SETUP1	4'h3	/* Apply address and data for	    `define WBBD_SETUP1	4'h3	/* Apply address and data for
    `define WBBD_RW1	4'h4	/* Latch data for byte 2 of 4	    `define WBBD_RW1	4'h4	/* Latch data for byte 2 of 4
    `define WBBD_SETUP2	4'h5	/* Apply address and data for	    `define WBBD_SETUP2	4'h5	/* Apply address and data for
    `define WBBD_RW2	4'h6	/* Latch data for byte 3 of 4	    `define WBBD_RW2	4'h6	/* Latch data for byte 3 of 4
    `define WBBD_SETUP3	4'h7	/* Apply address and data for	    `define WBBD_SETUP3	4'h7	/* Apply address and data for
    `define WBBD_RW3	4'h8	/* Latch data for byte 4 of 4	    `define WBBD_RW3	4'h8	/* Latch data for byte 4 of 4
    `define WBBD_DONE	4'h9	/* Send ACK back to wishbone 	    `define WBBD_DONE	4'h9	/* Send ACK back to wishbone 
    `define WBBD_RESET	4'ha	/* Clock once to reset the tr	    `define WBBD_RESET	4'ha	/* Clock once to reset the tr

    assign sys_select = (wb_adr_i[31:8] == SYS_BASE_ADR[31:8]	    assign sys_select = (wb_adr_i[31:8] == SYS_BASE_ADR[31:8]
    assign gpio_select = (wb_adr_i[31:8] == GPIO_BASE_ADR[31:	    assign gpio_select = (wb_adr_i[31:8] == GPIO_BASE_ADR[31:
    assign spi_select = (wb_adr_i[31:8] == SPI_BASE_ADR[31:8]	    assign spi_select = (wb_adr_i[31:8] == SPI_BASE_ADR[31:8]

    /* Register bit to SPI address mapping */			    /* Register bit to SPI address mapping */

    function [7:0] fdata(input [7:0] address);			    function [7:0] fdata(input [7:0] address);
	begin								begin
	case (address)							case (address)
	    /* Housekeeping SPI Protocol */				    /* Housekeeping SPI Protocol */
	    8'h00 : fdata = 8'h00;			// SP		    8'h00 : fdata = 8'h00;			// SP

	    /* Status and Identification */				    /* Status and Identification */
	    8'h01 : fdata = {4'h0, mfgr_id[11:8]};	// Ma		    8'h01 : fdata = {4'h0, mfgr_id[11:8]};	// Ma
	    8'h02 : fdata = mfgr_id[7:0];		// Ma		    8'h02 : fdata = mfgr_id[7:0];		// Ma
	    8'h03 : fdata = prod_id;			// Pr		    8'h03 : fdata = prod_id;			// Pr
	    8'h04 : fdata = mask_rev[31:24];		// Ma		    8'h04 : fdata = mask_rev[31:24];		// Ma
	    8'h05 : fdata = mask_rev[23:16];		// Ma		    8'h05 : fdata = mask_rev[23:16];		// Ma
	    8'h06 : fdata = mask_rev[15:8];		// Ma		    8'h06 : fdata = mask_rev[15:8];		// Ma
	    8'h07 : fdata = mask_rev[7:0];		// Ma		    8'h07 : fdata = mask_rev[7:0];		// Ma

	    /* Clocking control */					    /* Clocking control */
	    8'h08 : fdata = {6'b000000, pll_dco_ena, pll_ena}		    8'h08 : fdata = {6'b000000, pll_dco_ena, pll_ena}
	    8'h09 : fdata = {7'b0000000, pll_bypass};			    8'h09 : fdata = {7'b0000000, pll_bypass};
	    8'h0a : fdata = {7'b0000000, irq_spi};			    8'h0a : fdata = {7'b0000000, irq_spi};
	    8'h0b : fdata = {7'b0000000, reset};			    8'h0b : fdata = {7'b0000000, reset};
	    8'h0c : fdata = {7'b0000000, trap};		// CP		    8'h0c : fdata = {7'b0000000, trap};		// CP
	    8'h0d : fdata = pll_trim[7:0];				    8'h0d : fdata = pll_trim[7:0];
	    8'h0e : fdata = pll_trim[15:8];				    8'h0e : fdata = pll_trim[15:8];
	    8'h0f : fdata = pll_trim[23:16];				    8'h0f : fdata = pll_trim[23:16];
	    8'h10 : fdata = {6'b000000, pll_trim[25:24]};		    8'h10 : fdata = {6'b000000, pll_trim[25:24]};
	    8'h11 : fdata = {2'b00, pll90_sel, pll_sel};		    8'h11 : fdata = {2'b00, pll90_sel, pll_sel};
	    8'h12 : fdata = {3'b000, pll_div};				    8'h12 : fdata = {3'b000, pll_div};

	    // GPIO Control (bit bang and automatic)			    // GPIO Control (bit bang and automatic)
	    // NOTE: "serial_busy" is the read-back signal oc		    // NOTE: "serial_busy" is the read-back signal oc
	    // address/bit as "serial_xfer".				    // address/bit as "serial_xfer".
	    8'h13 : fdata = {1'b0, serial_data_2, serial_data		    8'h13 : fdata = {1'b0, serial_data_2, serial_data
				serial_bb_load, serial_bb_res					serial_bb_load, serial_bb_res
				serial_busy};							serial_busy};

`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
	    /* Optional:  SRAM read-only port (registers 14 t		    /* Optional:  SRAM read-only port (registers 14 t
	    8'h14 : fdata = {6'b000000, sram_ro_clk, sram_ro_		    8'h14 : fdata = {6'b000000, sram_ro_clk, sram_ro_
	    8'h15 : fdata = sram_ro_addr;				    8'h15 : fdata = sram_ro_addr;
	    8'h16 : fdata = sram_ro_data[31:24];			    8'h16 : fdata = sram_ro_data[31:24];
	    8'h17 : fdata = sram_ro_data[23:16];			    8'h17 : fdata = sram_ro_data[23:16];
	    8'h18 : fdata = sram_ro_data[15:8];				    8'h18 : fdata = sram_ro_data[15:8];
	    8'h19 : fdata = sram_ro_data[7:0];				    8'h19 : fdata = sram_ro_data[7:0];
`endif								`endif

	    /* System monitoring */					    /* System monitoring */
	    8'h1a : fdata = {4'b0000, usr1_vcc_pwrgood, usr2_		    8'h1a : fdata = {4'b0000, usr1_vcc_pwrgood, usr2_
				usr1_vdd_pwrgood, usr2_vdd_pw					usr1_vdd_pwrgood, usr2_vdd_pw
	    8'h1b : fdata = {5'b00000, clk1_output_dest, clk2		    8'h1b : fdata = {5'b00000, clk1_output_dest, clk2
				trap_output_dest};						trap_output_dest};
	    8'h1c : fdata = {6'b000000, irq_2_inputsrc, irq_1		    8'h1c : fdata = {6'b000000, irq_2_inputsrc, irq_1

	    /* GPIO Configuration */					    /* GPIO Configuration */
	    8'h1d : fdata = {3'b000, gpio_configure[0][12:8]}		    8'h1d : fdata = {3'b000, gpio_configure[0][12:8]}
	    8'h1e : fdata = gpio_configure[0][7:0];			    8'h1e : fdata = gpio_configure[0][7:0];
	    8'h1f : fdata = {3'b000, gpio_configure[1][12:8]}		    8'h1f : fdata = {3'b000, gpio_configure[1][12:8]}
	    8'h20 : fdata = gpio_configure[1][7:0];			    8'h20 : fdata = gpio_configure[1][7:0];
	    8'h21 : fdata = {3'b000, gpio_configure[2][12:8]}		    8'h21 : fdata = {3'b000, gpio_configure[2][12:8]}
	    8'h22 : fdata = gpio_configure[2][7:0];			    8'h22 : fdata = gpio_configure[2][7:0];
	    8'h23 : fdata = {3'b000, gpio_configure[3][12:8]}		    8'h23 : fdata = {3'b000, gpio_configure[3][12:8]}
	    8'h24 : fdata = gpio_configure[3][7:0];			    8'h24 : fdata = gpio_configure[3][7:0];
	    8'h25 : fdata = {3'b000, gpio_configure[4][12:8]}		    8'h25 : fdata = {3'b000, gpio_configure[4][12:8]}
	    8'h26 : fdata = gpio_configure[4][7:0];			    8'h26 : fdata = gpio_configure[4][7:0];
	    8'h27 : fdata = {3'b000, gpio_configure[5][12:8]}		    8'h27 : fdata = {3'b000, gpio_configure[5][12:8]}
	    8'h28 : fdata = gpio_configure[5][7:0];			    8'h28 : fdata = gpio_configure[5][7:0];
	    8'h29 : fdata = {3'b000, gpio_configure[6][12:8]}		    8'h29 : fdata = {3'b000, gpio_configure[6][12:8]}
	    8'h2a : fdata = gpio_configure[6][7:0];			    8'h2a : fdata = gpio_configure[6][7:0];
	    8'h2b : fdata = {3'b000, gpio_configure[7][12:8]}		    8'h2b : fdata = {3'b000, gpio_configure[7][12:8]}
	    8'h2c : fdata = gpio_configure[7][7:0];			    8'h2c : fdata = gpio_configure[7][7:0];
	    8'h2d : fdata = {3'b000, gpio_configure[8][12:8]}		    8'h2d : fdata = {3'b000, gpio_configure[8][12:8]}
	    8'h2e : fdata = gpio_configure[8][7:0];			    8'h2e : fdata = gpio_configure[8][7:0];
	    8'h2f : fdata = {3'b000, gpio_configure[9][12:8]}		    8'h2f : fdata = {3'b000, gpio_configure[9][12:8]}
	    8'h30 : fdata = gpio_configure[9][7:0];			    8'h30 : fdata = gpio_configure[9][7:0];
	    8'h31 : fdata = {3'b000, gpio_configure[10][12:8]		    8'h31 : fdata = {3'b000, gpio_configure[10][12:8]
	    8'h32 : fdata = gpio_configure[10][7:0];			    8'h32 : fdata = gpio_configure[10][7:0];
	    8'h33 : fdata = {3'b000, gpio_configure[11][12:8]		    8'h33 : fdata = {3'b000, gpio_configure[11][12:8]
	    8'h34 : fdata = gpio_configure[11][7:0];			    8'h34 : fdata = gpio_configure[11][7:0];
	    8'h35 : fdata = {3'b000, gpio_configure[12][12:8]		    8'h35 : fdata = {3'b000, gpio_configure[12][12:8]
	    8'h36 : fdata = gpio_configure[12][7:0];			    8'h36 : fdata = gpio_configure[12][7:0];
	    8'h37 : fdata = {3'b000, gpio_configure[13][12:8]		    8'h37 : fdata = {3'b000, gpio_configure[13][12:8]
	    8'h38 : fdata = gpio_configure[13][7:0];			    8'h38 : fdata = gpio_configure[13][7:0];
	    8'h39 : fdata = {3'b000, gpio_configure[14][12:8]		    8'h39 : fdata = {3'b000, gpio_configure[14][12:8]
	    8'h3a : fdata = gpio_configure[14][7:0];			    8'h3a : fdata = gpio_configure[14][7:0];
	    8'h3b : fdata = {3'b000, gpio_configure[15][12:8]		    8'h3b : fdata = {3'b000, gpio_configure[15][12:8]
	    8'h3c : fdata = gpio_configure[15][7:0];			    8'h3c : fdata = gpio_configure[15][7:0];
	    8'h3d : fdata = {3'b000, gpio_configure[16][12:8]		    8'h3d : fdata = {3'b000, gpio_configure[16][12:8]
	    8'h3e : fdata = gpio_configure[16][7:0];			    8'h3e : fdata = gpio_configure[16][7:0];
	    8'h3f : fdata = {3'b000, gpio_configure[17][12:8]		    8'h3f : fdata = {3'b000, gpio_configure[17][12:8]
	    8'h40 : fdata = gpio_configure[17][7:0];			    8'h40 : fdata = gpio_configure[17][7:0];
	    8'h41 : fdata = {3'b000, gpio_configure[18][12:8]		    8'h41 : fdata = {3'b000, gpio_configure[18][12:8]
	    8'h42 : fdata = gpio_configure[18][7:0];			    8'h42 : fdata = gpio_configure[18][7:0];
	    8'h43 : fdata = {3'b000, gpio_configure[19][12:8]		    8'h43 : fdata = {3'b000, gpio_configure[19][12:8]
	    8'h44 : fdata = gpio_configure[19][7:0];			    8'h44 : fdata = gpio_configure[19][7:0];
	    8'h45 : fdata = {3'b000, gpio_configure[20][12:8]		    8'h45 : fdata = {3'b000, gpio_configure[20][12:8]
	    8'h46 : fdata = gpio_configure[20][7:0];			    8'h46 : fdata = gpio_configure[20][7:0];
	    8'h47 : fdata = {3'b000, gpio_configure[21][12:8]		    8'h47 : fdata = {3'b000, gpio_configure[21][12:8]
	    8'h48 : fdata = gpio_configure[21][7:0];			    8'h48 : fdata = gpio_configure[21][7:0];
	    8'h49 : fdata = {3'b000, gpio_configure[22][12:8]		    8'h49 : fdata = {3'b000, gpio_configure[22][12:8]
	    8'h4a : fdata = gpio_configure[22][7:0];			    8'h4a : fdata = gpio_configure[22][7:0];
	    8'h4b : fdata = {3'b000, gpio_configure[23][12:8]		    8'h4b : fdata = {3'b000, gpio_configure[23][12:8]
	    8'h4c : fdata = gpio_configure[23][7:0];			    8'h4c : fdata = gpio_configure[23][7:0];
	    8'h4d : fdata = {3'b000, gpio_configure[24][12:8]		    8'h4d : fdata = {3'b000, gpio_configure[24][12:8]
	    8'h4e : fdata = gpio_configure[24][7:0];			    8'h4e : fdata = gpio_configure[24][7:0];
	    8'h4f : fdata = {3'b000, gpio_configure[25][12:8]		    8'h4f : fdata = {3'b000, gpio_configure[25][12:8]
	    8'h50 : fdata = gpio_configure[25][7:0];			    8'h50 : fdata = gpio_configure[25][7:0];
	    8'h51 : fdata = {3'b000, gpio_configure[26][12:8]		    8'h51 : fdata = {3'b000, gpio_configure[26][12:8]
	    8'h52 : fdata = gpio_configure[26][7:0];			    8'h52 : fdata = gpio_configure[26][7:0];
	    8'h53 : fdata = {3'b000, gpio_configure[27][12:8]		    8'h53 : fdata = {3'b000, gpio_configure[27][12:8]
	    8'h54 : fdata = gpio_configure[27][7:0];			    8'h54 : fdata = gpio_configure[27][7:0];
	    8'h55 : fdata = {3'b000, gpio_configure[28][12:8]		    8'h55 : fdata = {3'b000, gpio_configure[28][12:8]
	    8'h56 : fdata = gpio_configure[28][7:0];			    8'h56 : fdata = gpio_configure[28][7:0];
	    8'h57 : fdata = {3'b000, gpio_configure[29][12:8]		    8'h57 : fdata = {3'b000, gpio_configure[29][12:8]
	    8'h58 : fdata = gpio_configure[29][7:0];			    8'h58 : fdata = gpio_configure[29][7:0];
	    8'h59 : fdata = {3'b000, gpio_configure[30][12:8]		    8'h59 : fdata = {3'b000, gpio_configure[30][12:8]
	    8'h5a : fdata = gpio_configure[30][7:0];			    8'h5a : fdata = gpio_configure[30][7:0];
	    8'h5b : fdata = {3'b000, gpio_configure[31][12:8]		    8'h5b : fdata = {3'b000, gpio_configure[31][12:8]
	    8'h5c : fdata = gpio_configure[31][7:0];			    8'h5c : fdata = gpio_configure[31][7:0];
	    8'h5d : fdata = {3'b000, gpio_configure[32][12:8]		    8'h5d : fdata = {3'b000, gpio_configure[32][12:8]
	    8'h5e : fdata = gpio_configure[32][7:0];			    8'h5e : fdata = gpio_configure[32][7:0];
	    8'h5f : fdata = {3'b000, gpio_configure[33][12:8]		    8'h5f : fdata = {3'b000, gpio_configure[33][12:8]
	    8'h60 : fdata = gpio_configure[33][7:0];			    8'h60 : fdata = gpio_configure[33][7:0];
	    8'h61 : fdata = {3'b000, gpio_configure[34][12:8]		    8'h61 : fdata = {3'b000, gpio_configure[34][12:8]
	    8'h62 : fdata = gpio_configure[34][7:0];			    8'h62 : fdata = gpio_configure[34][7:0];
	    8'h63 : fdata = {3'b000, gpio_configure[35][12:8]		    8'h63 : fdata = {3'b000, gpio_configure[35][12:8]
	    8'h64 : fdata = gpio_configure[35][7:0];			    8'h64 : fdata = gpio_configure[35][7:0];
	    8'h65 : fdata = {3'b000, gpio_configure[36][12:8]		    8'h65 : fdata = {3'b000, gpio_configure[36][12:8]
	    8'h66 : fdata = gpio_configure[36][7:0];			    8'h66 : fdata = gpio_configure[36][7:0];
	    8'h67 : fdata = {3'b000, gpio_configure[37][12:8]		    8'h67 : fdata = {3'b000, gpio_configure[37][12:8]
	    8'h68 : fdata = gpio_configure[37][7:0];			    8'h68 : fdata = gpio_configure[37][7:0];

	    // GPIO Data						    // GPIO Data
	    8'h69 : fdata = {2'b00, mgmt_gpio_in[`MPRJ_IO_PAD		    8'h69 : fdata = {2'b00, mgmt_gpio_in[`MPRJ_IO_PAD
	    8'h6a : fdata = mgmt_gpio_in[31:24];			    8'h6a : fdata = mgmt_gpio_in[31:24];
	    8'h6b : fdata = mgmt_gpio_in[23:16];			    8'h6b : fdata = mgmt_gpio_in[23:16];
	    8'h6c : fdata = mgmt_gpio_in[15:8];				    8'h6c : fdata = mgmt_gpio_in[15:8];
	    8'h6d : fdata = mgmt_gpio_in[7:0];				    8'h6d : fdata = mgmt_gpio_in[7:0];

	    // Power Control (reserved)					    // Power Control (reserved)
	    8'h6e : fdata = {4'b0000, pwr_ctrl_out};			    8'h6e : fdata = {4'b0000, pwr_ctrl_out};

	    // Housekeeping SPI system disable				    // Housekeeping SPI system disable
	    8'h6f : fdata = {7'b0000000, hkspi_disable};		    8'h6f : fdata = {7'b0000000, hkspi_disable};

	    default: fdata = 8'h00;					    default: fdata = 8'h00;
	endcase								endcase
	end								end
    endfunction							    endfunction

    /* Memory map address to SPI address translation for back	    /* Memory map address to SPI address translation for back
    /* (see doc/memory_map.txt)					    /* (see doc/memory_map.txt)				

    wire [11:0] gpio_adr = GPIO_BASE_ADR[23:12];		    wire [11:0] gpio_adr = GPIO_BASE_ADR[23:12];
    wire [11:0] sys_adr = SYS_BASE_ADR[23:12];			    wire [11:0] sys_adr = SYS_BASE_ADR[23:12];
    wire [11:0] spi_adr = SPI_BASE_ADR[23:12];			    wire [11:0] spi_adr = SPI_BASE_ADR[23:12];

    function [7:0] spiaddr(input [31:0] wbaddress);		    function [7:0] spiaddr(input [31:0] wbaddress);
	begin								begin
	/* Address taken from lower 8 bits and upper 4 bits o		/* Address taken from lower 8 bits and upper 4 bits o
	/* wishbone address.						/* wishbone address.				
	case ({wbaddress[23:20], wbaddress[7:0]})			case ({wbaddress[23:20], wbaddress[7:0]})
	    spi_adr  | 12'h000 : spiaddr = 8'h00;	// SP		    spi_adr  | 12'h000 : spiaddr = 8'h00;	// SP
	    spi_adr  | 12'h004 : spiaddr = 8'h03;	// pr		    spi_adr  | 12'h004 : spiaddr = 8'h03;	// pr
	    spi_adr  | 12'h005 : spiaddr = 8'h02;	// Ma		    spi_adr  | 12'h005 : spiaddr = 8'h02;	// Ma
	    spi_adr  | 12'h006 : spiaddr = 8'h01;	// Ma		    spi_adr  | 12'h006 : spiaddr = 8'h01;	// Ma
	    spi_adr  | 12'h008 : spiaddr = 8'h07;	// Us		    spi_adr  | 12'h008 : spiaddr = 8'h07;	// Us
	    spi_adr  | 12'h009 : spiaddr = 8'h06;	// Us		    spi_adr  | 12'h009 : spiaddr = 8'h06;	// Us
	    spi_adr  | 12'h00a : spiaddr = 8'h05;	// Us		    spi_adr  | 12'h00a : spiaddr = 8'h05;	// Us
	    spi_adr  | 12'h00b : spiaddr = 8'h04;	// Us		    spi_adr  | 12'h00b : spiaddr = 8'h04;	// Us

	    spi_adr  | 12'h00c : spiaddr = 8'h08;	// PL		    spi_adr  | 12'h00c : spiaddr = 8'h08;	// PL
	    spi_adr  | 12'h010 : spiaddr = 8'h09;	// PL		    spi_adr  | 12'h010 : spiaddr = 8'h09;	// PL
	    spi_adr  | 12'h014 : spiaddr = 8'h0a;	// IR		    spi_adr  | 12'h014 : spiaddr = 8'h0a;	// IR
	    spi_adr  | 12'h018 : spiaddr = 8'h0b;	// Re		    spi_adr  | 12'h018 : spiaddr = 8'h0b;	// Re
	    spi_adr  | 12'h028 : spiaddr = 8'h0c;	// CP		    spi_adr  | 12'h028 : spiaddr = 8'h0c;	// CP
	    spi_adr  | 12'h01f : spiaddr = 8'h10;	// PL		    spi_adr  | 12'h01f : spiaddr = 8'h10;	// PL
	    spi_adr  | 12'h01e : spiaddr = 8'h0f;	// PL		    spi_adr  | 12'h01e : spiaddr = 8'h0f;	// PL
	    spi_adr  | 12'h01d : spiaddr = 8'h0e;	// PL		    spi_adr  | 12'h01d : spiaddr = 8'h0e;	// PL
	    spi_adr  | 12'h01c : spiaddr = 8'h0d;	// PL		    spi_adr  | 12'h01c : spiaddr = 8'h0d;	// PL
	    spi_adr  | 12'h020 : spiaddr = 8'h11;	// PL		    spi_adr  | 12'h020 : spiaddr = 8'h11;	// PL
	    spi_adr  | 12'h024 : spiaddr = 8'h12;	// PL		    spi_adr  | 12'h024 : spiaddr = 8'h12;	// PL

	    spi_adr  | 12'h02c : spiaddr = 8'h19;	// SR		    spi_adr  | 12'h02c : spiaddr = 8'h19;	// SR
	    spi_adr  | 12'h02d : spiaddr = 8'h18;	// SR		    spi_adr  | 12'h02d : spiaddr = 8'h18;	// SR
	    spi_adr  | 12'h02e : spiaddr = 8'h17;	// SR		    spi_adr  | 12'h02e : spiaddr = 8'h17;	// SR
	    spi_adr  | 12'h02f : spiaddr = 8'h16;	// SR		    spi_adr  | 12'h02f : spiaddr = 8'h16;	// SR
	    spi_adr  | 12'h030 : spiaddr = 8'h15;	// SR		    spi_adr  | 12'h030 : spiaddr = 8'h15;	// SR
	    spi_adr  | 12'h034 : spiaddr = 8'h14;	// SR		    spi_adr  | 12'h034 : spiaddr = 8'h14;	// SR

	    gpio_adr | 12'h000 : spiaddr = 8'h13;	// GP		    gpio_adr | 12'h000 : spiaddr = 8'h13;	// GP

	    sys_adr  | 12'h000 : spiaddr = 8'h1a;	// Po		    sys_adr  | 12'h000 : spiaddr = 8'h1a;	// Po
	    sys_adr  | 12'h004 : spiaddr = 8'h1b;	// Ou		    sys_adr  | 12'h004 : spiaddr = 8'h1b;	// Ou
	    sys_adr  | 12'h00c : spiaddr = 8'h1c;	// In		    sys_adr  | 12'h00c : spiaddr = 8'h1c;	// In

	    gpio_adr | 12'h025 : spiaddr = 8'h1d;	// GP		    gpio_adr | 12'h025 : spiaddr = 8'h1d;	// GP
	    gpio_adr | 12'h024 : spiaddr = 8'h1e;			    gpio_adr | 12'h024 : spiaddr = 8'h1e;
	    gpio_adr | 12'h029 : spiaddr = 8'h1f;			    gpio_adr | 12'h029 : spiaddr = 8'h1f;
	    gpio_adr | 12'h028 : spiaddr = 8'h20;			    gpio_adr | 12'h028 : spiaddr = 8'h20;
	    gpio_adr | 12'h02d : spiaddr = 8'h21;			    gpio_adr | 12'h02d : spiaddr = 8'h21;
	    gpio_adr | 12'h02c : spiaddr = 8'h22;			    gpio_adr | 12'h02c : spiaddr = 8'h22;
	    gpio_adr | 12'h031 : spiaddr = 8'h23;			    gpio_adr | 12'h031 : spiaddr = 8'h23;
	    gpio_adr | 12'h030 : spiaddr = 8'h24;			    gpio_adr | 12'h030 : spiaddr = 8'h24;
	    gpio_adr | 12'h035 : spiaddr = 8'h25;			    gpio_adr | 12'h035 : spiaddr = 8'h25;
	    gpio_adr | 12'h034 : spiaddr = 8'h26;			    gpio_adr | 12'h034 : spiaddr = 8'h26;
	    gpio_adr | 12'h039 : spiaddr = 8'h27;			    gpio_adr | 12'h039 : spiaddr = 8'h27;
	    gpio_adr | 12'h038 : spiaddr = 8'h28;			    gpio_adr | 12'h038 : spiaddr = 8'h28;
	    gpio_adr | 12'h03d : spiaddr = 8'h29;			    gpio_adr | 12'h03d : spiaddr = 8'h29;
	    gpio_adr | 12'h03c : spiaddr = 8'h2a;			    gpio_adr | 12'h03c : spiaddr = 8'h2a;
	    gpio_adr | 12'h041 : spiaddr = 8'h2b;			    gpio_adr | 12'h041 : spiaddr = 8'h2b;
	    gpio_adr | 12'h040 : spiaddr = 8'h2c;			    gpio_adr | 12'h040 : spiaddr = 8'h2c;
	    gpio_adr | 12'h045 : spiaddr = 8'h2d;			    gpio_adr | 12'h045 : spiaddr = 8'h2d;
	    gpio_adr | 12'h044 : spiaddr = 8'h2e;			    gpio_adr | 12'h044 : spiaddr = 8'h2e;
	    gpio_adr | 12'h049 : spiaddr = 8'h2f;			    gpio_adr | 12'h049 : spiaddr = 8'h2f;
	    gpio_adr | 12'h048 : spiaddr = 8'h30;			    gpio_adr | 12'h048 : spiaddr = 8'h30;
	    gpio_adr | 12'h04d : spiaddr = 8'h31;			    gpio_adr | 12'h04d : spiaddr = 8'h31;
	    gpio_adr | 12'h04c : spiaddr = 8'h32;			    gpio_adr | 12'h04c : spiaddr = 8'h32;
	    gpio_adr | 12'h051 : spiaddr = 8'h33;			    gpio_adr | 12'h051 : spiaddr = 8'h33;
	    gpio_adr | 12'h050 : spiaddr = 8'h34;			    gpio_adr | 12'h050 : spiaddr = 8'h34;
	    gpio_adr | 12'h055 : spiaddr = 8'h35;			    gpio_adr | 12'h055 : spiaddr = 8'h35;
	    gpio_adr | 12'h054 : spiaddr = 8'h36;			    gpio_adr | 12'h054 : spiaddr = 8'h36;
	    gpio_adr | 12'h059 : spiaddr = 8'h37;			    gpio_adr | 12'h059 : spiaddr = 8'h37;
	    gpio_adr | 12'h058 : spiaddr = 8'h38;			    gpio_adr | 12'h058 : spiaddr = 8'h38;
	    gpio_adr | 12'h05d : spiaddr = 8'h39;			    gpio_adr | 12'h05d : spiaddr = 8'h39;
	    gpio_adr | 12'h05c : spiaddr = 8'h3a;			    gpio_adr | 12'h05c : spiaddr = 8'h3a;
	    gpio_adr | 12'h061 : spiaddr = 8'h3b;			    gpio_adr | 12'h061 : spiaddr = 8'h3b;
	    gpio_adr | 12'h060 : spiaddr = 8'h3c;			    gpio_adr | 12'h060 : spiaddr = 8'h3c;
	    gpio_adr | 12'h065 : spiaddr = 8'h3d;			    gpio_adr | 12'h065 : spiaddr = 8'h3d;
	    gpio_adr | 12'h064 : spiaddr = 8'h3e;			    gpio_adr | 12'h064 : spiaddr = 8'h3e;
	    gpio_adr | 12'h069 : spiaddr = 8'h3f;			    gpio_adr | 12'h069 : spiaddr = 8'h3f;
	    gpio_adr | 12'h068 : spiaddr = 8'h40;			    gpio_adr | 12'h068 : spiaddr = 8'h40;
	    gpio_adr | 12'h06d : spiaddr = 8'h41;			    gpio_adr | 12'h06d : spiaddr = 8'h41;
	    gpio_adr | 12'h06c : spiaddr = 8'h42;			    gpio_adr | 12'h06c : spiaddr = 8'h42;
	    gpio_adr | 12'h071 : spiaddr = 8'h43;			    gpio_adr | 12'h071 : spiaddr = 8'h43;
	    gpio_adr | 12'h070 : spiaddr = 8'h44;			    gpio_adr | 12'h070 : spiaddr = 8'h44;
	    gpio_adr | 12'h075 : spiaddr = 8'h45;			    gpio_adr | 12'h075 : spiaddr = 8'h45;
	    gpio_adr | 12'h074 : spiaddr = 8'h46;			    gpio_adr | 12'h074 : spiaddr = 8'h46;
	    gpio_adr | 12'h079 : spiaddr = 8'h47;			    gpio_adr | 12'h079 : spiaddr = 8'h47;
	    gpio_adr | 12'h078 : spiaddr = 8'h48;			    gpio_adr | 12'h078 : spiaddr = 8'h48;
	    gpio_adr | 12'h07d : spiaddr = 8'h49;			    gpio_adr | 12'h07d : spiaddr = 8'h49;
	    gpio_adr | 12'h07c : spiaddr = 8'h4a;			    gpio_adr | 12'h07c : spiaddr = 8'h4a;
	    gpio_adr | 12'h081 : spiaddr = 8'h4b;			    gpio_adr | 12'h081 : spiaddr = 8'h4b;
	    gpio_adr | 12'h080 : spiaddr = 8'h4c;			    gpio_adr | 12'h080 : spiaddr = 8'h4c;
	    gpio_adr | 12'h085 : spiaddr = 8'h4d;			    gpio_adr | 12'h085 : spiaddr = 8'h4d;
	    gpio_adr | 12'h084 : spiaddr = 8'h4e;			    gpio_adr | 12'h084 : spiaddr = 8'h4e;
	    gpio_adr | 12'h089 : spiaddr = 8'h4f;			    gpio_adr | 12'h089 : spiaddr = 8'h4f;
	    gpio_adr | 12'h088 : spiaddr = 8'h50;			    gpio_adr | 12'h088 : spiaddr = 8'h50;
	    gpio_adr | 12'h08d : spiaddr = 8'h51;			    gpio_adr | 12'h08d : spiaddr = 8'h51;
	    gpio_adr | 12'h08c : spiaddr = 8'h52;			    gpio_adr | 12'h08c : spiaddr = 8'h52;
	    gpio_adr | 12'h091 : spiaddr = 8'h53;			    gpio_adr | 12'h091 : spiaddr = 8'h53;
	    gpio_adr | 12'h090 : spiaddr = 8'h54;			    gpio_adr | 12'h090 : spiaddr = 8'h54;
	    gpio_adr | 12'h095 : spiaddr = 8'h55;			    gpio_adr | 12'h095 : spiaddr = 8'h55;
	    gpio_adr | 12'h094 : spiaddr = 8'h56;			    gpio_adr | 12'h094 : spiaddr = 8'h56;
	    gpio_adr | 12'h099 : spiaddr = 8'h57;			    gpio_adr | 12'h099 : spiaddr = 8'h57;
	    gpio_adr | 12'h098 : spiaddr = 8'h58;			    gpio_adr | 12'h098 : spiaddr = 8'h58;
	    gpio_adr | 12'h09d : spiaddr = 8'h59;			    gpio_adr | 12'h09d : spiaddr = 8'h59;
	    gpio_adr | 12'h09c : spiaddr = 8'h5a;			    gpio_adr | 12'h09c : spiaddr = 8'h5a;
	    gpio_adr | 12'h0a1 : spiaddr = 8'h5b;			    gpio_adr | 12'h0a1 : spiaddr = 8'h5b;
	    gpio_adr | 12'h0a0 : spiaddr = 8'h5c;			    gpio_adr | 12'h0a0 : spiaddr = 8'h5c;
	    gpio_adr | 12'h0a5 : spiaddr = 8'h5d;			    gpio_adr | 12'h0a5 : spiaddr = 8'h5d;
	    gpio_adr | 12'h0a4 : spiaddr = 8'h5e;			    gpio_adr | 12'h0a4 : spiaddr = 8'h5e;
	    gpio_adr | 12'h0a9 : spiaddr = 8'h5f;			    gpio_adr | 12'h0a9 : spiaddr = 8'h5f;
	    gpio_adr | 12'h0a8 : spiaddr = 8'h60;			    gpio_adr | 12'h0a8 : spiaddr = 8'h60;
	    gpio_adr | 12'h0ad : spiaddr = 8'h61;			    gpio_adr | 12'h0ad : spiaddr = 8'h61;
	    gpio_adr | 12'h0ac : spiaddr = 8'h62;			    gpio_adr | 12'h0ac : spiaddr = 8'h62;
	    gpio_adr | 12'h0b1 : spiaddr = 8'h63;			    gpio_adr | 12'h0b1 : spiaddr = 8'h63;
	    gpio_adr | 12'h0b0 : spiaddr = 8'h64;			    gpio_adr | 12'h0b0 : spiaddr = 8'h64;
	    gpio_adr | 12'h0b5 : spiaddr = 8'h65;			    gpio_adr | 12'h0b5 : spiaddr = 8'h65;
	    gpio_adr | 12'h0b4 : spiaddr = 8'h66;			    gpio_adr | 12'h0b4 : spiaddr = 8'h66;
	    gpio_adr | 12'h0b9 : spiaddr = 8'h67;			    gpio_adr | 12'h0b9 : spiaddr = 8'h67;
	    gpio_adr | 12'h0b8 : spiaddr = 8'h68;			    gpio_adr | 12'h0b8 : spiaddr = 8'h68;

	    gpio_adr | 12'h010 : spiaddr = 8'h69;	// GP		    gpio_adr | 12'h010 : spiaddr = 8'h69;	// GP

	    gpio_adr | 12'h00f : spiaddr = 8'h6a;	// GP		    gpio_adr | 12'h00f : spiaddr = 8'h6a;	// GP
	    gpio_adr | 12'h00e : spiaddr = 8'h6b;	// GP		    gpio_adr | 12'h00e : spiaddr = 8'h6b;	// GP
	    gpio_adr | 12'h00d : spiaddr = 8'h6c;	// GP		    gpio_adr | 12'h00d : spiaddr = 8'h6c;	// GP
	    gpio_adr | 12'h00c : spiaddr = 8'h6d;	// GP		    gpio_adr | 12'h00c : spiaddr = 8'h6d;	// GP

	    gpio_adr | 12'h004 : spiaddr = 8'h6e;	// Po		    gpio_adr | 12'h004 : spiaddr = 8'h6e;	// Po

	    sys_adr  | 12'h010 : spiaddr = 8'h6f;	// Ho		    sys_adr  | 12'h010 : spiaddr = 8'h6f;	// Ho

	    default : spiaddr = 8'h00;					    default : spiaddr = 8'h00;
	endcase								endcase
	end								end
    endfunction							    endfunction
									
    // SPI is considered active when the GPIO for CSB is set 	    // SPI is considered active when the GPIO for CSB is set 
    // CSB is low.  SPI is considered "busy" when rdstb or wr	    // CSB is low.  SPI is considered "busy" when rdstb or wr
    // indicating that the SPI will read or write a byte on t	    // indicating that the SPI will read or write a byte on t
    // transition.						    // transition.

    wire spi_is_enabled = (~gpio_configure[3][INP_DIS]) & (~h	    wire spi_is_enabled = (~gpio_configure[3][INP_DIS]) & (~h
    wire spi_is_active = spi_is_enabled && (mgmt_gpio_in[3] =	    wire spi_is_active = spi_is_enabled && (mgmt_gpio_in[3] =
    wire spi_is_busy = spi_is_active && (rdstb || wrstb);	    wire spi_is_busy = spi_is_active && (rdstb || wrstb);

    /* Wishbone back-door state machine and address translati	    /* Wishbone back-door state machine and address translati

    always @(posedge wb_clk_i or posedge wb_rst_i) begin	    always @(posedge wb_clk_i or posedge wb_rst_i) begin
	if (wb_rst_i) begin						if (wb_rst_i) begin
	    wbbd_sck <= 1'b0;						    wbbd_sck <= 1'b0;
	    wbbd_write <= 1'b0;						    wbbd_write <= 1'b0;
	    wbbd_addr <= 8'd0;						    wbbd_addr <= 8'd0;
	    wbbd_data <= 8'd0;						    wbbd_data <= 8'd0;
	    wbbd_busy <= 1'b0;						    wbbd_busy <= 1'b0;
	    wb_ack_o <= 1'b0;						    wb_ack_o <= 1'b0;
	    wbbd_state <= `WBBD_IDLE;					    wbbd_state <= `WBBD_IDLE;
	end else begin							end else begin
	    case (wbbd_state)						    case (wbbd_state)
		`WBBD_IDLE: begin						`WBBD_IDLE: begin
		    wbbd_sck <= 1'b0;						    wbbd_sck <= 1'b0;
		    wbbd_busy <= 1'b0;						    wbbd_busy <= 1'b0;
		    if ((sys_select | gpio_select | spi_selec			    if ((sys_select | gpio_select | spi_selec
	    	    		 wb_cyc_i && wb_stb_i) begin		    	    		 wb_cyc_i && wb_stb_i) begin
			wb_ack_o <= 1'b0;						wb_ack_o <= 1'b0;
			wbbd_state <= `WBBD_SETUP0;					wbbd_state <= `WBBD_SETUP0;
		    end								    end
		end								end
		`WBBD_SETUP0: begin						`WBBD_SETUP0: begin
		    wbbd_sck <= 1'b0;						    wbbd_sck <= 1'b0;
		    wbbd_addr <= spiaddr(wb_adr_i);				    wbbd_addr <= spiaddr(wb_adr_i);
		    if (wb_sel_i[0] & wb_we_i) begin				    if (wb_sel_i[0] & wb_we_i) begin
		    	wbbd_data <= wb_dat_i[7:0];				    	wbbd_data <= wb_dat_i[7:0];
		    end								    end
		    wbbd_write <= wb_sel_i[0] & wb_we_i;			    wbbd_write <= wb_sel_i[0] & wb_we_i;
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;

		    // If the SPI is being accessed and about			    // If the SPI is being accessed and about
		    // write a byte, then stall until the SPI			    // write a byte, then stall until the SPI
		    if (!spi_is_busy) begin					    if (!spi_is_busy) begin
		        wbbd_state <= `WBBD_RW0;				        wbbd_state <= `WBBD_RW0;
		    end								    end
		end								end
		`WBBD_RW0: begin						`WBBD_RW0: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b1;						    wbbd_sck <= 1'b1;
		    wb_dat_o[7:0] <= odata;					    wb_dat_o[7:0] <= odata;
		    wbbd_state <= `WBBD_SETUP1;					    wbbd_state <= `WBBD_SETUP1;
		end								end
		`WBBD_SETUP1: begin						`WBBD_SETUP1: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b0;						    wbbd_sck <= 1'b0;
		    wbbd_addr <= spiaddr(wb_adr_i + 1);				    wbbd_addr <= spiaddr(wb_adr_i + 1);
		    if (wb_sel_i[1] & wb_we_i) begin				    if (wb_sel_i[1] & wb_we_i) begin
		    	wbbd_data <= wb_dat_i[15:8];				    	wbbd_data <= wb_dat_i[15:8];
		    end								    end
		    wbbd_write <= wb_sel_i[1] & wb_we_i;			    wbbd_write <= wb_sel_i[1] & wb_we_i;
		    if (!spi_is_busy) begin					    if (!spi_is_busy) begin
		        wbbd_state <= `WBBD_RW1;				        wbbd_state <= `WBBD_RW1;
		    end								    end
		end								end
		`WBBD_RW1: begin						`WBBD_RW1: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b1;						    wbbd_sck <= 1'b1;
		    wb_dat_o[15:8] <= odata;					    wb_dat_o[15:8] <= odata;
		    wbbd_state <= `WBBD_SETUP2;					    wbbd_state <= `WBBD_SETUP2;
		end								end
		`WBBD_SETUP2: begin						`WBBD_SETUP2: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b0;						    wbbd_sck <= 1'b0;
		    wbbd_addr <= spiaddr(wb_adr_i + 2);				    wbbd_addr <= spiaddr(wb_adr_i + 2);
		    if (wb_sel_i[2] & wb_we_i) begin				    if (wb_sel_i[2] & wb_we_i) begin
		    	wbbd_data <= wb_dat_i[23:16];				    	wbbd_data <= wb_dat_i[23:16];
		    end								    end
		    wbbd_write <= wb_sel_i[2] & wb_we_i;			    wbbd_write <= wb_sel_i[2] & wb_we_i;
		    if (!spi_is_busy) begin					    if (!spi_is_busy) begin
		        wbbd_state <= `WBBD_RW2;				        wbbd_state <= `WBBD_RW2;
		    end								    end
		end								end
		`WBBD_RW2: begin						`WBBD_RW2: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b1;						    wbbd_sck <= 1'b1;
		    wb_dat_o[23:16] <= odata;					    wb_dat_o[23:16] <= odata;
		    wbbd_state <= `WBBD_SETUP3;					    wbbd_state <= `WBBD_SETUP3;
		end								end
		`WBBD_SETUP3: begin						`WBBD_SETUP3: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b0;						    wbbd_sck <= 1'b0;
		    wbbd_addr <= spiaddr(wb_adr_i + 3);				    wbbd_addr <= spiaddr(wb_adr_i + 3);
		    if (wb_sel_i[3] & wb_we_i) begin				    if (wb_sel_i[3] & wb_we_i) begin
		    	wbbd_data <= wb_dat_i[31:24];				    	wbbd_data <= wb_dat_i[31:24];
		    end								    end
		    wbbd_write <= wb_sel_i[3] & wb_we_i;			    wbbd_write <= wb_sel_i[3] & wb_we_i;
		    if (!spi_is_busy) begin					    if (!spi_is_busy) begin
		        wbbd_state <= `WBBD_RW3;				        wbbd_state <= `WBBD_RW3;
		    end								    end
		end								end
		`WBBD_RW3: begin						`WBBD_RW3: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b1;						    wbbd_sck <= 1'b1;
		    wb_dat_o[31:24] <= odata;					    wb_dat_o[31:24] <= odata;
		    wb_ack_o <= 1'b1;	// Release hold on wi			    wb_ack_o <= 1'b1;	// Release hold on wi
		    wbbd_state <= `WBBD_DONE;					    wbbd_state <= `WBBD_DONE;
		end								end
		`WBBD_DONE: begin						`WBBD_DONE: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b0;						    wbbd_sck <= 1'b0;
		    wb_ack_o <= 1'b0;	// Reset for next acc			    wb_ack_o <= 1'b0;	// Reset for next acc
		    wbbd_write <= 1'b0;						    wbbd_write <= 1'b0;
		    wbbd_state <= `WBBD_RESET;					    wbbd_state <= `WBBD_RESET;
		end								end
		`WBBD_RESET: begin						`WBBD_RESET: begin
		    wbbd_busy <= 1'b1;						    wbbd_busy <= 1'b1;
		    wbbd_sck <= 1'b1;						    wbbd_sck <= 1'b1;
		    wb_ack_o <= 1'b0;						    wb_ack_o <= 1'b0;
		    wbbd_write <= 1'b0;						    wbbd_write <= 1'b0;
		    wbbd_state <= `WBBD_IDLE;					    wbbd_state <= `WBBD_IDLE;
		end								end
	    endcase							    endcase
	end								end
    end								    end

    // Instantiate the SPI interface protocol module		    // Instantiate the SPI interface protocol module

    housekeeping_spi hkspi (					    housekeeping_spi hkspi (
	.reset(~porb),							.reset(~porb),
    	.SCK(mgmt_gpio_in[4]),					    	.SCK(mgmt_gpio_in[4]),
    	.SDI(mgmt_gpio_in[2]),					    	.SDI(mgmt_gpio_in[2]),
    	.CSB((spi_is_enabled) ? mgmt_gpio_in[3] : 1'b1),	    	.CSB((spi_is_enabled) ? mgmt_gpio_in[3] : 1'b1),
    	.SDO(sdo),						    	.SDO(sdo),
    	.sdoenb(sdo_enb),					    	.sdoenb(sdo_enb),
    	.idata(odata),						    	.idata(odata),
    	.odata(idata),						    	.odata(idata),
    	.oaddr(iaddr),						    	.oaddr(iaddr),
    	.rdstb(rdstb),						    	.rdstb(rdstb),
    	.wrstb(wrstb),						    	.wrstb(wrstb),
    	.pass_thru_mgmt(pass_thru_mgmt),			    	.pass_thru_mgmt(pass_thru_mgmt),
    	.pass_thru_mgmt_delay(pass_thru_mgmt_delay),		    	.pass_thru_mgmt_delay(pass_thru_mgmt_delay),
    	.pass_thru_user(pass_thru_user),			    	.pass_thru_user(pass_thru_user),
    	.pass_thru_user_delay(pass_thru_user_delay),		    	.pass_thru_user_delay(pass_thru_user_delay),
    	.pass_thru_mgmt_reset(pass_thru_mgmt_reset),		    	.pass_thru_mgmt_reset(pass_thru_mgmt_reset),
    	.pass_thru_user_reset(pass_thru_user_reset)		    	.pass_thru_user_reset(pass_thru_user_reset)
    );								    );



    // GPIO data handling to and from the management SoC	    // GPIO data handling to and from the management SoC

    assign mgmt_gpio_out[37] = (qspi_enabled) ? spimemio_flas	    assign mgmt_gpio_out[37] = (qspi_enabled) ? spimemio_flas
		mgmt_gpio_data[37];						mgmt_gpio_data[37];
    assign mgmt_gpio_out[36] = (qspi_enabled) ? spimemio_flas	    assign mgmt_gpio_out[36] = (qspi_enabled) ? spimemio_flas
		mgmt_gpio_data[36];						mgmt_gpio_data[36];

    assign mgmt_gpio_oeb[37] = (qspi_enabled) ? spimemio_flas	    assign mgmt_gpio_oeb[37] = (qspi_enabled) ? spimemio_flas
		~gpio_configure[37][INP_DIS];					~gpio_configure[37][INP_DIS];
    assign mgmt_gpio_oeb[36] = (qspi_enabled) ? spimemio_flas	    assign mgmt_gpio_oeb[36] = (qspi_enabled) ? spimemio_flas
		~gpio_configure[36][INP_DIS];					~gpio_configure[36][INP_DIS];
    assign mgmt_gpio_oeb[35] = (spi_enabled) ? spi_sdoenb :	    assign mgmt_gpio_oeb[35] = (spi_enabled) ? spi_sdoenb :
		~gpio_configure[35][INP_DIS];					~gpio_configure[35][INP_DIS];

    // NOTE:  Ignored by spimemio module when QSPI disabled, 	    // NOTE:  Ignored by spimemio module when QSPI disabled, 
    // need any exception when qspi_enabled == 1.		    // need any exception when qspi_enabled == 1.
    assign spimemio_flash_io3_di = mgmt_gpio_in[37];		    assign spimemio_flash_io3_di = mgmt_gpio_in[37];
    assign spimemio_flash_io2_di = mgmt_gpio_in[36];		    assign spimemio_flash_io2_di = mgmt_gpio_in[36];

    // SPI master is assigned to the other 4 bits of the data	    // SPI master is assigned to the other 4 bits of the data
    assign mgmt_gpio_out[32] = (spi_enabled) ? spi_sck : mgmt	    assign mgmt_gpio_out[32] = (spi_enabled) ? spi_sck : mgmt
    assign mgmt_gpio_out[33] = (spi_enabled) ? spi_csb : mgmt	    assign mgmt_gpio_out[33] = (spi_enabled) ? spi_csb : mgmt
    assign mgmt_gpio_out[34] = mgmt_gpio_data[34];		    assign mgmt_gpio_out[34] = mgmt_gpio_data[34];
    assign mgmt_gpio_out[35] = (spi_enabled) ? spi_sdo : mgmt	    assign mgmt_gpio_out[35] = (spi_enabled) ? spi_sdo : mgmt

    assign mgmt_gpio_out[31:16] = mgmt_gpio_data[31:16];	    assign mgmt_gpio_out[31:16] = mgmt_gpio_data[31:16];
    assign mgmt_gpio_out[12:11] = mgmt_gpio_data[12:11];	    assign mgmt_gpio_out[12:11] = mgmt_gpio_data[12:11];

    assign mgmt_gpio_out[10] = (pass_thru_user_delay) ? mgmt_	    assign mgmt_gpio_out[10] = (pass_thru_user_delay) ? mgmt_
			: mgmt_gpio_data[10];						: mgmt_gpio_data[10];
    assign mgmt_gpio_out_9_prebuff = (pass_thru_user) ? mgmt_	    assign mgmt_gpio_out_9_prebuff = (pass_thru_user) ? mgmt_
			: mgmt_gpio_data[9];						: mgmt_gpio_data[9];

(* keep *) bufbd7 mgmt_gpio_9_buff_inst (		      |	(* keep *) sky130_fd_sc_hd__clkbuf_8 mgmt_gpio_9_buff_inst (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
        .VPWR(VPWR),						        .VPWR(VPWR),
        .VGND(VGND),						        .VGND(VGND),
        .VPB(VPWR),						        .VPB(VPWR),
        .VNB(VGND),						        .VNB(VGND),
`endif								`endif
	.I(mgmt_gpio_out_9_prebuff),			      |		.A(mgmt_gpio_out_9_prebuff),
    .Z(mgmt_gpio_out[9]));				      |	    .X(mgmt_gpio_out[9]));

    assign mgmt_gpio_out[8] = (pass_thru_user_delay) ? mgmt_g	    assign mgmt_gpio_out[8] = (pass_thru_user_delay) ? mgmt_g
			: mgmt_gpio_data[8];						: mgmt_gpio_data[8];

    assign mgmt_gpio_out[7] = mgmt_gpio_data[7];		    assign mgmt_gpio_out[7] = mgmt_gpio_data[7];
    assign mgmt_gpio_out[6] = (uart_enabled) ? ser_tx : mgmt_	    assign mgmt_gpio_out[6] = (uart_enabled) ? ser_tx : mgmt_
    assign mgmt_gpio_out[5:2] = mgmt_gpio_data[5:2];		    assign mgmt_gpio_out[5:2] = mgmt_gpio_data[5:2];

    // In pass-through modes, route SDO from the respective f	    // In pass-through modes, route SDO from the respective f
    // management SoC) to the dedicated SDO pin (GPIO[1])	    // management SoC) to the dedicated SDO pin (GPIO[1])

    assign mgmt_gpio_out[1] = (pass_thru_mgmt) ? pad_flash_io	    assign mgmt_gpio_out[1] = (pass_thru_mgmt) ? pad_flash_io
		 (pass_thru_user) ? mgmt_gpio_in[11] :				 (pass_thru_user) ? mgmt_gpio_in[11] :
		 (spi_is_active) ? sdo : mgmt_gpio_data[1];			 (spi_is_active) ? sdo : mgmt_gpio_data[1];
    assign mgmt_gpio_out[0] = (debug_mode) ? debug_out : mgmt	    assign mgmt_gpio_out[0] = (debug_mode) ? debug_out : mgmt

    assign mgmt_gpio_oeb[1] = (spi_is_active) ? sdo_enb : ~gp	    assign mgmt_gpio_oeb[1] = (spi_is_active) ? sdo_enb : ~gp
    assign mgmt_gpio_oeb[0] = (debug_mode) ? debug_oeb : ~gpi	    assign mgmt_gpio_oeb[0] = (debug_mode) ? debug_oeb : ~gpi

    assign ser_rx = (uart_enabled) ? mgmt_gpio_in[5] : 1'b0;	    assign ser_rx = (uart_enabled) ? mgmt_gpio_in[5] : 1'b0;
    assign spi_sdi = (spi_enabled) ? mgmt_gpio_in[34] : 1'b0;	    assign spi_sdi = (spi_enabled) ? mgmt_gpio_in[34] : 1'b0;
    assign debug_in = (debug_mode) ? mgmt_gpio_in[0] : 1'b0;	    assign debug_in = (debug_mode) ? mgmt_gpio_in[0] : 1'b0;

    genvar i;							    genvar i;

    /* These are disconnected, but apply a meaningful signal 	    /* These are disconnected, but apply a meaningful signal 
    generate							    generate
	for (i = 2; i < `MPRJ_IO_PADS-3; i = i + 1) begin		for (i = 2; i < `MPRJ_IO_PADS-3; i = i + 1) begin
	    assign mgmt_gpio_oeb[i] = ~gpio_configure[i][INP_		    assign mgmt_gpio_oeb[i] = ~gpio_configure[i][INP_
	end								end
    endgenerate							    endgenerate

    // System monitoring.  Multiplex the clock and trap		    // System monitoring.  Multiplex the clock and trap
    // signals to the associated pad, and multiplex the irq s	    // signals to the associated pad, and multiplex the irq s
    // from the associated pad, when the redirection is enabl	    // from the associated pad, when the redirection is enabl
    // that the redirection is upstream of the user/managment	    // that the redirection is upstream of the user/managment
    // so the pad being under control of the user area takes 	    // so the pad being under control of the user area takes 
    // over the system monitoring function.			    // over the system monitoring function.

    assign mgmt_gpio_out_15_prebuff = (clk2_output_dest == 1'	    assign mgmt_gpio_out_15_prebuff = (clk2_output_dest == 1'
		: mgmt_gpio_data[15];						: mgmt_gpio_data[15];

(* keep *) bufbd7 mgmt_gpio_15_buff_inst (		      |	(* keep *) sky130_fd_sc_hd__clkbuf_8 mgmt_gpio_15_buff_inst (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
        .VPWR(VPWR),						        .VPWR(VPWR),
        .VGND(VGND),						        .VGND(VGND),
        .VPB(VPWR),						        .VPB(VPWR),
        .VNB(VGND),						        .VNB(VGND),
`endif								`endif
	.I(mgmt_gpio_out_15_prebuff),			      |		.A(mgmt_gpio_out_15_prebuff),
    .Z(mgmt_gpio_out[15]));				      |	    .X(mgmt_gpio_out[15]));

    assign mgmt_gpio_out_14_prebuff = (clk1_output_dest == 1'	    assign mgmt_gpio_out_14_prebuff = (clk1_output_dest == 1'
		: mgmt_gpio_data[14];						: mgmt_gpio_data[14];

(* keep *) bufbd7 mgmt_gpio_14_buff_inst (		      |	(* keep *) sky130_fd_sc_hd__clkbuf_8 mgmt_gpio_14_buff_inst (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
        .VPWR(VPWR),						        .VPWR(VPWR),
        .VGND(VGND),						        .VGND(VGND),
        .VPB(VPWR),						        .VPB(VPWR),
        .VNB(VGND),						        .VNB(VGND),
`endif								`endif
	.I(mgmt_gpio_out_14_prebuff),			      |		.A(mgmt_gpio_out_14_prebuff),
    .Z(mgmt_gpio_out[14]));				      |	    .X(mgmt_gpio_out[14]));

    assign mgmt_gpio_out[13] = (trap_output_dest == 1'b1) ? t	    assign mgmt_gpio_out[13] = (trap_output_dest == 1'b1) ? t
		: mgmt_gpio_data[13];						: mgmt_gpio_data[13];

    assign irq[0] = irq_spi;					    assign irq[0] = irq_spi;
    assign irq[1] = (irq_1_inputsrc == 1'b1) ? mgmt_gpio_in[7	    assign irq[1] = (irq_1_inputsrc == 1'b1) ? mgmt_gpio_in[7
    assign irq[2] = (irq_2_inputsrc == 1'b1) ? mgmt_gpio_in[1	    assign irq[2] = (irq_2_inputsrc == 1'b1) ? mgmt_gpio_in[1

    // GPIO serial loader and GPIO management control		    // GPIO serial loader and GPIO management control

`define GPIO_IDLE	2'b00					`define GPIO_IDLE	2'b00
`define GPIO_START	2'b01					`define GPIO_START	2'b01
`define GPIO_XBYTE	2'b10					`define GPIO_XBYTE	2'b10
`define GPIO_LOAD	2'b11					`define GPIO_LOAD	2'b11

    reg [3:0]	xfer_count;					    reg [3:0]	xfer_count;
    reg [4:0]	pad_count_1;					    reg [4:0]	pad_count_1;
    reg [5:0]	pad_count_2;					    reg [5:0]	pad_count_2;
    reg [1:0]	xfer_state;					    reg [1:0]	xfer_state;

    reg serial_clock_pre;					    reg serial_clock_pre;
    reg serial_resetn_pre;					    reg serial_resetn_pre;
    reg serial_load_pre;					    reg serial_load_pre;
    reg [IO_CTRL_BITS-1:0] serial_data_staging_1;		    reg [IO_CTRL_BITS-1:0] serial_data_staging_1;
    reg [IO_CTRL_BITS-1:0] serial_data_staging_2;		    reg [IO_CTRL_BITS-1:0] serial_data_staging_2;

    assign serial_clock = (serial_bb_enable == 1'b1) ?		    assign serial_clock = (serial_bb_enable == 1'b1) ?
			serial_bb_clock : serial_clock_pre;				serial_bb_clock : serial_clock_pre;
    assign serial_resetn = (serial_bb_enable == 1'b1) ?		    assign serial_resetn = (serial_bb_enable == 1'b1) ?
			serial_bb_resetn : serial_resetn_pre;				serial_bb_resetn : serial_resetn_pre;
    assign serial_load = (serial_bb_enable == 1'b1) ?		    assign serial_load = (serial_bb_enable == 1'b1) ?
			serial_bb_load : serial_load_pre;				serial_bb_load : serial_load_pre;

    assign serial_data_1 = (serial_bb_enable == 1'b1) ?		    assign serial_data_1 = (serial_bb_enable == 1'b1) ?
			serial_bb_data_1 : serial_data_stagin				serial_bb_data_1 : serial_data_stagin
    assign serial_data_2 = (serial_bb_enable == 1'b1) ?		    assign serial_data_2 = (serial_bb_enable == 1'b1) ?
			serial_bb_data_2 : serial_data_stagin				serial_bb_data_2 : serial_data_stagin

    always @(posedge wb_clk_i or negedge porb) begin		    always @(posedge wb_clk_i or negedge porb) begin
	if (porb == 1'b0) begin						if (porb == 1'b0) begin
	    xfer_state <= `GPIO_IDLE;					    xfer_state <= `GPIO_IDLE;
	    xfer_count <= 4'd0;						    xfer_count <= 4'd0;
            /* NOTE:  This assumes that MPRJ_IO_PADS_1 and MP	            /* NOTE:  This assumes that MPRJ_IO_PADS_1 and MP
             * equal, because they get clocked the same numbe	             * equal, because they get clocked the same numbe
             * the same clock signal.  pad_count_2 gates the 	             * the same clock signal.  pad_count_2 gates the 
             */							             */
	    pad_count_1 <= `MPRJ_IO_PADS_1 - 1;				    pad_count_1 <= `MPRJ_IO_PADS_1 - 1;
	    pad_count_2 <= `MPRJ_IO_PADS_1;				    pad_count_2 <= `MPRJ_IO_PADS_1;
	    serial_resetn_pre <= 1'b0;					    serial_resetn_pre <= 1'b0;
	    serial_clock_pre <= 1'b0;					    serial_clock_pre <= 1'b0;
	    serial_load_pre <= 1'b0;					    serial_load_pre <= 1'b0;
	    serial_data_staging_1 <= 0;					    serial_data_staging_1 <= 0;
	    serial_data_staging_2 <= 0;					    serial_data_staging_2 <= 0;
	    serial_busy <= 1'b0;					    serial_busy <= 1'b0;

	end else begin							end else begin

            serial_resetn_pre <= 1'b1;				            serial_resetn_pre <= 1'b1;
	    case (xfer_state)						    case (xfer_state)
		`GPIO_IDLE: begin						`GPIO_IDLE: begin
		    pad_count_1 <= `MPRJ_IO_PADS_1 - 1;				    pad_count_1 <= `MPRJ_IO_PADS_1 - 1;
                    pad_count_2 <= `MPRJ_IO_PADS_1;		                    pad_count_2 <= `MPRJ_IO_PADS_1;
                    serial_clock_pre <= 1'b0;			                    serial_clock_pre <= 1'b0;
                    serial_load_pre <= 1'b0;			                    serial_load_pre <= 1'b0;
                    if (serial_xfer == 1'b1) begin		                    if (serial_xfer == 1'b1) begin
                        xfer_state <= `GPIO_START;		                        xfer_state <= `GPIO_START;
	    	    	serial_busy <= 1'b1;				    	    	serial_busy <= 1'b1;
                    end else begin				                    end else begin
	    	    	serial_busy <= 1'b0;				    	    	serial_busy <= 1'b0;
		    end								    end
		end								end
		`GPIO_START: begin						`GPIO_START: begin
                    serial_clock_pre <= 1'b0;			                    serial_clock_pre <= 1'b0;
                    serial_load_pre <= 1'b0;			                    serial_load_pre <= 1'b0;
                    xfer_count <= 6'd0;				                    xfer_count <= 6'd0;
                    pad_count_1 <= pad_count_1 - 1;		                    pad_count_1 <= pad_count_1 - 1;
                    pad_count_2 <= pad_count_2 + 1;		                    pad_count_2 <= pad_count_2 + 1;
                    xfer_state <= `GPIO_XBYTE;			                    xfer_state <= `GPIO_XBYTE;
                    serial_data_staging_1 <= gpio_configure[p	                    serial_data_staging_1 <= gpio_configure[p
                    serial_data_staging_2 <= gpio_configure[p	                    serial_data_staging_2 <= gpio_configure[p
		end								end
		`GPIO_XBYTE: begin						`GPIO_XBYTE: begin
                    serial_clock_pre <= ~serial_clock;		                    serial_clock_pre <= ~serial_clock;
                    serial_load_pre <= 1'b0;			                    serial_load_pre <= 1'b0;
                    if (serial_clock == 1'b0) begin		                    if (serial_clock == 1'b0) begin
                        if (xfer_count == IO_CTRL_BITS - 1) b	                        if (xfer_count == IO_CTRL_BITS - 1) b
                            xfer_count <= 4'd0;			                            xfer_count <= 4'd0;
                            if (pad_count_2 == `MPRJ_IO_PADS)	                            if (pad_count_2 == `MPRJ_IO_PADS)
                                xfer_state <= `GPIO_LOAD;	                                xfer_state <= `GPIO_LOAD;
                            end else begin			                            end else begin
                                xfer_state <= `GPIO_START;	                                xfer_state <= `GPIO_START;
                            end					                            end
                        end else begin				                        end else begin
                            xfer_count <= xfer_count + 1;	                            xfer_count <= xfer_count + 1;
                        end					                        end
                    end else begin				                    end else begin
                        serial_data_staging_1 <=		                        serial_data_staging_1 <=
				{serial_data_staging_1[IO_CTR					{serial_data_staging_1[IO_CTR
                        serial_data_staging_2 <=		                        serial_data_staging_2 <=
				{serial_data_staging_2[IO_CTR					{serial_data_staging_2[IO_CTR
                    end						                    end
		end								end
		`GPIO_LOAD: begin						`GPIO_LOAD: begin
                    xfer_count <= xfer_count + 1;		                    xfer_count <= xfer_count + 1;

                    /* Load sequence:  Pulse clock for final 	                    /* Load sequence:  Pulse clock for final 
                     * Pulse the load strobe.			                     * Pulse the load strobe.
                     * Return to idle mode.			                     * Return to idle mode.
                     */						                     */
                    if (xfer_count == 4'd0) begin		                    if (xfer_count == 4'd0) begin
                        serial_clock_pre <= 1'b0;		                        serial_clock_pre <= 1'b0;
                        serial_load_pre <= 1'b0;		                        serial_load_pre <= 1'b0;
                    end else if (xfer_count == 4'd1) begin	                    end else if (xfer_count == 4'd1) begin
                        serial_clock_pre <= 1'b0;		                        serial_clock_pre <= 1'b0;
                        serial_load_pre <= 1'b1;		                        serial_load_pre <= 1'b1;
                    end else if (xfer_count == 4'd2) begin	                    end else if (xfer_count == 4'd2) begin
	    	    	serial_busy <= 1'b0;				    	    	serial_busy <= 1'b0;
                        serial_clock_pre <= 1'b0;		                        serial_clock_pre <= 1'b0;
                        serial_load_pre <= 1'b0;		                        serial_load_pre <= 1'b0;
                        xfer_state <= `GPIO_IDLE;		                        xfer_state <= `GPIO_IDLE;
		    end								    end
                end						                end
            endcase						            endcase
	end								end
    end								    end

    // SPI Identification					    // SPI Identification

    assign mfgr_id = 12'h456;		// Hard-coded		    assign mfgr_id = 12'h456;		// Hard-coded
    assign prod_id = 8'h11;		// Hard-coded		    assign prod_id = 8'h11;		// Hard-coded
    assign mask_rev = mask_rev_in;	// Copy in to out.	    assign mask_rev = mask_rev_in;	// Copy in to out.

    // SPI Data transfer protocol.  The wishbone back door ma	    // SPI Data transfer protocol.  The wishbone back door ma
    // used if the front door is closed (CSB is high or the C	    // used if the front door is closed (CSB is high or the C
    // not an input).  The time to apply values for the back 	    // not an input).  The time to apply values for the back 
    // is limited to the clock cycle around the read or write	    // is limited to the clock cycle around the read or write
    // wbbd state machine (see below).				    // wbbd state machine (see below).

    assign caddr = (wbbd_busy) ? wbbd_addr : iaddr;		    assign caddr = (wbbd_busy) ? wbbd_addr : iaddr;
    assign csclk = (wbbd_busy) ? wbbd_sck : ((spi_is_active) 	    assign csclk = (wbbd_busy) ? wbbd_sck : ((spi_is_active) 
    assign cdata = (wbbd_busy) ? wbbd_data : idata;		    assign cdata = (wbbd_busy) ? wbbd_data : idata;
    assign cwstb = (wbbd_busy) ? wbbd_write : wrstb;		    assign cwstb = (wbbd_busy) ? wbbd_write : wrstb;

    assign odata = fdata(caddr);				    assign odata = fdata(caddr);

    // Register mapping and I/O to SPI interface module		    // Register mapping and I/O to SPI interface module

    integer j;							    integer j;

    always @(posedge csclk or negedge porb) begin		    always @(posedge csclk or negedge porb) begin
	if (porb == 1'b0) begin						if (porb == 1'b0) begin
            // Set trim for PLL at (almost) slowest rate (~90	            // Set trim for PLL at (almost) slowest rate (~90
            // pll_trim[12] must be set to zero for proper st	            // pll_trim[12] must be set to zero for proper st
            pll_trim <= 26'b11111111111110111111111111;		            pll_trim <= 26'b11111111111110111111111111;
            pll_sel <= 3'b010;		// Default output div	            pll_sel <= 3'b010;		// Default output div
            pll90_sel <= 3'b010;	// Default secondary 	            pll90_sel <= 3'b010;	// Default secondary 
            pll_div <= 5'b00100;	// Default feedback d	            pll_div <= 5'b00100;	// Default feedback d
            pll_dco_ena <= 1'b1;	// Default free-runni	            pll_dco_ena <= 1'b1;	// Default free-runni
            pll_ena <= 1'b0;		// Default PLL turned	            pll_ena <= 1'b0;		// Default PLL turned
            pll_bypass <= 1'b1;		// Default bypass mod	            pll_bypass <= 1'b1;		// Default bypass mod
            irq_spi <= 1'b0;					            irq_spi <= 1'b0;
            reset_reg <= 1'b0;					            reset_reg <= 1'b0;

	    // System monitoring signals				    // System monitoring signals
	    clk1_output_dest <= 1'b0;					    clk1_output_dest <= 1'b0;
	    clk2_output_dest <= 1'b0;					    clk2_output_dest <= 1'b0;
	    trap_output_dest <= 1'b0;					    trap_output_dest <= 1'b0;
	    irq_1_inputsrc <= 1'b0;					    irq_1_inputsrc <= 1'b0;
	    irq_2_inputsrc <= 1'b0;					    irq_2_inputsrc <= 1'b0;

	    // GPIO Configuration, Data, and Control			    // GPIO Configuration, Data, and Control
	    // To-do:  Get user project pad defaults from ext		    // To-do:  Get user project pad defaults from ext
	    // to be configured by user or at project generat		    // to be configured by user or at project generat
	    // Pads 1 to 4 are the SPI and considered critica		    // Pads 1 to 4 are the SPI and considered critica
	    // infrastructure, and should not be altered from		    // infrastructure, and should not be altered from
	    // below.  NOTE:  These are not startup values, b		    // below.  NOTE:  These are not startup values, b
	    // match the startup values applied to the GPIO, 		    // match the startup values applied to the GPIO, 
	    // GPIO should be always triggered to load at sta		    // GPIO should be always triggered to load at sta

	    for (j = 0; j < `MPRJ_IO_PADS; j=j+1) begin			    for (j = 0; j < `MPRJ_IO_PADS; j=j+1) begin
		if ((j < 2) || (j >= `MPRJ_IO_PADS - 2)) begi			if ((j < 2) || (j >= `MPRJ_IO_PADS - 2)) begi
		    gpio_configure[j] <= 'h1803;				    gpio_configure[j] <= 'h1803;
                end else begin					                end else begin
		    if (j == 3) begin						    if (j == 3) begin
			// j == 3 corresponds to CSB, which i				// j == 3 corresponds to CSB, which i
	                gpio_configure[j] <= 'h0801;			                gpio_configure[j] <= 'h0801;
		    end else begin						    end else begin
	                gpio_configure[j] <= 'h0403;			                gpio_configure[j] <= 'h0403;
		    end								    end
		end								end
	    end								    end

	    mgmt_gpio_data <= 'd0;					    mgmt_gpio_data <= 'd0;
	    mgmt_gpio_data_buf <= 'd0;					    mgmt_gpio_data_buf <= 'd0;
	    serial_bb_enable <= 1'b0;					    serial_bb_enable <= 1'b0;
	    serial_bb_load <= 1'b0;					    serial_bb_load <= 1'b0;
	    serial_bb_data_1 <= 1'b0;					    serial_bb_data_1 <= 1'b0;
	    serial_bb_data_2 <= 1'b0;					    serial_bb_data_2 <= 1'b0;
	    serial_bb_clock <= 1'b0;					    serial_bb_clock <= 1'b0;
	    serial_bb_resetn <= 1'b0;					    serial_bb_resetn <= 1'b0;
	    serial_xfer <= 1'b0;					    serial_xfer <= 1'b0;
	    hkspi_disable <= 1'b0;					    hkspi_disable <= 1'b0;
	    pwr_ctrl_out <= 'd0;					    pwr_ctrl_out <= 'd0;

`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
	    sram_ro_clk <= 1'b0;					    sram_ro_clk <= 1'b0;
	    sram_ro_csb <= 1'b1;					    sram_ro_csb <= 1'b1;
	    sram_ro_addr <= 8'h00;					    sram_ro_addr <= 8'h00;
`endif								`endif

        end else begin						        end else begin
	    if (cwstb == 1'b1) begin					    if (cwstb == 1'b1) begin
                case (caddr)					                case (caddr)
	    	    /* Register 8'h00 is reserved for future 		    	    /* Register 8'h00 is reserved for future 
	    	    /* Registers 8'h01 to 8'h07 are read-only		    	    /* Registers 8'h01 to 8'h07 are read-only
            	    8'h08: begin				            	    8'h08: begin
                	pll_ena <= cdata[0];			                	pll_ena <= cdata[0];
                	pll_dco_ena <= cdata[1];		                	pll_dco_ena <= cdata[1];
            	    end						            	    end
            	    8'h09: begin				            	    8'h09: begin
                	pll_bypass <= cdata[0];			                	pll_bypass <= cdata[0];
            	    end						            	    end
            	    8'h0a: begin				            	    8'h0a: begin
                	irq_spi <= cdata[0];			                	irq_spi <= cdata[0];
            	    end						            	    end
            	    8'h0b: begin				            	    8'h0b: begin
                	reset_reg <= cdata[0];			                	reset_reg <= cdata[0];
            	    end						            	    end

		    /* Register 0c (trap state) is read-only 			    /* Register 0c (trap state) is read-only 

            	    8'h0d: begin				            	    8'h0d: begin
                	pll_trim[7:0] <= cdata;			                	pll_trim[7:0] <= cdata;
            	    end						            	    end
            	    8'h0e: begin				            	    8'h0e: begin
                	pll_trim[15:8] <= cdata;		                	pll_trim[15:8] <= cdata;
            	    end						            	    end
            	    8'h0f: begin				            	    8'h0f: begin
                	pll_trim[23:16] <= cdata;		                	pll_trim[23:16] <= cdata;
            	    end						            	    end
            	    8'h10: begin				            	    8'h10: begin
                	pll_trim[25:24] <= cdata[1:0];		                	pll_trim[25:24] <= cdata[1:0];
            	    end						            	    end
            	    8'h11: begin				            	    8'h11: begin
                	pll90_sel <= cdata[5:3];		                	pll90_sel <= cdata[5:3];
                	pll_sel <= cdata[2:0];			                	pll_sel <= cdata[2:0];
            	    end						            	    end
            	    8'h12: begin				            	    8'h12: begin
                	pll_div <= cdata[4:0];			                	pll_div <= cdata[4:0];
            	    end						            	    end
	    	    8'h13: begin					    	    8'h13: begin
			serial_bb_data_2 <= cdata[6];					serial_bb_data_2 <= cdata[6];
			serial_bb_data_1 <= cdata[5];					serial_bb_data_1 <= cdata[5];
			serial_bb_clock  <= cdata[4];					serial_bb_clock  <= cdata[4];
			serial_bb_load   <= cdata[3];					serial_bb_load   <= cdata[3];
			serial_bb_resetn <= cdata[2];					serial_bb_resetn <= cdata[2];
			serial_bb_enable <= cdata[1];					serial_bb_enable <= cdata[1];
			serial_xfer <= cdata[0];					serial_xfer <= cdata[0];
	    	    end							    	    end

`ifdef USE_SRAM_RO_INTERFACE					`ifdef USE_SRAM_RO_INTERFACE
		    /* Optional:  Add SRAM read-only interfac			    /* Optional:  Add SRAM read-only interfac
		    8'h14: begin						    8'h14: begin
			sram_ro_clk <= cdata[1];					sram_ro_clk <= cdata[1];
			sram_ro_csb <= cdata[0];					sram_ro_csb <= cdata[0];
		    end								    end
		    8'h15: begin						    8'h15: begin
	    		sram_ro_addr <= cdata;				    		sram_ro_addr <= cdata;
		    end								    end
`endif								`endif
		    								    
		    /* Registers 16 to 19 (SRAM data) are rea			    /* Registers 16 to 19 (SRAM data) are rea

		    /* Register 1a (power monitor) is read-on			    /* Register 1a (power monitor) is read-on

            	    8'h1b: begin				            	    8'h1b: begin
			clk1_output_dest <= cdata[2];					clk1_output_dest <= cdata[2];
			clk2_output_dest <= cdata[1];					clk2_output_dest <= cdata[1];
			trap_output_dest <= cdata[0];					trap_output_dest <= cdata[0];
	    	    end							    	    end
            	    8'h1c: begin				            	    8'h1c: begin
			irq_2_inputsrc <= cdata[1];					irq_2_inputsrc <= cdata[1];
			irq_1_inputsrc <= cdata[0];					irq_1_inputsrc <= cdata[0];
	    	    end							    	    end
            	    8'h1d: begin				            	    8'h1d: begin
			gpio_configure[0][12:8] <= cdata[4:0]				gpio_configure[0][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h1e: begin				            	    8'h1e: begin
			gpio_configure[0][7:0] <= cdata;				gpio_configure[0][7:0] <= cdata;
	    	    end							    	    end
            	    8'h1f: begin				            	    8'h1f: begin
			gpio_configure[1][12:8] <= cdata[4:0]				gpio_configure[1][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h20: begin				            	    8'h20: begin
			gpio_configure[1][7:0] <= cdata;				gpio_configure[1][7:0] <= cdata;
	    	    end							    	    end
            	    8'h21: begin				            	    8'h21: begin
			gpio_configure[2][12:8] <= cdata[4:0]				gpio_configure[2][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h22: begin				            	    8'h22: begin
			gpio_configure[2][7:0] <= cdata;				gpio_configure[2][7:0] <= cdata;
	    	    end							    	    end
            	    8'h23: begin				            	    8'h23: begin
			gpio_configure[3][12:8] <= cdata[4:0]				gpio_configure[3][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h24: begin				            	    8'h24: begin
			gpio_configure[3][7:0] <= cdata;				gpio_configure[3][7:0] <= cdata;
	    	    end							    	    end
            	    8'h25: begin				            	    8'h25: begin
			gpio_configure[4][12:8] <= cdata[4:0]				gpio_configure[4][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h26: begin				            	    8'h26: begin
			gpio_configure[4][7:0] <= cdata;				gpio_configure[4][7:0] <= cdata;
	    	    end							    	    end
            	    8'h27: begin				            	    8'h27: begin
			gpio_configure[5][12:8] <= cdata[4:0]				gpio_configure[5][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h28: begin				            	    8'h28: begin
			gpio_configure[5][7:0] <= cdata;				gpio_configure[5][7:0] <= cdata;
	    	    end							    	    end
            	    8'h29: begin				            	    8'h29: begin
			gpio_configure[6][12:8] <= cdata[4:0]				gpio_configure[6][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h2a: begin				            	    8'h2a: begin
			gpio_configure[6][7:0] <= cdata;				gpio_configure[6][7:0] <= cdata;
	    	    end							    	    end
            	    8'h2b: begin				            	    8'h2b: begin
			gpio_configure[7][12:8] <= cdata[4:0]				gpio_configure[7][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h2c: begin				            	    8'h2c: begin
			gpio_configure[7][7:0] <= cdata;				gpio_configure[7][7:0] <= cdata;
	    	    end							    	    end
            	    8'h2d: begin				            	    8'h2d: begin
			gpio_configure[8][12:8] <= cdata[4:0]				gpio_configure[8][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h2e: begin				            	    8'h2e: begin
			gpio_configure[8][7:0] <= cdata;				gpio_configure[8][7:0] <= cdata;
	    	    end							    	    end
            	    8'h2f: begin				            	    8'h2f: begin
			gpio_configure[9][12:8] <= cdata[4:0]				gpio_configure[9][12:8] <= cdata[4:0]
	    	    end							    	    end
            	    8'h30: begin				            	    8'h30: begin
			gpio_configure[9][7:0] <= cdata;				gpio_configure[9][7:0] <= cdata;
	    	    end							    	    end
            	    8'h31: begin				            	    8'h31: begin
			gpio_configure[10][12:8] <= cdata[4:0				gpio_configure[10][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h32: begin				            	    8'h32: begin
			gpio_configure[10][7:0] <= cdata;				gpio_configure[10][7:0] <= cdata;
	    	    end							    	    end
            	    8'h33: begin				            	    8'h33: begin
			gpio_configure[11][12:8] <= cdata[4:0				gpio_configure[11][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h34: begin				            	    8'h34: begin
			gpio_configure[11][7:0] <= cdata;				gpio_configure[11][7:0] <= cdata;
	    	    end							    	    end
            	    8'h35: begin				            	    8'h35: begin
			gpio_configure[12][12:8] <= cdata[4:0				gpio_configure[12][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h36: begin				            	    8'h36: begin
			gpio_configure[12][7:0] <= cdata;				gpio_configure[12][7:0] <= cdata;
	    	    end							    	    end
            	    8'h37: begin				            	    8'h37: begin
			gpio_configure[13][12:8] <= cdata[4:0				gpio_configure[13][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h38: begin				            	    8'h38: begin
			gpio_configure[13][7:0] <= cdata;				gpio_configure[13][7:0] <= cdata;
	    	    end							    	    end
            	    8'h39: begin				            	    8'h39: begin
			gpio_configure[14][12:8] <= cdata[4:0				gpio_configure[14][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h3a: begin				            	    8'h3a: begin
			gpio_configure[14][7:0] <= cdata;				gpio_configure[14][7:0] <= cdata;
	    	    end							    	    end
            	    8'h3b: begin				            	    8'h3b: begin
			gpio_configure[15][12:8] <= cdata[4:0				gpio_configure[15][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h3c: begin				            	    8'h3c: begin
			gpio_configure[15][7:0] <= cdata;				gpio_configure[15][7:0] <= cdata;
	    	    end							    	    end
            	    8'h3d: begin				            	    8'h3d: begin
			gpio_configure[16][12:8] <= cdata[4:0				gpio_configure[16][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h3e: begin				            	    8'h3e: begin
			gpio_configure[16][7:0] <= cdata;				gpio_configure[16][7:0] <= cdata;
	    	    end							    	    end
            	    8'h3f: begin				            	    8'h3f: begin
			gpio_configure[17][12:8] <= cdata[4:0				gpio_configure[17][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h40: begin				            	    8'h40: begin
			gpio_configure[17][7:0] <= cdata;				gpio_configure[17][7:0] <= cdata;
	    	    end							    	    end
            	    8'h41: begin				            	    8'h41: begin
			gpio_configure[18][12:8] <= cdata[4:0				gpio_configure[18][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h42: begin				            	    8'h42: begin
			gpio_configure[18][7:0] <= cdata;				gpio_configure[18][7:0] <= cdata;
	    	    end							    	    end
            	    8'h43: begin				            	    8'h43: begin
			gpio_configure[19][12:8] <= cdata[4:0				gpio_configure[19][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h44: begin				            	    8'h44: begin
			gpio_configure[19][7:0] <= cdata;				gpio_configure[19][7:0] <= cdata;
	    	    end							    	    end
            	    8'h45: begin				            	    8'h45: begin
			gpio_configure[20][12:8] <= cdata[4:0				gpio_configure[20][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h46: begin				            	    8'h46: begin
			gpio_configure[20][7:0] <= cdata;				gpio_configure[20][7:0] <= cdata;
	    	    end							    	    end
            	    8'h47: begin				            	    8'h47: begin
			gpio_configure[21][12:8] <= cdata[4:0				gpio_configure[21][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h48: begin				            	    8'h48: begin
			gpio_configure[21][7:0] <= cdata;				gpio_configure[21][7:0] <= cdata;
	    	    end							    	    end
            	    8'h49: begin				            	    8'h49: begin
			gpio_configure[22][12:8] <= cdata[4:0				gpio_configure[22][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h4a: begin				            	    8'h4a: begin
			gpio_configure[22][7:0] <= cdata;				gpio_configure[22][7:0] <= cdata;
	    	    end							    	    end
            	    8'h4b: begin				            	    8'h4b: begin
			gpio_configure[23][12:8] <= cdata[4:0				gpio_configure[23][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h4c: begin				            	    8'h4c: begin
			gpio_configure[23][7:0] <= cdata;				gpio_configure[23][7:0] <= cdata;
	    	    end							    	    end
            	    8'h4d: begin				            	    8'h4d: begin
			gpio_configure[24][12:8] <= cdata[4:0				gpio_configure[24][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h4e: begin				            	    8'h4e: begin
			gpio_configure[24][7:0] <= cdata;				gpio_configure[24][7:0] <= cdata;
	    	    end							    	    end
            	    8'h4f: begin				            	    8'h4f: begin
			gpio_configure[25][12:8] <= cdata[4:0				gpio_configure[25][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h50: begin				            	    8'h50: begin
			gpio_configure[25][7:0] <= cdata;				gpio_configure[25][7:0] <= cdata;
	    	    end							    	    end
            	    8'h51: begin				            	    8'h51: begin
			gpio_configure[26][12:8] <= cdata[4:0				gpio_configure[26][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h52: begin				            	    8'h52: begin
			gpio_configure[26][7:0] <= cdata;				gpio_configure[26][7:0] <= cdata;
	    	    end							    	    end
            	    8'h53: begin				            	    8'h53: begin
			gpio_configure[27][12:8] <= cdata[4:0				gpio_configure[27][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h54: begin				            	    8'h54: begin
			gpio_configure[27][7:0] <= cdata;				gpio_configure[27][7:0] <= cdata;
	    	    end							    	    end
            	    8'h55: begin				            	    8'h55: begin
			gpio_configure[28][12:8] <= cdata[4:0				gpio_configure[28][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h56: begin				            	    8'h56: begin
			gpio_configure[28][7:0] <= cdata;				gpio_configure[28][7:0] <= cdata;
	    	    end							    	    end
            	    8'h57: begin				            	    8'h57: begin
			gpio_configure[29][12:8] <= cdata[4:0				gpio_configure[29][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h58: begin				            	    8'h58: begin
			gpio_configure[29][7:0] <= cdata;				gpio_configure[29][7:0] <= cdata;
	    	    end							    	    end
            	    8'h59: begin				            	    8'h59: begin
			gpio_configure[30][12:8] <= cdata[4:0				gpio_configure[30][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h5a: begin				            	    8'h5a: begin
			gpio_configure[30][7:0] <= cdata;				gpio_configure[30][7:0] <= cdata;
	    	    end							    	    end
            	    8'h5b: begin				            	    8'h5b: begin
			gpio_configure[31][12:8] <= cdata[4:0				gpio_configure[31][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h5c: begin				            	    8'h5c: begin
			gpio_configure[31][7:0] <= cdata;				gpio_configure[31][7:0] <= cdata;
	    	    end							    	    end
            	    8'h5d: begin				            	    8'h5d: begin
			gpio_configure[32][12:8] <= cdata[4:0				gpio_configure[32][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h5e: begin				            	    8'h5e: begin
			gpio_configure[32][7:0] <= cdata;				gpio_configure[32][7:0] <= cdata;
	    	    end							    	    end
            	    8'h5f: begin				            	    8'h5f: begin
			gpio_configure[33][12:8] <= cdata[4:0				gpio_configure[33][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h60: begin				            	    8'h60: begin
			gpio_configure[33][7:0] <= cdata;				gpio_configure[33][7:0] <= cdata;
	    	    end							    	    end
            	    8'h61: begin				            	    8'h61: begin
			gpio_configure[34][12:8] <= cdata[4:0				gpio_configure[34][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h62: begin				            	    8'h62: begin
			gpio_configure[34][7:0] <= cdata;				gpio_configure[34][7:0] <= cdata;
	    	    end							    	    end
            	    8'h63: begin				            	    8'h63: begin
			gpio_configure[35][12:8] <= cdata[4:0				gpio_configure[35][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h64: begin				            	    8'h64: begin
			gpio_configure[35][7:0] <= cdata;				gpio_configure[35][7:0] <= cdata;
	    	    end							    	    end
            	    8'h65: begin				            	    8'h65: begin
			gpio_configure[36][12:8] <= cdata[4:0				gpio_configure[36][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h66: begin				            	    8'h66: begin
			gpio_configure[36][7:0] <= cdata;				gpio_configure[36][7:0] <= cdata;
	    	    end							    	    end
            	    8'h67: begin				            	    8'h67: begin
			gpio_configure[37][12:8] <= cdata[4:0				gpio_configure[37][12:8] <= cdata[4:0
	    	    end							    	    end
            	    8'h68: begin				            	    8'h68: begin
			gpio_configure[37][7:0] <= cdata;				gpio_configure[37][7:0] <= cdata;
	    	    end							    	    end
	    	    8'h69: begin					    	    8'h69: begin
			mgmt_gpio_data[37:32] <= cdata[5:0];				mgmt_gpio_data[37:32] <= cdata[5:0];
	    	    end							    	    end
	    	    8'h6a: begin					    	    8'h6a: begin
			/* NOTE: mgmt_gpio_data updates only 				/* NOTE: mgmt_gpio_data updates only 
			/* upper byte write when writing thro				/* upper byte write when writing thro
			/* wishbone back-door.  This lets all				/* wishbone back-door.  This lets all
			/* update at the same time.					/* update at the same time.	
			if (spi_is_active) begin					if (spi_is_active) begin
			    mgmt_gpio_data[31:24] <= cdata;				    mgmt_gpio_data[31:24] <= cdata;
			end else begin							end else begin
			    mgmt_gpio_data[31:0] <= {cdata, m				    mgmt_gpio_data[31:0] <= {cdata, m
			end								end
	    	    end							    	    end
	    	    8'h6b: begin					    	    8'h6b: begin
			if (spi_is_active) begin					if (spi_is_active) begin
			    mgmt_gpio_data[23:16] <= cdata;				    mgmt_gpio_data[23:16] <= cdata;
			end else begin							end else begin
			    mgmt_gpio_data_buf[23:16] <= cdat				    mgmt_gpio_data_buf[23:16] <= cdat
			end								end
	    	    end							    	    end
	    	    8'h6c: begin					    	    8'h6c: begin
			if (spi_is_active) begin					if (spi_is_active) begin
			    mgmt_gpio_data[15:8] <= cdata;				    mgmt_gpio_data[15:8] <= cdata;
			end else begin							end else begin
			    mgmt_gpio_data_buf[15:8] <= cdata				    mgmt_gpio_data_buf[15:8] <= cdata
			end								end
	    	    end							    	    end
	    	    8'h6d: begin					    	    8'h6d: begin
			if (spi_is_active) begin					if (spi_is_active) begin
			    mgmt_gpio_data[7:0] <= cdata;				    mgmt_gpio_data[7:0] <= cdata;
			end else begin							end else begin
			    mgmt_gpio_data_buf[7:0] <= cdata;				    mgmt_gpio_data_buf[7:0] <= cdata;
			end								end
	    	    end							    	    end
	    	    8'h6e: begin					    	    8'h6e: begin
			pwr_ctrl_out <= cdata[3:0];					pwr_ctrl_out <= cdata[3:0];
	    	    end							    	    end
	    	    8'h6f: begin					    	    8'h6f: begin
			hkspi_disable <= cdata[0];					hkspi_disable <= cdata[0];
	    	    end							    	    end
        	endcase	// (caddr)				        	endcase	// (caddr)
    	    end else begin					    	    end else begin
	    	serial_xfer <= 1'b0;	// Serial transfer is		    	serial_xfer <= 1'b0;	// Serial transfer is
		irq_spi <= 1'b0;	// IRQ is self-resett			irq_spi <= 1'b0;	// IRQ is self-resett
    	    end							    	    end
    	end							    	end
    end								    end
endmodule	// housekeeping					endmodule	// housekeeping

`default_nettype wire						`default_nettype wire
Only in rtl: ibex_all.v
diff -ry rtl/manual_power_connections.v verilog/rtl/manual_power_connections.v
module manual_power_connections ();				module manual_power_connections ();
endmodule							endmodule
Only in rtl: mgmt_core.v
Only in rtl: mgmt_core_wrapper.v
diff -ry rtl/mgmt_protect_hv.v verilog/rtl/mgmt_protect_hv.v
//`include "dummy_scl180_conb_1.v"			      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      <
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* mgmt_protect_hv:						/* mgmt_protect_hv:					
/*								/*							
/* High voltage (3.3V) part of the mgmt_protect module.  Spli	/* High voltage (3.3V) part of the mgmt_protect module.  Spli
/* a separate module and file so that the synthesis tools can	/* a separate module and file so that the synthesis tools can
/* separately from the rest, since it uses a different standa	/* separately from the rest, since it uses a different standa
/* library.  See the file mgmt_protect.v for a full descripti	/* library.  See the file mgmt_protect.v for a full descripti
/* whole management protection method.				/* whole management protection method.			
/*-----------------------------------------------------------	/*-----------------------------------------------------------

module mgmt_protect_hv (					module mgmt_protect_hv (
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
    inout	vccd,						    inout	vccd,
    inout	vssd,						    inout	vssd,
    inout	vdda1,						    inout	vdda1,
    inout	vssa1,						    inout	vssa1,
    inout	vdda2,						    inout	vdda2,
    inout	vssa2,						    inout	vssa2,
`endif								`endif
*/							      |
    output	mprj_vdd_logic1,				    output	mprj_vdd_logic1,
    output	mprj2_vdd_logic1				    output	mprj2_vdd_logic1

);								);

    wire mprj_vdd_logic1_h;					    wire mprj_vdd_logic1_h;
    wire mprj2_vdd_logic1_h;					    wire mprj2_vdd_logic1_h;

/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
    // This is to emulate the substrate shorting grounds toge	    // This is to emulate the substrate shorting grounds toge
    // purposes							    // purposes
    assign vssa2 = vssa1;					    assign vssa2 = vssa1;
    assign vssa1 = vssd;					    assign vssa1 = vssd;
`endif*/						      |	`endif

    // Logic high in the VDDA (3.3V) domains			    // Logic high in the VDDA (3.3V) domains

    dummy_scl180_conb_1 mprj_logic_high_hvl (		      |	    sky130_fd_sc_hvl__conb_1 mprj_logic_high_hvl (
/*`ifndef USE_POWER_PINS				      |	`ifdef USE_POWER_PINS
        .VPWR(vdda1),						        .VPWR(vdda1),
        .VGND(vssa1),						        .VGND(vssa1),
        .VPB(vdda1),						        .VPB(vdda1),
        .VNB(vssa1),						        .VNB(vssa1),
`endif*/						      |	`endif
        .HI(mprj_vdd_logic1_h),					        .HI(mprj_vdd_logic1_h),
        .LO()							        .LO()
    );								    );

    dummy_scl180_conb_1 mprj2_logic_high_hvl (		      |	    sky130_fd_sc_hvl__conb_1 mprj2_logic_high_hvl (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
        .VPWR(vdda2),						        .VPWR(vdda2),
        .VGND(vssa2),						        .VGND(vssa2),
        .VPB(vdda2),						        .VPB(vdda2),
        .VNB(vssa2),						        .VNB(vssa2),
`endif								`endif
        .HI(mprj2_vdd_logic1_h),				        .HI(mprj2_vdd_logic1_h),
        .LO()							        .LO()
    );								    );

    // Level shift the logic high signals into the 1.8V domai	    // Level shift the logic high signals into the 1.8V domai

/*    sky130_fd_sc_hvl__lsbufhv2lv_1 mprj_logic_high_lv (     |	    sky130_fd_sc_hvl__lsbufhv2lv_1 mprj_logic_high_lv (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
	.VPWR(vdda1),							.VPWR(vdda1),
	.VGND(vssd),							.VGND(vssd),
	.LVPWR(vccd),							.LVPWR(vccd),
	.VPB(vdda1),							.VPB(vdda1),
	.VNB(vssd),							.VNB(vssd),
`endif								`endif
	.X(mprj_vdd_logic1),						.X(mprj_vdd_logic1),
	.A(mprj_vdd_logic1_h)						.A(mprj_vdd_logic1_h)
    );								    );
*/							      <
// we will have level shifting available in the SCL180 I/Os   <
// HIGH-TO-LOW						      <
assign mprj_vdd_logic1 = mprj_vdd_logic1_h;		      <

/*    sky130_fd_sc_hvl__lsbufhv2lv_1 mprj2_logic_high_lv (    |	    sky130_fd_sc_hvl__lsbufhv2lv_1 mprj2_logic_high_lv (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
	.VPWR(vdda2),							.VPWR(vdda2),
	.VGND(vssd),							.VGND(vssd),
	.LVPWR(vccd),							.LVPWR(vccd),
	.VPB(vdda2),							.VPB(vdda2),
	.VNB(vssd),							.VNB(vssd),
`endif								`endif
	.X(mprj2_vdd_logic1),						.X(mprj2_vdd_logic1),
	.A(mprj2_vdd_logic1_h)						.A(mprj2_vdd_logic1_h)
    );								    );
							      <
*/							      <
							      <
// we will have level shifting available in the SCL180 I/Os   <
// HIGH-TO-LOW						      <
assign mprj2_vdd_logic1 = mprj2_vdd_logic1_h;		      <
endmodule							endmodule

`default_nettype wire						`default_nettype wire
diff -ry rtl/mgmt_protect.v verilog/rtl/mgmt_protect.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
							      <
/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* Buffers protecting the management region from the user reg	/* Buffers protecting the management region from the user reg
/* This mainly consists of tristate buffers that are enabled 	/* This mainly consists of tristate buffers that are enabled 
/* "logic 1" output connected to the user's VCCD domain.  Thi	/* "logic 1" output connected to the user's VCCD domain.  Thi
/* that the buffer is disabled and the output high-impedence 	/* that the buffer is disabled and the output high-impedence 
/* user 1.8V supply is absent.					/* user 1.8V supply is absent.				
/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* Because there is no tristate buffer with a non-inverted en	/* Because there is no tristate buffer with a non-inverted en
/* tristate inverter with non-inverted enable is used in seri	/* tristate inverter with non-inverted enable is used in seri
/* another (normal) inverter.					/* another (normal) inverter.				
/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* For the sake of placement/routing, one conb (logic 1) cell	/* For the sake of placement/routing, one conb (logic 1) cell
/* for every buffer.						/* for every buffer.					
/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* 10/3/2022:  Removed tri-state buffers in favor of AND gate	/* 10/3/2022:  Removed tri-state buffers in favor of AND gate
/* if the user project is powered down, then the outputs are 	/* if the user project is powered down, then the outputs are 
/* rather than tristated.  Other explicitly-referenced gates 	/* rather than tristated.  Other explicitly-referenced gates 
/* with the assumption that all outputs will be buffered as n	/* with the assumption that all outputs will be buffered as n
/* the synthesis tools.  Therefore the only restrictions need	/* the synthesis tools.  Therefore the only restrictions need
/* synthesis tools is the list of input signals that must not	/* synthesis tools is the list of input signals that must not
/* buffered because they are allowed to be floating.		/* buffered because they are allowed to be floating.	
/*-----------------------------------------------------------	/*-----------------------------------------------------------

module mgmt_protect (						module mgmt_protect (
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
    inout	  vccd,						    inout	  vccd,
    inout	  vssd,						    inout	  vssd,
    inout	  vccd1,					    inout	  vccd1,
    inout	  vssd1,					    inout	  vssd1,
    inout	  vccd2,					    inout	  vccd2,
    inout	  vssd2,					    inout	  vssd2,
    inout	  vdda1,					    inout	  vdda1,
    inout	  vssa1,					    inout	  vssa1,
    inout	  vdda2,					    inout	  vdda2,
    inout	  vssa2,					    inout	  vssa2,
`endif*/						      |	`endif

    input 	  caravel_clk,					    input 	  caravel_clk,
    input 	  caravel_clk2,					    input 	  caravel_clk2,
    input	  caravel_rstn,					    input	  caravel_rstn,
    input 	  mprj_cyc_o_core,				    input 	  mprj_cyc_o_core,
    input 	  mprj_stb_o_core,				    input 	  mprj_stb_o_core,
    input         mprj_we_o_core,				    input         mprj_we_o_core,
    input [3:0]   mprj_sel_o_core,				    input [3:0]   mprj_sel_o_core,
    input [31:0]  mprj_adr_o_core,				    input [31:0]  mprj_adr_o_core,
    input [31:0]  mprj_dat_o_core,				    input [31:0]  mprj_dat_o_core,
    input [2:0]	  user_irq_core,				    input [2:0]	  user_irq_core,

    output [31:0] mprj_dat_i_core,				    output [31:0] mprj_dat_i_core,
    output	  mprj_ack_i_core,				    output	  mprj_ack_i_core,

    input  	  mprj_iena_wb,		// Enable wishbone fr	    input  	  mprj_iena_wb,		// Enable wishbone fr

    // All signal in/out directions are the reverse of the si	    // All signal in/out directions are the reverse of the si
    // names at the buffer intrface.				    // names at the buffer intrface.

    output [127:0] la_data_in_mprj,				    output [127:0] la_data_in_mprj,
    input  [127:0] la_data_out_mprj,				    input  [127:0] la_data_out_mprj,
    input  [127:0] la_oenb_mprj,				    input  [127:0] la_oenb_mprj,
    input  [127:0] la_iena_mprj,				    input  [127:0] la_iena_mprj,

    input  [127:0] la_data_out_core,				    input  [127:0] la_data_out_core,
    output [127:0] la_data_in_core,				    output [127:0] la_data_in_core,
    output [127:0] la_oenb_core,				    output [127:0] la_oenb_core,

    input  [2:0]  user_irq_ena,					    input  [2:0]  user_irq_ena,

    output 	  user_clock,					    output 	  user_clock,
    output 	  user_clock2,					    output 	  user_clock2,
    output 	  user_reset,					    output 	  user_reset,
    output 	  mprj_cyc_o_user,				    output 	  mprj_cyc_o_user,
    output 	  mprj_stb_o_user,				    output 	  mprj_stb_o_user,
    output 	  mprj_we_o_user,				    output 	  mprj_we_o_user,
    output [3:0]  mprj_sel_o_user,				    output [3:0]  mprj_sel_o_user,
    output [31:0] mprj_adr_o_user,				    output [31:0] mprj_adr_o_user,
    output [31:0] mprj_dat_o_user,				    output [31:0] mprj_dat_o_user,
    input  [31:0] mprj_dat_i_user,				    input  [31:0] mprj_dat_i_user,
    input	  mprj_ack_i_user,				    input	  mprj_ack_i_user,
    output [2:0]  user_irq,					    output [2:0]  user_irq,
    output	  user1_vcc_powergood,				    output	  user1_vcc_powergood,
    output	  user2_vcc_powergood,				    output	  user2_vcc_powergood,
    output	  user1_vdd_powergood,				    output	  user1_vdd_powergood,
    output	  user2_vdd_powergood				    output	  user2_vdd_powergood
);								);

	wire [462:0] mprj_logic1;					wire [462:0] mprj_logic1;
	wire	     mprj2_logic1;					wire	     mprj2_logic1;

	wire mprj_vdd_logic1_h;						wire mprj_vdd_logic1_h;
	wire mprj2_vdd_logic1_h;					wire mprj2_vdd_logic1_h;
	wire mprj_vdd_logic1;						wire mprj_vdd_logic1;
	wire mprj2_vdd_logic1;						wire mprj2_vdd_logic1;


	wire [127:0] la_data_in_mprj_bar;				wire [127:0] la_data_in_mprj_bar;
	wire [2:0] user_irq_bar;					wire [2:0] user_irq_bar;

	wire [127:0] la_data_in_enable;					wire [127:0] la_data_in_enable;
	wire [127:0] la_data_out_enable;				wire [127:0] la_data_out_enable;
	wire [2:0] user_irq_enable;					wire [2:0] user_irq_enable;
	wire 	   wb_in_enable;					wire 	   wb_in_enable;

	wire [31:0] mprj_dat_i_core_bar;				wire [31:0] mprj_dat_i_core_bar;
	wire 	    mprj_ack_i_core_bar;				wire 	    mprj_ack_i_core_bar;

        mprj_logic_high mprj_logic_high_inst (			        mprj_logic_high mprj_logic_high_inst (
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
                .vccd1(vccd1),					                .vccd1(vccd1),
                .vssd1(vssd1),					                .vssd1(vssd1),
`endif*/						      |	`endif
                .HI(mprj_logic1)				                .HI(mprj_logic1)
        );							        );

        mprj2_logic_high mprj2_logic_high_inst (		        mprj2_logic_high mprj2_logic_high_inst (
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
                .vccd2(vccd2),					                .vccd2(vccd2),
                .vssd2(vssd2),					                .vssd2(vssd2),
`endif*/						      |	`endif
                .HI(mprj2_logic1)				                .HI(mprj2_logic1)
        );							        );

	// Logic high in the VDDA (3.3V) domains			// Logic high in the VDDA (3.3V) domains

	mgmt_protect_hv powergood_check (				mgmt_protect_hv powergood_check (
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
	    .vccd(vccd),						    .vccd(vccd),
	    .vssd(vssd),						    .vssd(vssd),
	    .vdda1(vdda1),						    .vdda1(vdda1),
	    .vssa1(vssa1),						    .vssa1(vssa1),
	    .vdda2(vdda2),						    .vdda2(vdda2),
	    .vssa2(vssa2),						    .vssa2(vssa2),
`endif */						      |	`endif
	    .mprj_vdd_logic1(mprj_vdd_logic1),				    .mprj_vdd_logic1(mprj_vdd_logic1),
	    .mprj2_vdd_logic1(mprj2_vdd_logic1)				    .mprj2_vdd_logic1(mprj2_vdd_logic1)
	);								);

	// Buffering from the user side to the management sid		// Buffering from the user side to the management sid
	// NOTE:  This is intended to be better protected, by		// NOTE:  This is intended to be better protected, by
	// chain of an lv-to-hv buffer followed by an hv-to-l		// chain of an lv-to-hv buffer followed by an hv-to-l
	// This serves as a placeholder until that configurat		// This serves as a placeholder until that configurat
	// checked and characterized.  The function below for		// checked and characterized.  The function below for
	// data input to the management core to be a solid lo		// data input to the management core to be a solid lo
	// the user project is powered down.				// the user project is powered down.

	assign la_data_in_enable = la_iena_mprj & mprj_logic1		assign la_data_in_enable = la_iena_mprj & mprj_logic1

	nd02d4 user_to_mprj_in_gates [127:0] (		      |		sky130_fd_sc_hd__nand2_4 user_to_mprj_in_gates [127:0
/*`ifndef USE_POWER_PINS				      |	`ifdef USE_POWER_PINS
                .VPWR(vccd),					                .VPWR(vccd),
                .VGND(vssd),					                .VGND(vssd),
                .VPB(vccd),					                .VPB(vccd),
                .VNB(vssd),					                .VNB(vssd),
`endif */						      |	`endif
		.ZN(la_data_in_mprj_bar),		      |			.Y(la_data_in_mprj_bar),
		.A1(la_data_out_core),		// may be flo |			.A(la_data_out_core),		// may be flo
		.A2(la_data_in_enable)			      |			.B(la_data_in_enable)
	);								);

	assign la_data_in_mprj = ~la_data_in_mprj_bar;			assign la_data_in_mprj = ~la_data_in_mprj_bar;

	// Protection, similar to the above, for the three us		// Protection, similar to the above, for the three us

	assign user_irq_enable = user_irq_ena & mprj_logic1[4		assign user_irq_enable = user_irq_ena & mprj_logic1[4

	nd02d4 user_irq_gates [2:0] (			      |		sky130_fd_sc_hd__nand2_4 user_irq_gates [2:0] (
/*`ifndef USE_POWER_PINS				      |	`ifdef USE_POWER_PINS
                .VPWR(vccd),					                .VPWR(vccd),
                .VGND(vssd),					                .VGND(vssd),
                .VPB(vccd),					                .VPB(vccd),
                .VNB(vssd),					                .VNB(vssd),
`endif */						      |	`endif
		.ZN(user_irq_bar),			      |			.Y(user_irq_bar),
		.A1(user_irq_core),		// may be flo |			.A(user_irq_core),		// may be flo
		.A2(user_irq_enable)			      |			.B(user_irq_enable)
	);								);

	assign user_irq = ~user_irq_bar;				assign user_irq = ~user_irq_bar;

	// Protection, similar to the above, for the return		// Protection, similar to the above, for the return
	// signals from user area to managment on the wishbon		// signals from user area to managment on the wishbon

	assign wb_in_enable = mprj_iena_wb & mprj_logic1[462]		assign wb_in_enable = mprj_iena_wb & mprj_logic1[462]

	nd02d4 user_wb_dat_gates [31:0] (		      |		sky130_fd_sc_hd__nand2_4 user_wb_dat_gates [31:0] (
/*`ifndef USE_POWER_PINS				      |	`ifdef USE_POWER_PINS
                .VPWR(vccd),					                .VPWR(vccd),
                .VGND(vssd),					                .VGND(vssd),
                .VPB(vccd),					                .VPB(vccd),
                .VNB(vssd),					                .VNB(vssd),
`endif */						      |	`endif
		.ZN(mprj_dat_i_core_bar),		      |			.Y(mprj_dat_i_core_bar),
		.A1(mprj_dat_i_user),		// may be flo |			.A(mprj_dat_i_user),		// may be flo
		.A2(wb_in_enable)			      |			.B(wb_in_enable)
	);								);

	assign mprj_dat_i_core = ~mprj_dat_i_core_bar;			assign mprj_dat_i_core = ~mprj_dat_i_core_bar;

	nd02d4 user_wb_ack_gate (			      |		sky130_fd_sc_hd__nand2_4 user_wb_ack_gate (
/*`ifndef USE_POWER_PINS				      |	`ifdef USE_POWER_PINS
                .VPWR(vccd),					                .VPWR(vccd),
                .VGND(vssd),					                .VGND(vssd),
                .VPB(vccd),					                .VPB(vccd),
                .VNB(vssd),					                .VNB(vssd),
`endif*/						      |	`endif
		.ZN(mprj_ack_i_core_bar),		      |			.Y(mprj_ack_i_core_bar),
		.A1(mprj_ack_i_user),		// may be flo |			.A(mprj_ack_i_user),		// may be flo
		.A2(wb_in_enable)			      |			.B(wb_in_enable)
	);								);

	assign mprj_ack_i_core = ~mprj_ack_i_core_bar;			assign mprj_ack_i_core = ~mprj_ack_i_core_bar;

	// The remaining circuitry guards against the managem		// The remaining circuitry guards against the managem
	// SoC dumping current into the user project area whe		// SoC dumping current into the user project area whe
	// the user project area is powered down.			// the user project area is powered down.
									
	assign user_reset      = (~caravel_rstn) & mprj_logic		assign user_reset      = (~caravel_rstn) & mprj_logic
	assign user_clock      = caravel_clk     & mprj_logic		assign user_clock      = caravel_clk     & mprj_logic
	assign user_clock2     = caravel_clk2    & mprj_logic		assign user_clock2     = caravel_clk2    & mprj_logic
	assign mprj_cyc_o_user = mprj_cyc_o_core & mprj_logic		assign mprj_cyc_o_user = mprj_cyc_o_core & mprj_logic
	assign mprj_stb_o_user = mprj_stb_o_core & mprj_logic		assign mprj_stb_o_user = mprj_stb_o_core & mprj_logic
	assign mprj_we_o_user  = mprj_we_o_core  & mprj_logic		assign mprj_we_o_user  = mprj_we_o_core  & mprj_logic
	assign mprj_sel_o_user = mprj_sel_o_core & mprj_logic		assign mprj_sel_o_user = mprj_sel_o_core & mprj_logic
	assign mprj_adr_o_user = mprj_adr_o_core & mprj_logic		assign mprj_adr_o_user = mprj_adr_o_core & mprj_logic
	assign mprj_dat_o_user = mprj_dat_o_core & mprj_logic		assign mprj_dat_o_user = mprj_dat_o_core & mprj_logic

	/* Project data out from the managment side to the us		/* Project data out from the managment side to the us
	/* area when the user project is powered down.			/* area when the user project is powered down.	

	assign la_data_out_enable = (~la_oenb_mprj) & mprj_lo		assign la_data_out_enable = (~la_oenb_mprj) & mprj_lo
	assign la_data_in_core = la_data_out_mprj & la_data_o		assign la_data_in_core = la_data_out_mprj & la_data_o

	/* Project data out enable (bar) from the managment s		/* Project data out enable (bar) from the managment s
	/* user project	area when the user project is powered		/* user project	area when the user project is powered

	assign la_oenb_core = la_oenb_mprj & mprj_logic1[329:		assign la_oenb_core = la_oenb_mprj & mprj_logic1[329:

	/* The conb cell output is a resistive connection dir		/* The conb cell output is a resistive connection dir
	/* the power supply, so when returning the user1_powe		/* the power supply, so when returning the user1_powe
	/* signal, make sure that it is buffered properly.		/* signal, make sure that it is buffered properly.

	assign user1_vcc_powergood = mprj_logic1[461];			assign user1_vcc_powergood = mprj_logic1[461];
	assign user2_vcc_powergood = mprj2_logic1;			assign user2_vcc_powergood = mprj2_logic1;
	assign user1_vdd_powergood = mprj_vdd_logic1;			assign user1_vdd_powergood = mprj_vdd_logic1;
	assign user2_vdd_powergood = mprj2_vdd_logic1;			assign user2_vdd_powergood = mprj2_vdd_logic1;

endmodule							endmodule
`default_nettype wire						`default_nettype wire
diff -ry rtl/mprj2_logic_high.v verilog/rtl/mprj2_logic_high.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

module mprj2_logic_high (					module mprj2_logic_high (
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
    inout	   vccd2,					    inout	   vccd2,
    inout	   vssd2,					    inout	   vssd2,
`endif */						      |	`endif
    output         HI						    output         HI
);								);
dummy_scl180_conb_1 inst (				      |	sky130_fd_sc_hd__conb_1 inst (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
                .VPWR(vccd2),					                .VPWR(vccd2),
                .VGND(vssd2),					                .VGND(vssd2),
                .VPB(vccd2),					                .VPB(vccd2),
                .VNB(vssd2),					                .VNB(vssd2),
`endif								`endif
                .HI(HI),					                .HI(HI),
                .LO()						                .LO()
        );							        );
endmodule							endmodule
diff -ry rtl/mprj_io_buffer.v verilog/rtl/mprj_io_buffer.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0
`default_nettype wire					      |
module mprj_io_buffer (						module mprj_io_buffer (
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
      input VPWR,						      input VPWR,
      input VGND,						      input VGND,
`endif*/						      |	`endif
     input [(`MPRJ_IO_PADS_1-1):0]  mgmt_gpio_in,		     input [(`MPRJ_IO_PADS_1-1):0]  mgmt_gpio_in,
     output [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_in_buf,		     output [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_in_buf,
     input [2:0]   mgmt_gpio_oeb,				     input [2:0]   mgmt_gpio_oeb,
     output [2:0]  mgmt_gpio_oeb_buf,				     output [2:0]  mgmt_gpio_oeb_buf,
     input [(`MPRJ_IO_PADS_1-1):0]  mgmt_gpio_out,		     input [(`MPRJ_IO_PADS_1-1):0]  mgmt_gpio_out,
     output [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_out_buf		     output [(`MPRJ_IO_PADS_1-1):0] mgmt_gpio_out_buf
);								);


buffd7 BUF[(`MPRJ_IO_PADS_2*2+3)-1:0] (			      |	sky130_fd_sc_hd__clkbuf_8 BUF[(`MPRJ_IO_PADS_2*2+3)-1:0] (
    `ifndef USE_POWER_PINS				      |	    `ifdef USE_POWER_PINS
            .VPWR(VPWR),					            .VPWR(VPWR),
            .VGND(VGND),					            .VGND(VGND),
            .VPB(VPWR),						            .VPB(VPWR),
            .VNB(VGND),						            .VNB(VGND),
    `endif							    `endif
		.I({mgmt_gpio_in, mgmt_gpio_oeb, mgmt_gpio_ou |			.A({mgmt_gpio_in, mgmt_gpio_oeb, mgmt_gpio_ou
		.Z({mgmt_gpio_in_buf, mgmt_gpio_oeb_buf, mgmt |			.X({mgmt_gpio_in_buf, mgmt_gpio_oeb_buf, mgmt
); 								); 

endmodule						      /	endmodule
diff -ry rtl/mprj_io.v verilog/rtl/mprj_io.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD	// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

// `default_nettype none					// `default_nettype none



module mprj_io #(						module mprj_io #(
    parameter AREA1PADS = `MPRJ_IO_PADS_1,			    parameter AREA1PADS = `MPRJ_IO_PADS_1,
    parameter TOTAL_PADS = `MPRJ_IO_PADS			    parameter TOTAL_PADS = `MPRJ_IO_PADS
) (								) (
    inout vddio,						    inout vddio,
    inout vssio,						    inout vssio,
    inout vdda,							    inout vdda,
    inout vssa,							    inout vssa,
    inout vccd,							    inout vccd,
    inout vssd,							    inout vssd,

    inout vdda1,						    inout vdda1,
    inout vdda2,						    inout vdda2,
    inout vssa1,						    inout vssa1,
    inout vssa2,						    inout vssa2,

    input vddio_q,						    input vddio_q,
    input vssio_q,						    input vssio_q,
    input analog_a,						    input analog_a,
    input analog_b,						    input analog_b,
    input porb_h,						    input porb_h,
    input [TOTAL_PADS-1:0] vccd_conb,				    input [TOTAL_PADS-1:0] vccd_conb,
    inout [TOTAL_PADS-1:0] io,					    inout [TOTAL_PADS-1:0] io,
    input [TOTAL_PADS-1:0] io_out,				    input [TOTAL_PADS-1:0] io_out,
    input [TOTAL_PADS-1:0] oeb,					    input [TOTAL_PADS-1:0] oeb,
    input [TOTAL_PADS-1:0] enh,					    input [TOTAL_PADS-1:0] enh,
    input [TOTAL_PADS-1:0] inp_dis,				    input [TOTAL_PADS-1:0] inp_dis,
    input [TOTAL_PADS-1:0] ib_mode_sel,				    input [TOTAL_PADS-1:0] ib_mode_sel,
    input [TOTAL_PADS-1:0] vtrip_sel,				    input [TOTAL_PADS-1:0] vtrip_sel,
    input [TOTAL_PADS-1:0] slow_sel,				    input [TOTAL_PADS-1:0] slow_sel,
    input [TOTAL_PADS-1:0] holdover,				    input [TOTAL_PADS-1:0] holdover,
    input [TOTAL_PADS-1:0] analog_en,				    input [TOTAL_PADS-1:0] analog_en,
    input [TOTAL_PADS-1:0] analog_sel,				    input [TOTAL_PADS-1:0] analog_sel,
    input [TOTAL_PADS-1:0] analog_pol,				    input [TOTAL_PADS-1:0] analog_pol,
    input [TOTAL_PADS*3-1:0] dm,				    input [TOTAL_PADS*3-1:0] dm,
    output [TOTAL_PADS-1:0] io_in,				    output [TOTAL_PADS-1:0] io_in,
    output [TOTAL_PADS-1:0] io_in_3v3,				    output [TOTAL_PADS-1:0] io_in_3v3,
    inout [TOTAL_PADS-10:0] analog_io,				    inout [TOTAL_PADS-10:0] analog_io,
    inout [TOTAL_PADS-10:0] analog_noesd_io			    inout [TOTAL_PADS-10:0] analog_noesd_io
);								);

    wire [TOTAL_PADS-1:0] loop0_io;	// Internal loopback 	    wire [TOTAL_PADS-1:0] loop0_io;	// Internal loopback 
    wire [TOTAL_PADS-1:0] loop1_io;	// Internal loopback 	    wire [TOTAL_PADS-1:0] loop1_io;	// Internal loopback 
    wire [6:0] no_connect_1a, no_connect_1b;			    wire [6:0] no_connect_1a, no_connect_1b;
    wire [1:0] no_connect_2a, no_connect_2b;			    wire [1:0] no_connect_2a, no_connect_2b;



    //pc3b03ed_wrapper area1_io_pad [AREA1PADS - 1:0]( .Y_COR	    //pc3b03ed_wrapper area1_io_pad [AREA1PADS - 1:0]( .Y_COR
 								 
    pc3b03ed_wrapper area1_io_pad [AREA1PADS - 1:0]( .IN(io_i	    pc3b03ed_wrapper area1_io_pad [AREA1PADS - 1:0]( .IN(io_i
   // pc3b03ed_wrapper area_1_io_pad_i( .Y_CORE(io_in[0]), .X	   // pc3b03ed_wrapper area_1_io_pad_i( .Y_CORE(io_in[0]), .X
    //pc3b03ed_wrapper area_1_io_pad_making_inp [1]( .Y_CORE(	    //pc3b03ed_wrapper area_1_io_pad_making_inp [1]( .Y_CORE(
   // pc3d01 area_1_io_pad_making_inp( .CIN(io_in[1]), .PAD(i	   // pc3d01 area_1_io_pad_making_inp( .CIN(io_in[1]), .PAD(i
    pc3b03ed_wrapper area2_io_pad [TOTAL_PADS - 1:AREA1PADS](	    pc3b03ed_wrapper area2_io_pad [TOTAL_PADS - 1:AREA1PADS](
   								   
   /* sky130_ef_io__gpiov2_pad_wrapped  area1_io_pad [AREA1PA	   /* sky130_ef_io__gpiov2_pad_wrapped  area1_io_pad [AREA1PA
	`USER1_ABUTMENT_PINS						`USER1_ABUTMENT_PINS
	`ifndef	TOP_ROUTING						`ifndef	TOP_ROUTING
	    .PAD(io[AREA1PADS - 1:0]),					    .PAD(io[AREA1PADS - 1:0]),
	`endif								`endif
	    .OUT(io_out[AREA1PADS - 1:0]),				    .OUT(io_out[AREA1PADS - 1:0]),
	    .OE_N(oeb[AREA1PADS - 1:0]),				    .OE_N(oeb[AREA1PADS - 1:0]),
	    .HLD_H_N(loop1_io[AREA1PADS - 1:0]),			    .HLD_H_N(loop1_io[AREA1PADS - 1:0]),
	    .ENABLE_H(enh[AREA1PADS - 1:0]),				    .ENABLE_H(enh[AREA1PADS - 1:0]),
	    .ENABLE_INP_H(loop0_io[AREA1PADS - 1:0]),			    .ENABLE_INP_H(loop0_io[AREA1PADS - 1:0]),
	    .ENABLE_VDDA_H(porb_h),					    .ENABLE_VDDA_H(porb_h),
	    .ENABLE_VSWITCH_H(loop0_io[AREA1PADS - 1:0]),		    .ENABLE_VSWITCH_H(loop0_io[AREA1PADS - 1:0]),
	    .ENABLE_VDDIO(vccd_conb[AREA1PADS - 1:0]),			    .ENABLE_VDDIO(vccd_conb[AREA1PADS - 1:0]),
	    .INP_DIS(inp_dis[AREA1PADS - 1:0]),				    .INP_DIS(inp_dis[AREA1PADS - 1:0]),
	    .IB_MODE_SEL(ib_mode_sel[AREA1PADS - 1:0]),			    .IB_MODE_SEL(ib_mode_sel[AREA1PADS - 1:0]),
	    .VTRIP_SEL(vtrip_sel[AREA1PADS - 1:0]),			    .VTRIP_SEL(vtrip_sel[AREA1PADS - 1:0]),
	    .SLOW(slow_sel[AREA1PADS - 1:0]),				    .SLOW(slow_sel[AREA1PADS - 1:0]),
	    .HLD_OVR(holdover[AREA1PADS - 1:0]),			    .HLD_OVR(holdover[AREA1PADS - 1:0]),
	    .ANALOG_EN(analog_en[AREA1PADS - 1:0]),			    .ANALOG_EN(analog_en[AREA1PADS - 1:0]),
	    .ANALOG_SEL(analog_sel[AREA1PADS - 1:0]),			    .ANALOG_SEL(analog_sel[AREA1PADS - 1:0]),
	    .ANALOG_POL(analog_pol[AREA1PADS - 1:0]),			    .ANALOG_POL(analog_pol[AREA1PADS - 1:0]),
	    .DM(dm[AREA1PADS*3 - 1:0]),					    .DM(dm[AREA1PADS*3 - 1:0]),
	    .PAD_A_NOESD_H({analog_noesd_io[AREA1PADS - 8:0],		    .PAD_A_NOESD_H({analog_noesd_io[AREA1PADS - 8:0],
	    .PAD_A_ESD_0_H({analog_io[AREA1PADS - 8:0], no_co		    .PAD_A_ESD_0_H({analog_io[AREA1PADS - 8:0], no_co
	    .PAD_A_ESD_1_H(),						    .PAD_A_ESD_1_H(),
	    .IN(io_in[AREA1PADS - 1:0]),				    .IN(io_in[AREA1PADS - 1:0]),
	    .IN_H(io_in_3v3[AREA1PADS - 1:0]),				    .IN_H(io_in_3v3[AREA1PADS - 1:0]),
	    .TIE_HI_ESD(loop1_io[AREA1PADS - 1:0]),			    .TIE_HI_ESD(loop1_io[AREA1PADS - 1:0]),
	    .TIE_LO_ESD(loop0_io[AREA1PADS - 1:0])			    .TIE_LO_ESD(loop0_io[AREA1PADS - 1:0])
    );								    );

    sky130_ef_io__gpiov2_pad_wrapped area2_io_pad [TOTAL_PADS	    sky130_ef_io__gpiov2_pad_wrapped area2_io_pad [TOTAL_PADS
	`USER2_ABUTMENT_PINS						`USER2_ABUTMENT_PINS
	`ifndef	TOP_ROUTING						`ifndef	TOP_ROUTING
	    .PAD(io[TOTAL_PADS - 1:AREA1PADS]),				    .PAD(io[TOTAL_PADS - 1:AREA1PADS]),
	`endif								`endif
	    .OUT(io_out[TOTAL_PADS - 1:AREA1PADS]),			    .OUT(io_out[TOTAL_PADS - 1:AREA1PADS]),
	    .OE_N(oeb[TOTAL_PADS - 1:AREA1PADS]),			    .OE_N(oeb[TOTAL_PADS - 1:AREA1PADS]),
	    .HLD_H_N(loop1_io[TOTAL_PADS - 1:AREA1PADS]),		    .HLD_H_N(loop1_io[TOTAL_PADS - 1:AREA1PADS]),
	    .ENABLE_H(enh[TOTAL_PADS - 1:AREA1PADS]),			    .ENABLE_H(enh[TOTAL_PADS - 1:AREA1PADS]),
	    .ENABLE_INP_H(loop0_io[TOTAL_PADS - 1:AREA1PADS])		    .ENABLE_INP_H(loop0_io[TOTAL_PADS - 1:AREA1PADS])
	    .ENABLE_VDDA_H(porb_h),					    .ENABLE_VDDA_H(porb_h),
	    .ENABLE_VSWITCH_H(loop0_io[TOTAL_PADS - 1:AREA1PA		    .ENABLE_VSWITCH_H(loop0_io[TOTAL_PADS - 1:AREA1PA
	    .ENABLE_VDDIO(vccd_conb[TOTAL_PADS - 1:AREA1PADS]		    .ENABLE_VDDIO(vccd_conb[TOTAL_PADS - 1:AREA1PADS]
	    .INP_DIS(inp_dis[TOTAL_PADS - 1:AREA1PADS]),		    .INP_DIS(inp_dis[TOTAL_PADS - 1:AREA1PADS]),
	    .IB_MODE_SEL(ib_mode_sel[TOTAL_PADS - 1:AREA1PADS		    .IB_MODE_SEL(ib_mode_sel[TOTAL_PADS - 1:AREA1PADS
	    .VTRIP_SEL(vtrip_sel[TOTAL_PADS - 1:AREA1PADS]),		    .VTRIP_SEL(vtrip_sel[TOTAL_PADS - 1:AREA1PADS]),
	    .SLOW(slow_sel[TOTAL_PADS - 1:AREA1PADS]),			    .SLOW(slow_sel[TOTAL_PADS - 1:AREA1PADS]),
	    .HLD_OVR(holdover[TOTAL_PADS - 1:AREA1PADS]),		    .HLD_OVR(holdover[TOTAL_PADS - 1:AREA1PADS]),
	    .ANALOG_EN(analog_en[TOTAL_PADS - 1:AREA1PADS]),		    .ANALOG_EN(analog_en[TOTAL_PADS - 1:AREA1PADS]),
	    .ANALOG_SEL(analog_sel[TOTAL_PADS - 1:AREA1PADS])		    .ANALOG_SEL(analog_sel[TOTAL_PADS - 1:AREA1PADS])
	    .ANALOG_POL(analog_pol[TOTAL_PADS - 1:AREA1PADS])		    .ANALOG_POL(analog_pol[TOTAL_PADS - 1:AREA1PADS])
	    .DM(dm[TOTAL_PADS*3 - 1:AREA1PADS*3]),			    .DM(dm[TOTAL_PADS*3 - 1:AREA1PADS*3]),
	    .PAD_A_NOESD_H({no_connect_2a, analog_noesd_io[TO		    .PAD_A_NOESD_H({no_connect_2a, analog_noesd_io[TO
	    .PAD_A_ESD_0_H({no_connect_2b, analog_io[TOTAL_PA		    .PAD_A_ESD_0_H({no_connect_2b, analog_io[TOTAL_PA
	    .PAD_A_ESD_1_H(),						    .PAD_A_ESD_1_H(),
	    .IN(io_in[TOTAL_PADS - 1:AREA1PADS]),			    .IN(io_in[TOTAL_PADS - 1:AREA1PADS]),
	    .IN_H(io_in_3v3[TOTAL_PADS - 1:AREA1PADS]),			    .IN_H(io_in_3v3[TOTAL_PADS - 1:AREA1PADS]),
	    .TIE_HI_ESD(loop1_io[TOTAL_PADS - 1:AREA1PADS]),		    .TIE_HI_ESD(loop1_io[TOTAL_PADS - 1:AREA1PADS]),
	    .TIE_LO_ESD(loop0_io[TOTAL_PADS - 1:AREA1PADS])		    .TIE_LO_ESD(loop0_io[TOTAL_PADS - 1:AREA1PADS])
    );								    );
*/								*/
endmodule							endmodule
// `default_nettype wire					// `default_nettype wire
diff -ry rtl/mprj_logic_high.v verilog/rtl/mprj_logic_high.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

module mprj_logic_high (					module mprj_logic_high (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    inout	   vccd1,					    inout	   vccd1,
    inout	   vssd1,					    inout	   vssd1,
`endif								`endif
    output [462:0] HI						    output [462:0] HI
);								);
dummy_scl180_conb_1 insts [462:0] (			      |	sky130_fd_sc_hd__conb_1 insts [462:0] (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
                .VPWR(vccd1),					                .VPWR(vccd1),
                .VGND(vssd1),					                .VGND(vssd1),
                .VPB(vccd1),					                .VPB(vccd1),
                .VNB(vssd1),					                .VNB(vssd1),
`endif								`endif
                .HI(HI),					                .HI(HI),
                .LO()						                .LO()
        );							        );
endmodule							endmodule
Only in verilog/rtl: openframe_netlists.v
diff -ry rtl/__openframe_project_wrapper.v verilog/rtl/__openframe_project_wrapper.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
/*								/*
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 *								 *
 * openframe_project_wrapper					 * openframe_project_wrapper
 *								 *
 * This wrapper enumerates all of the pins available to the	 * This wrapper enumerates all of the pins available to the
 * user for the user openframe project.				 * user for the user openframe project.
 *								 *
 * Written by Tim Edwards					 * Written by Tim Edwards
 * March 27, 2023						 * March 27, 2023
 * Efabless Corporation						 * Efabless Corporation
 *								 *
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 */								 */

module openframe_project_wrapper (				module openframe_project_wrapper (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    inout vdda,		// User area 0 3.3V supply		    inout vdda,		// User area 0 3.3V supply
    inout vdda1,	// User area 1 3.3V supply		    inout vdda1,	// User area 1 3.3V supply
    inout vdda2,	// User area 2 3.3V supply		    inout vdda2,	// User area 2 3.3V supply
    inout vssa,		// User area 0 analog ground		    inout vssa,		// User area 0 analog ground
    inout vssa1,	// User area 1 analog ground		    inout vssa1,	// User area 1 analog ground
    inout vssa2,	// User area 2 analog ground		    inout vssa2,	// User area 2 analog ground
    inout vccd,		// Common 1.8V supply			    inout vccd,		// Common 1.8V supply
    inout vccd1,	// User area 1 1.8V supply		    inout vccd1,	// User area 1 1.8V supply
    inout vccd2,	// User area 2 1.8v supply		    inout vccd2,	// User area 2 1.8v supply
    inout vssd,		// Common digital ground		    inout vssd,		// Common digital ground
    inout vssd1,	// User area 1 digital ground		    inout vssd1,	// User area 1 digital ground
    inout vssd2,	// User area 2 digital ground		    inout vssd2,	// User area 2 digital ground
							      >	    inout vddio,	// Common 3.3V ESD supply
							      >	    inout vssio,	// Common ESD ground
`endif								`endif

    /* Signals exported from the frame area to the user proje	    /* Signals exported from the frame area to the user proje
    /* The user may elect to use any of these inputs.		    /* The user may elect to use any of these inputs.	

    input	 porb_h,	// power-on reset, sense inve	    input	 porb_h,	// power-on reset, sense inve
    input	 porb_l,	// power-on reset, sense inve	    input	 porb_l,	// power-on reset, sense inve
    input	 por_l,		// power-on reset, noninverte	    input	 por_l,		// power-on reset, noninverte
    input	 resetb_h,	// master reset, sense invert	    input	 resetb_h,	// master reset, sense invert
    input	 resetb_l,	// master reset, sense invert	    input	 resetb_l,	// master reset, sense invert
    input [31:0] mask_rev,	// 32-bit user ID, 1.8V domai	    input [31:0] mask_rev,	// 32-bit user ID, 1.8V domai

    /* GPIOs.  There are 44 GPIOs (19 left, 19 right, 6 botto	    /* GPIOs.  There are 44 GPIOs (19 left, 19 right, 6 botto
    /* These must be configured appropriately by the user pro	    /* These must be configured appropriately by the user pro

    /* Basic bidirectional I/O.  Input gpio_in_h is in the 3.	    /* Basic bidirectional I/O.  Input gpio_in_h is in the 3.
     * others are in the 1.8v domain.  OEB is output enable, 	     * others are in the 1.8v domain.  OEB is output enable, 
     */								     */
    input  [`OPENFRAME_IO_PADS-1:0] gpio_in,			    input  [`OPENFRAME_IO_PADS-1:0] gpio_in,
    input  [`OPENFRAME_IO_PADS-1:0] gpio_in_h,			    input  [`OPENFRAME_IO_PADS-1:0] gpio_in_h,
    output [`OPENFRAME_IO_PADS-1:0] gpio_out,			    output [`OPENFRAME_IO_PADS-1:0] gpio_out,
    output [`OPENFRAME_IO_PADS-1:0] gpio_oeb,			    output [`OPENFRAME_IO_PADS-1:0] gpio_oeb,

    /* Pad configuration.  These signals are usually static v	    /* Pad configuration.  These signals are usually static v
     * See the documentation for the sky130_fd_io__gpiov2 cel	     * See the documentation for the sky130_fd_io__gpiov2 cel
     * and their use.						     * and their use.
     */								     */
    output [`OPENFRAME_IO_PADS-1:0] gpio_inp_dis,		    output [`OPENFRAME_IO_PADS-1:0] gpio_inp_dis,
    output [`OPENFRAME_IO_PADS-1:0] gpio_ib_mode_sel,		    output [`OPENFRAME_IO_PADS-1:0] gpio_ib_mode_sel,
    output [`OPENFRAME_IO_PADS-1:0] gpio_vtrip_sel,		    output [`OPENFRAME_IO_PADS-1:0] gpio_vtrip_sel,
    output [`OPENFRAME_IO_PADS-1:0] gpio_slow_sel,		    output [`OPENFRAME_IO_PADS-1:0] gpio_slow_sel,
    output [`OPENFRAME_IO_PADS-1:0] gpio_holdover,		    output [`OPENFRAME_IO_PADS-1:0] gpio_holdover,
    output [`OPENFRAME_IO_PADS-1:0] gpio_analog_en,		    output [`OPENFRAME_IO_PADS-1:0] gpio_analog_en,
    output [`OPENFRAME_IO_PADS-1:0] gpio_analog_sel,		    output [`OPENFRAME_IO_PADS-1:0] gpio_analog_sel,
    output [`OPENFRAME_IO_PADS-1:0] gpio_analog_pol,		    output [`OPENFRAME_IO_PADS-1:0] gpio_analog_pol,
    output [`OPENFRAME_IO_PADS-1:0] gpio_dm2,			    output [`OPENFRAME_IO_PADS-1:0] gpio_dm2,
    output [`OPENFRAME_IO_PADS-1:0] gpio_dm1,			    output [`OPENFRAME_IO_PADS-1:0] gpio_dm1,
    output [`OPENFRAME_IO_PADS-1:0] gpio_dm0,			    output [`OPENFRAME_IO_PADS-1:0] gpio_dm0,

    /* These signals correct directly to the pad.  Pads using	    /* These signals correct directly to the pad.  Pads using
     * connections should keep the digital input and output b	     * connections should keep the digital input and output b
     * off.  Both signals connect to the same pad.  The "noes	     * off.  Both signals connect to the same pad.  The "noes
     * is a direct connection to the pad;  the other signal c	     * is a direct connection to the pad;  the other signal c
     * a series resistor which gives it minimal ESD protectio	     * a series resistor which gives it minimal ESD protectio
     * have basic over- and under-voltage protection at the p	     * have basic over- and under-voltage protection at the p
     * signals may be expected to attenuate heavily above 50M	     * signals may be expected to attenuate heavily above 50M
     */								     */
    inout  [`OPENFRAME_IO_PADS-1:0] analog_io,			    inout  [`OPENFRAME_IO_PADS-1:0] analog_io,
    inout  [`OPENFRAME_IO_PADS-1:0] analog_noesd_io,		    inout  [`OPENFRAME_IO_PADS-1:0] analog_noesd_io,

    /* These signals are constant one and zero in the 1.8V do	    /* These signals are constant one and zero in the 1.8V do
     * each GPIO pad, and can be looped back to the control s	     * each GPIO pad, and can be looped back to the control s
     * same GPIO pad to set a static configuration at power-u	     * same GPIO pad to set a static configuration at power-u
     */								     */
    input  [`OPENFRAME_IO_PADS-1:0] gpio_loopback_one,		    input  [`OPENFRAME_IO_PADS-1:0] gpio_loopback_one,
    input  [`OPENFRAME_IO_PADS-1:0] gpio_loopback_zero		    input  [`OPENFRAME_IO_PADS-1:0] gpio_loopback_zero
);								);

`ifdef OPENFRAME_TESTING					`ifdef OPENFRAME_TESTING
	openframe_example test_example (				openframe_example test_example (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
		.vdda(vdda),							.vdda(vdda),
		.vdda1(vdda1),							.vdda1(vdda1),
		.vdda2(vdda2),							.vdda2(vdda2),
		.vssa(vssa),							.vssa(vssa),
		.vssa1(vssa1),							.vssa1(vssa1),
		.vssa2(vssa2),							.vssa2(vssa2),
		.vccd(vccd),							.vccd(vccd),
		.vccd1(vccd1),							.vccd1(vccd1),
		.vccd2(vccd2),							.vccd2(vccd2),
		.vssd(vssd),							.vssd(vssd),
		.vssd1(vssd1),							.vssd1(vssd1),
		.vssd2(vssd2),							.vssd2(vssd2),
							      >			.vddio(vddio),
							      >			.vssio(vssio),
`endif								`endif
	    .porb_h(porb_h),						    .porb_h(porb_h),
	    .porb_l(porb_l),						    .porb_l(porb_l),
	    .por_l(por_l),						    .por_l(por_l),
	    .resetb_h(resetb_h),					    .resetb_h(resetb_h),
	    .resetb_l(resetb_l),					    .resetb_l(resetb_l),
	    .mask_rev(mask_rev),					    .mask_rev(mask_rev),
	    .gpio_in(gpio_in),						    .gpio_in(gpio_in),
	    .gpio_in_h(gpio_in_h),					    .gpio_in_h(gpio_in_h),
	    .gpio_out(gpio_out),					    .gpio_out(gpio_out),
	    .gpio_oeb(gpio_oeb),					    .gpio_oeb(gpio_oeb),
	    .gpio_inp_dis(gpio_inp_dis),				    .gpio_inp_dis(gpio_inp_dis),
	    .gpio_ib_mode_sel(gpio_ib_mode_sel),			    .gpio_ib_mode_sel(gpio_ib_mode_sel),
	    .gpio_vtrip_sel(gpio_vtrip_sel),				    .gpio_vtrip_sel(gpio_vtrip_sel),
	    .gpio_slow_sel(gpio_slow_sel),				    .gpio_slow_sel(gpio_slow_sel),
	    .gpio_holdover(gpio_holdover),				    .gpio_holdover(gpio_holdover),
	    .gpio_analog_en(gpio_analog_en),				    .gpio_analog_en(gpio_analog_en),
	    .gpio_analog_sel(gpio_analog_sel),				    .gpio_analog_sel(gpio_analog_sel),
	    .gpio_analog_pol(gpio_analog_pol),				    .gpio_analog_pol(gpio_analog_pol),
	    .gpio_dm2(gpio_dm2),					    .gpio_dm2(gpio_dm2),
	    .gpio_dm1(gpio_dm1),					    .gpio_dm1(gpio_dm1),
	    .gpio_dm0(gpio_dm0),					    .gpio_dm0(gpio_dm0),
	    .analog_io(analog_io),					    .analog_io(analog_io),
	    .analog_noesd_io(analog_noesd_io),				    .analog_noesd_io(analog_noesd_io),
	    .gpio_loopback_one(gpio_loopback_one),			    .gpio_loopback_one(gpio_loopback_one),
	    .gpio_loopback_zero(gpio_loopback_zero)			    .gpio_loopback_zero(gpio_loopback_zero)
	);								);
`endif								`endif

endmodule	// openframe_project_wrapper			endmodule	// openframe_project_wrapper
diff -ry rtl/open_source.v verilog/rtl/open_source.v
module open_source ();						module open_source ();
endmodule							endmodule
diff -ry rtl/pads.v verilog/rtl/pads.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

// `default_nettype none					// `default_nettype none
`ifndef TOP_ROUTING 						`ifndef TOP_ROUTING 
	`define USER1_ABUTMENT_PINS \					`define USER1_ABUTMENT_PINS \
	.AMUXBUS_A(analog_a),\						.AMUXBUS_A(analog_a),\
	.AMUXBUS_B(analog_b),\				      |		.AMUXBUS_B(analog_b),`ifdef USE_POWER_PINS\
	.VSSA(vssa1),\							.VSSA(vssa1),\
	.VDDA(vdda1),\							.VDDA(vdda1),\
	.VSWITCH(vddio),\						.VSWITCH(vddio),\
	.VDDIO_Q(vddio_q),\						.VDDIO_Q(vddio_q),\
	.VCCHIB(vccd),\							.VCCHIB(vccd),\
	.VDDIO(vddio),\							.VDDIO(vddio),\
	.VCCD(vccd),\							.VCCD(vccd),\
	.VSSIO(vssio),\							.VSSIO(vssio),\
	.VSSD(vssd),\							.VSSD(vssd),\
	.VSSIO_Q(vssio_q),				      |		.VSSIO_Q(vssio_q),`endif

	`define USER2_ABUTMENT_PINS \					`define USER2_ABUTMENT_PINS \
	.AMUXBUS_A(analog_a),\						.AMUXBUS_A(analog_a),\
	.AMUXBUS_B(analog_b),\				      |		.AMUXBUS_B(analog_b),`ifdef USE_POWER_PINS\
	.VSSA(vssa2),\							.VSSA(vssa2),\
	.VDDA(vdda2),\							.VDDA(vdda2),\
	.VSWITCH(vddio),\						.VSWITCH(vddio),\
	.VDDIO_Q(vddio_q),\						.VDDIO_Q(vddio_q),\
	.VCCHIB(vccd),\							.VCCHIB(vccd),\
	.VDDIO(vddio),\							.VDDIO(vddio),\
	.VCCD(vccd),\							.VCCD(vccd),\
	.VSSIO(vssio),\							.VSSIO(vssio),\
	.VSSD(vssd),\							.VSSD(vssd),\
	.VSSIO_Q(vssio_q),				      |		.VSSIO_Q(vssio_q),`endif

	`define MGMT_ABUTMENT_PINS \					`define MGMT_ABUTMENT_PINS \
	.AMUXBUS_A(analog_a),\						.AMUXBUS_A(analog_a),\
	.AMUXBUS_B(analog_b),\				      |		.AMUXBUS_B(analog_b), `ifdef USE_POWER_PINS \
	.VSSA(vssa),\							.VSSA(vssa),\
	.VDDA(vdda),\							.VDDA(vdda),\
	.VSWITCH(vddio),\						.VSWITCH(vddio),\
	.VDDIO_Q(vddio_q),\						.VDDIO_Q(vddio_q),\
	.VCCHIB(vccd),\							.VCCHIB(vccd),\
	.VDDIO(vddio),\							.VDDIO(vddio),\
	.VCCD(vccd),\							.VCCD(vccd),\
	.VSSIO(vssio),\							.VSSIO(vssio),\
	.VSSD(vssd),\							.VSSD(vssd),\
	.VSSIO_Q(vssio_q),				      |		.VSSIO_Q(vssio_q), `endif
`else 								`else 
	`define USER1_ABUTMENT_PINS 					`define USER1_ABUTMENT_PINS 
	`define USER2_ABUTMENT_PINS 					`define USER2_ABUTMENT_PINS 
	`define MGMT_ABUTMENT_PINS 					`define MGMT_ABUTMENT_PINS 
`endif								`endif

`define HVCLAMP_PINS(H,L) \					`define HVCLAMP_PINS(H,L) \
	.DRN_HVC(H), \							.DRN_HVC(H), \
	.SRC_BDY_HVC(L)							.SRC_BDY_HVC(L)

`define LVCLAMP_PINS(H1,L1,H2,L2,L3) \				`define LVCLAMP_PINS(H1,L1,H2,L2,L3) \
	.BDY2_B2B(L3), \						.BDY2_B2B(L3), \
	.DRN_LVC1(H1), \						.DRN_LVC1(H1), \
	.DRN_LVC2(H2), \						.DRN_LVC2(H2), \
	.SRC_BDY_LVC1(L1), \						.SRC_BDY_LVC1(L1), \
	.SRC_BDY_LVC2(L2)						.SRC_BDY_LVC2(L2)

`define INPUT_PAD(X,Y,CONB_ONE,CONB_ZERO) \			`define INPUT_PAD(X,Y,CONB_ONE,CONB_ZERO) \
	wire loop_zero_``X; \						wire loop_zero_``X; \
	wire loop_one_``X; \						wire loop_one_``X; \
	sky130_ef_io__gpiov2_pad_wrapped X``_pad ( \			sky130_ef_io__gpiov2_pad_wrapped X``_pad ( \
	`MGMT_ABUTMENT_PINS \						`MGMT_ABUTMENT_PINS \
	`ifndef	TOP_ROUTING \						`ifndef	TOP_ROUTING \
		.PAD(X), \							.PAD(X), \
	`endif	\							`endif	\
		.OUT(CONB_ZERO), \						.OUT(CONB_ZERO), \
		.OE_N(CONB_ONE), \						.OE_N(CONB_ONE), \
		.HLD_H_N(loop_one_``X), \					.HLD_H_N(loop_one_``X), \
		.ENABLE_H(porb_h), \						.ENABLE_H(porb_h), \
		.ENABLE_INP_H(loop_zero_``X), \					.ENABLE_INP_H(loop_zero_``X), \
		.ENABLE_VDDA_H(porb_h), \					.ENABLE_VDDA_H(porb_h), \
		.ENABLE_VSWITCH_H(loop_zero_``X), \				.ENABLE_VSWITCH_H(loop_zero_``X), \
		.ENABLE_VDDIO(CONB_ONE), \					.ENABLE_VDDIO(CONB_ONE), \
		.INP_DIS(por), \						.INP_DIS(por), \
		.IB_MODE_SEL(CONB_ZERO), \					.IB_MODE_SEL(CONB_ZERO), \
		.VTRIP_SEL(CONB_ZERO), \					.VTRIP_SEL(CONB_ZERO), \
		.SLOW(CONB_ZERO),	\					.SLOW(CONB_ZERO),	\
		.HLD_OVR(CONB_ZERO), \						.HLD_OVR(CONB_ZERO), \
		.ANALOG_EN(CONB_ZERO), \					.ANALOG_EN(CONB_ZERO), \
		.ANALOG_SEL(CONB_ZERO), \					.ANALOG_SEL(CONB_ZERO), \
		.ANALOG_POL(CONB_ZERO), \					.ANALOG_POL(CONB_ZERO), \
		.DM({CONB_ZERO, CONB_ZERO, CONB_ONE}), \			.DM({CONB_ZERO, CONB_ZERO, CONB_ONE}), \
		.PAD_A_NOESD_H(), \						.PAD_A_NOESD_H(), \
		.PAD_A_ESD_0_H(), \						.PAD_A_ESD_0_H(), \
		.PAD_A_ESD_1_H(), \						.PAD_A_ESD_1_H(), \
		.IN(Y), \							.IN(Y), \
		.IN_H(), \							.IN_H(), \
		.TIE_HI_ESD(loop_one_``X), \					.TIE_HI_ESD(loop_one_``X), \
		.TIE_LO_ESD(loop_zero_``X) )					.TIE_LO_ESD(loop_zero_``X) )

							      <
`define INPUT_PAD_SCL(X,Y) \				      <
         pc3d01 X``_PAD ( \				      <
	 .CIN(Y), \					      <
	 .PAD(X) )					      <
							      <
							      <
							      <
							      <
							      <
`define OUTPUT_PAD(X,Y,CONB_ONE,CONB_ZERO,INPUT_DIS,OUT_EN_N)	`define OUTPUT_PAD(X,Y,CONB_ONE,CONB_ZERO,INPUT_DIS,OUT_EN_N)
	wire loop_zero_``X; \						wire loop_zero_``X; \
	wire loop_one_``X; \						wire loop_one_``X; \
	sky130_ef_io__gpiov2_pad_wrapped X``_pad ( \			sky130_ef_io__gpiov2_pad_wrapped X``_pad ( \
	`MGMT_ABUTMENT_PINS \						`MGMT_ABUTMENT_PINS \
	`ifndef	TOP_ROUTING \						`ifndef	TOP_ROUTING \
		.PAD(X), \							.PAD(X), \
	`endif \							`endif \
		.OUT(Y), \							.OUT(Y), \
		.OE_N(OUT_EN_N), \						.OE_N(OUT_EN_N), \
		.HLD_H_N(loop_one_``X), \					.HLD_H_N(loop_one_``X), \
		.ENABLE_H(porb_h),	\					.ENABLE_H(porb_h),	\
		.ENABLE_INP_H(loop_zero_``X), \					.ENABLE_INP_H(loop_zero_``X), \
		.ENABLE_VDDA_H(porb_h), \					.ENABLE_VDDA_H(porb_h), \
		.ENABLE_VSWITCH_H(loop_zero_``X), \				.ENABLE_VSWITCH_H(loop_zero_``X), \
		.ENABLE_VDDIO(CONB_ONE), \					.ENABLE_VDDIO(CONB_ONE), \
		.INP_DIS(INPUT_DIS), \						.INP_DIS(INPUT_DIS), \
		.IB_MODE_SEL(CONB_ZERO), \					.IB_MODE_SEL(CONB_ZERO), \
		.VTRIP_SEL(CONB_ZERO), \					.VTRIP_SEL(CONB_ZERO), \
		.SLOW(CONB_ZERO),	\					.SLOW(CONB_ZERO),	\
		.HLD_OVR(CONB_ZERO), \						.HLD_OVR(CONB_ZERO), \
		.ANALOG_EN(CONB_ZERO), \					.ANALOG_EN(CONB_ZERO), \
		.ANALOG_SEL(CONB_ZERO), \					.ANALOG_SEL(CONB_ZERO), \
		.ANALOG_POL(CONB_ZERO), \					.ANALOG_POL(CONB_ZERO), \
		.DM({CONB_ONE, CONB_ONE, CONB_ZERO}),	\			.DM({CONB_ONE, CONB_ONE, CONB_ZERO}),	\
		.PAD_A_NOESD_H(), \						.PAD_A_NOESD_H(), \
		.PAD_A_ESD_0_H(), \						.PAD_A_ESD_0_H(), \
		.PAD_A_ESD_1_H(), \						.PAD_A_ESD_1_H(), \
		.IN(), \							.IN(), \
		.IN_H(), \							.IN_H(), \
		.TIE_HI_ESD(loop_one_``X), \					.TIE_HI_ESD(loop_one_``X), \
		.TIE_LO_ESD(loop_zero_``X)) 					.TIE_LO_ESD(loop_zero_``X)) 

`define OUTPUT_NO_INP_DIS_PAD(X,Y,CONB_ONE,CONB_ZERO,OUT_EN_N	`define OUTPUT_NO_INP_DIS_PAD(X,Y,CONB_ONE,CONB_ZERO,OUT_EN_N
	wire loop_zero_``X; \						wire loop_zero_``X; \
	wire loop_one_``X; \						wire loop_one_``X; \
	sky130_ef_io__gpiov2_pad_wrapped X``_pad ( \			sky130_ef_io__gpiov2_pad_wrapped X``_pad ( \
	`MGMT_ABUTMENT_PINS \						`MGMT_ABUTMENT_PINS \
	`ifndef	TOP_ROUTING \						`ifndef	TOP_ROUTING \
		.PAD(X), \							.PAD(X), \
	`endif \							`endif \
		.OUT(Y), \							.OUT(Y), \
		.OE_N(OUT_EN_N), \						.OE_N(OUT_EN_N), \
		.HLD_H_N(loop_one_``X), \					.HLD_H_N(loop_one_``X), \
		.ENABLE_H(porb_h),	\					.ENABLE_H(porb_h),	\
		.ENABLE_INP_H(loop_zero_``X), \					.ENABLE_INP_H(loop_zero_``X), \
		.ENABLE_VDDA_H(porb_h), \					.ENABLE_VDDA_H(porb_h), \
		.ENABLE_VSWITCH_H(loop_zero_``X), \				.ENABLE_VSWITCH_H(loop_zero_``X), \
		.ENABLE_VDDIO(CONB_ONE), \					.ENABLE_VDDIO(CONB_ONE), \
		.INP_DIS(CONB_ZERO), \						.INP_DIS(CONB_ZERO), \
		.IB_MODE_SEL(CONB_ZERO), \					.IB_MODE_SEL(CONB_ZERO), \
		.VTRIP_SEL(CONB_ZERO), \					.VTRIP_SEL(CONB_ZERO), \
		.SLOW(CONB_ZERO),	\					.SLOW(CONB_ZERO),	\
		.HLD_OVR(CONB_ZERO), \						.HLD_OVR(CONB_ZERO), \
		.ANALOG_EN(CONB_ZERO), \					.ANALOG_EN(CONB_ZERO), \
		.ANALOG_SEL(CONB_ZERO), \					.ANALOG_SEL(CONB_ZERO), \
		.ANALOG_POL(CONB_ZERO), \					.ANALOG_POL(CONB_ZERO), \
		.DM({CONB_ONE, CONB_ONE, CONB_ZERO}), \				.DM({CONB_ONE, CONB_ONE, CONB_ZERO}), \
		.PAD_A_NOESD_H(), \						.PAD_A_NOESD_H(), \
		.PAD_A_ESD_0_H(), \						.PAD_A_ESD_0_H(), \
		.PAD_A_ESD_1_H(), \						.PAD_A_ESD_1_H(), \
		.IN(), \							.IN(), \
		.IN_H(), \							.IN_H(), \
		.TIE_HI_ESD(loop_one_``X), \					.TIE_HI_ESD(loop_one_``X), \
		.TIE_LO_ESD(loop_zero_``X)) 					.TIE_LO_ESD(loop_zero_``X)) 

							      <
`define OUTPUT_NO_INP_DIS_SCL(X, Y,OUT_EN_N) \		      <
	pt3b02 X``_pad( \				      <
	.CIN(Y), \					      <
	.OEN(OUT_EN_N), \				      <
	.I(), \						      <
	.PAD(X) )					      <
							      <
							      <
`define INOUT_PAD(X,Y,CONB_ONE,CONB_ZERO,Y_OUT,INPUT_DIS,OUT_	`define INOUT_PAD(X,Y,CONB_ONE,CONB_ZERO,Y_OUT,INPUT_DIS,OUT_
	wire loop_zero_``X; \						wire loop_zero_``X; \
	wire loop_one_``X; \						wire loop_one_``X; \
	sky130_ef_io__gpiov2_pad_wrapped X``_pad ( \			sky130_ef_io__gpiov2_pad_wrapped X``_pad ( \
	`MGMT_ABUTMENT_PINS \						`MGMT_ABUTMENT_PINS \
	`ifndef	TOP_ROUTING \						`ifndef	TOP_ROUTING \
		.PAD(X), \							.PAD(X), \
	`endif	\							`endif	\
		.OUT(Y_OUT),	\						.OUT(Y_OUT),	\
		.OE_N(OUT_EN_N), \						.OE_N(OUT_EN_N), \
		.HLD_H_N(loop_one_``X),	\					.HLD_H_N(loop_one_``X),	\
		.ENABLE_H(porb_h), \						.ENABLE_H(porb_h), \
		.ENABLE_INP_H(loop_zero_``X), \					.ENABLE_INP_H(loop_zero_``X), \
		.ENABLE_VDDA_H(porb_h), \					.ENABLE_VDDA_H(porb_h), \
		.ENABLE_VSWITCH_H(loop_zero_``X), \				.ENABLE_VSWITCH_H(loop_zero_``X), \
		.ENABLE_VDDIO(CONB_ONE), \					.ENABLE_VDDIO(CONB_ONE), \
		.INP_DIS(INPUT_DIS), \						.INP_DIS(INPUT_DIS), \
		.IB_MODE_SEL(CONB_ZERO), \					.IB_MODE_SEL(CONB_ZERO), \
		.VTRIP_SEL(CONB_ZERO), \					.VTRIP_SEL(CONB_ZERO), \
		.SLOW(CONB_ZERO),	\					.SLOW(CONB_ZERO),	\
		.HLD_OVR(CONB_ZERO), \						.HLD_OVR(CONB_ZERO), \
		.ANALOG_EN(CONB_ZERO), \					.ANALOG_EN(CONB_ZERO), \
		.ANALOG_SEL(CONB_ZERO), \					.ANALOG_SEL(CONB_ZERO), \
		.ANALOG_POL(CONB_ZERO), \					.ANALOG_POL(CONB_ZERO), \
		.DM(MODE), \							.DM(MODE), \
		.PAD_A_NOESD_H(), \						.PAD_A_NOESD_H(), \
		.PAD_A_ESD_0_H(), \						.PAD_A_ESD_0_H(), \
		.PAD_A_ESD_1_H(), \						.PAD_A_ESD_1_H(), \
		.IN(Y),  \							.IN(Y),  \
		.IN_H(), \							.IN_H(), \
		.TIE_HI_ESD(loop_one_``X), \					.TIE_HI_ESD(loop_one_``X), \
		.TIE_LO_ESD(loop_zero_``X) )					.TIE_LO_ESD(loop_zero_``X) )

							      <
/*`define INOUT_PAD_SCL(X, Y, Y_CORE ,INPUT_DIS, OUT_EN_N, dm <
	pc3b03ed_wrapper Y``_pad( \			      <
		.Y_CORE(Y_CORE), \			      <
		.X(X), \				      <
		.Y(Y), \				      <
		.INPUT_DIS(INPUT_DIS), \		      <
	        .OUT_EN_N(OUT_EN_N), \			      <
                 .dm(dm) )				      <
*/							      <
// `default_nettype wire					// `default_nettype wire
Only in rtl: pc3b03ed.v
diff -ry rtl/pc3b03ed_wrapper.v verilog/rtl/pc3b03ed_wrapper.v
// SPDX-FileCopyrightText: 2025 VSD				// SPDX-FileCopyrightText: 2025 VSD
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* Vsdcaravel, RISC-V SoC Implementation using Synopsys and S	/* Vsdcaravel, RISC-V SoC Implementation using Synopsys and S
/* a project for the VSD/Semiconductor Laboratory SCL180	/* a project for the VSD/Semiconductor Laboratory SCL180
/* fabrication process 			                     	/* fabrication process 			                     
/*                                                          	/*                                                          
/* Copyright 2025 VSD                           	     	/* Copyright 2025 VSD                           	     
/* Originally written by Bharat                              	/* Originally written by Bharat                              
/* 			    	                             	/* 			    	                             
/* Edited by Dhanvanti Bhavsar and Kunal Ghosh on (11/02/2025	/* Edited by Dhanvanti Bhavsar and Kunal Ghosh on (11/02/2025
/* Updated on 11/02/2025:  Revised using SCL180 PDK	     	/* Updated on 11/02/2025:  Revised using SCL180 PDK	     
/* This file is open source hardware released under the     	/* This file is open source hardware released under the     
/* Apache 2.0 license.  See file LICENSE.                   	/* Apache 2.0 license.  See file LICENSE.                   
/* from housekeeping.v (refactoring a number of functions fro	/* from housekeeping.v (refactoring a number of functions fro
/* the management SoC).						/* the management SoC).					
/*                                                          	/*                                                          
/*-----------------------------------------------------------	/*-----------------------------------------------------------



//`include "pc3b03ed.v"						//`include "pc3b03ed.v"
module pc3b03ed_wrapper(OUT, PAD, IN, INPUT_DIS, OUT_EN_N, dm	module pc3b03ed_wrapper(OUT, PAD, IN, INPUT_DIS, OUT_EN_N, dm
output  IN;							output  IN;
input   OUT, INPUT_DIS, OUT_EN_N;				input   OUT, INPUT_DIS, OUT_EN_N;
inout   PAD;							inout   PAD;
input [2:0]dm;							input [2:0]dm;


wire output_EN_N;						wire output_EN_N;
wire pull_down_enb;						wire pull_down_enb;

//assign output_EN_N = (dm[2:0] != 3'b110 && ~OUT_EN_N) && ((	//assign output_EN_N = (dm[2:0] != 3'b110 && ~OUT_EN_N) && ((

assign output_EN_N = (~INPUT_DIS && (dm[2:0] == 3'b001)) || O	assign output_EN_N = (~INPUT_DIS && (dm[2:0] == 3'b001)) || O
//assign output_EN_N = (OUT_EN_N == 1'b0) ? 1'b0 : 1'b1;	//assign output_EN_N = (OUT_EN_N == 1'b0) ? 1'b0 : 1'b1;
assign pull_down_enb = (dm[2:0] == 3'b000);			assign pull_down_enb = (dm[2:0] == 3'b000);


pc3b03ed pad(.CIN( IN ),					pc3b03ed pad(.CIN( IN ),
		.OEN(output_EN_N),						.OEN(output_EN_N),
		.RENB(pull_down_enb),						.RENB(pull_down_enb),
		.I(OUT),							.I(OUT),
		.PAD(PAD));							.PAD(PAD));
endmodule 							endmodule 
Only in rtl: pc3d01.v
Only in rtl: pc3d01_wrapper.v
Only in rtl: pc3d21.v
Only in rtl: picorv32.v
Only in rtl: primitives.v
Only in rtl: pt3b02.v
Only in rtl: pt3b02_wrapper.v
Only in rtl: pv0a.v
Only in rtl: pv0i.v
Only in rtl: pvda.v
Only in rtl: pvdi.v
Only in rtl: RAM128.v
Only in rtl: RAM256.v
diff -ry rtl/ring_osc2x13.v verilog/rtl/ring_osc2x13.v
`ifdef SIM							`ifdef SIM
`include "/home/Synopsys/pdk/SCL_PDK_3/SCLPDK_V3.0_KIT/scl180	`include "/home/Synopsys/pdk/SCL_PDK_3/SCLPDK_V3.0_KIT/scl180
`endif								`endif
`include "dummy_scl180_conb_1.v"				`include "dummy_scl180_conb_1.v"
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD	// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire						`default_nettype wire
// Tunable ring oscillator---synthesizable (physical) version	// Tunable ring oscillator---synthesizable (physical) version
//								//
// NOTE:  This netlist cannot be simulated correctly due to l	// NOTE:  This netlist cannot be simulated correctly due to l
// of accurate timing in the digital cell verilog models.	// of accurate timing in the digital cell verilog models.

module delay_stage(in, trim, out);				module delay_stage(in, trim, out);
    input in;							    input in;
    input [1:0] trim;						    input [1:0] trim;
    output out;							    output out;

    wire d0, d1, d2, ts;					    wire d0, d1, d2, ts;

    wire dummy_dsig1, dummy_dsig2;				    wire dummy_dsig1, dummy_dsig2;

    bufbd2 delaybuf0 (						    bufbd2 delaybuf0 (
	.I(in),								.I(in),
	.Z(ts)								.Z(ts)
    );								    );

    bufbdf delaybuf1 (						    bufbdf delaybuf1 (
	.I(ts),								.I(ts),
	.Z(d0)								.Z(d0)
    );								    );

    // adding extra inverter to match for scl180		    // adding extra inverter to match for scl180
    inv0d1 dummyinv1 (						    inv0d1 dummyinv1 (
	    .I(trim[1]),						    .I(trim[1]),
	    .ZN(dummy_dsig1)						    .ZN(dummy_dsig1)
    );								    );

    invtd2 delayen1 (						    invtd2 delayen1 (
	.I(d0),								.I(d0),
	.EN(dummy_dsig1),						.EN(dummy_dsig1),
	.ZN(d1)								.ZN(d1)
    );								    );

    invtd4 delayenb1 (						    invtd4 delayenb1 (
	.I(ts),								.I(ts),
	.EN(trim[1]),							.EN(trim[1]),
	.ZN(d1)								.ZN(d1)
    );								    );

    invbd2  delayint0 (						    invbd2  delayint0 (
	.I(d1),								.I(d1),
	.ZN(d2)								.ZN(d2)
    );								    );



    // adding extra inverter to match for scl180		    // adding extra inverter to match for scl180
    inv0d1 dummyinv2 (						    inv0d1 dummyinv2 (
	    .I(trim[0]),						    .I(trim[0]),
	    .ZN(dummy_dsig2)						    .ZN(dummy_dsig2)
    );								    );

    invtd2 delayen0 (						    invtd2 delayen0 (
	.I(d2),								.I(d2),
	.EN(dummy_dsig2),						.EN(dummy_dsig2),
	.ZN(out)							.ZN(out)
    );								    );

    invtd7 delayenb0 (						    invtd7 delayenb0 (
	.I(ts),								.I(ts),
	.EN(trim[0]),							.EN(trim[0]),
	.ZN(out)							.ZN(out)
    );								    );

endmodule							endmodule

module start_stage(in, trim, reset, out);			module start_stage(in, trim, reset, out);
    input in;							    input in;
    input [1:0] trim;						    input [1:0] trim;
    input reset;						    input reset;
    output out;							    output out;

    wire d0, d1, d2, ctrl0, one;				    wire d0, d1, d2, ctrl0, one;

    wire dummy_ssig1, dummy_ssig2, dummy_ssig3;			    wire dummy_ssig1, dummy_ssig2, dummy_ssig3;

    bufbdf delaybuf0 (						    bufbdf delaybuf0 (
	.I(in),								.I(in),
	.Z(d0)								.Z(d0)
    );								    );
    								    
    // adding extra inverter to match for scl180		    // adding extra inverter to match for scl180
    inv0d1 dummyinv1 (						    inv0d1 dummyinv1 (
	    .I(trim[1]),						    .I(trim[1]),
	    .ZN(dummy_ssig2)						    .ZN(dummy_ssig2)
    );								    );

    invtd2 delayen1 (						    invtd2 delayen1 (
	.I(d0),								.I(d0),
	.EN(dummy_ssig2),						.EN(dummy_ssig2),
	.ZN(d1)								.ZN(d1)
    );								    );

    invtd4 delayenb1 (						    invtd4 delayenb1 (
	.I(in),								.I(in),
	.EN(trim[1]),							.EN(trim[1]),
	.ZN(d1)								.ZN(d1)
    );								    );

    invbd2 delayint0 (						    invbd2 delayint0 (
	.I(d1),								.I(d1),
	.ZN(d2)								.ZN(d2)
    );								    );

    // adding extra inverter to match for scl180		    // adding extra inverter to match for scl180
    inv0d1 dummyinv2 (						    inv0d1 dummyinv2 (
	    .I(trim[0]),						    .I(trim[0]),
	    .ZN(dummy_ssig3)						    .ZN(dummy_ssig3)
    );								    );

    invtd2 delayen0 (						    invtd2 delayen0 (
	.I(d2),								.I(d2),
	.EN(dummy_ssig3),						.EN(dummy_ssig3),
	.ZN(out)							.ZN(out)
    );								    );

    invtd7 delayenb0 (						    invtd7 delayenb0 (
	.I(in),								.I(in),
	.EN(ctrl0),							.EN(ctrl0),
	.ZN(out)							.ZN(out)
    );								    );

   // adding extra inveter to match for scl180			   // adding extra inveter to match for scl180
    inv0d1 dummyinv0 (						    inv0d1 dummyinv0 (
	    .I(reset),							    .I(reset),
	    .ZN(dummy_ssig1)						    .ZN(dummy_ssig1)
    );								    );



    invtd1 reseten0 (						    invtd1 reseten0 (
	.I(one),							.I(one),
	.EN(dummy_ssig1),						.EN(dummy_ssig1),
	.ZN(out)							.ZN(out)
    );								    );

    or02d2 ctrlen0 (						    or02d2 ctrlen0 (
	.A1(reset),							.A1(reset),
	.A2(trim[0]),							.A2(trim[0]),
	.Z(ctrl0)							.Z(ctrl0)
    );								    );

    dummy_scl180_conb_1 const1 (				    dummy_scl180_conb_1 const1 (
	.HI(one),							.HI(one),
	.LO()								.LO()
    );								    );

endmodule							endmodule

// Ring oscillator with 13 stages, each with two trim bits de	// Ring oscillator with 13 stages, each with two trim bits de
// (see above).  Trim is not binary:  For trim[1:0], lower bi	// (see above).  Trim is not binary:  For trim[1:0], lower bi
// trim[0] is primary trim and must be applied first;  upper	// trim[0] is primary trim and must be applied first;  upper
// bit trim[1] is secondary trim and should only be applied	// bit trim[1] is secondary trim and should only be applied
// after the primary trim is applied, or it has no effect.	// after the primary trim is applied, or it has no effect.
//								//
// Total effective number of inverter stages in this oscillat	// Total effective number of inverter stages in this oscillat
// ranges from 13 at trim 0 to 65 at trim 24.  The intention 	// ranges from 13 at trim 0 to 65 at trim 24.  The intention 
// to cover a range greater than 2x so that the midrange can 	// to cover a range greater than 2x so that the midrange can 
// reached over all PVT conditions.				// reached over all PVT conditions.
//								//
// Frequency of this ring oscillator under SPICE simulations 	// Frequency of this ring oscillator under SPICE simulations 
// nominal PVT is maximum 214 MHz (trim 0), minimum 90 MHz (t	// nominal PVT is maximum 214 MHz (trim 0), minimum 90 MHz (t

module ring_osc2x13(reset, trim, clockp);			module ring_osc2x13(reset, trim, clockp);
    input reset;						    input reset;
    input [25:0] trim;						    input [25:0] trim;
    output[1:0] clockp;						    output[1:0] clockp;

	// !FUNCTIONAL;  i.e., gate level netlist below			// !FUNCTIONAL;  i.e., gate level netlist below

    wire [1:0] clockp;						    wire [1:0] clockp;
    wire [12:0] d;						    wire [12:0] d;
    wire [1:0] c;						    wire [1:0] c;

    // Main oscillator loop stages				    // Main oscillator loop stages
 								 
    genvar i;							    genvar i;
    generate							    generate
	for (i = 0; i < 12; i = i + 1) begin : dstage			for (i = 0; i < 12; i = i + 1) begin : dstage
	    delay_stage id (						    delay_stage id (
		.in(d[i]),							.in(d[i]),
		.trim({trim[i+13], trim[i]}),					.trim({trim[i+13], trim[i]}),
		.out(d[i+1])							.out(d[i+1])
	    );								    );
	end								end
    endgenerate							    endgenerate

    // Reset/startup stage					    // Reset/startup stage
 								 
    start_stage iss (						    start_stage iss (
	.in(d[12]),							.in(d[12]),
	.trim({trim[25], trim[12]}),					.trim({trim[25], trim[12]}),
	.reset(reset),							.reset(reset),
	.out(d[0])							.out(d[0])
    );								    );

    // Buffered outputs a 0 and 90 degrees phase (approximate	    // Buffered outputs a 0 and 90 degrees phase (approximate

    invbd4 ibufp00 (						    invbd4 ibufp00 (
	.I(d[0]),							.I(d[0]),
	.ZN(c[0])							.ZN(c[0])
    );								    );
    invbd7 ibufp01 (						    invbd7 ibufp01 (
	.I(c[0]),							.I(c[0]),
	.ZN(clockp[0])							.ZN(clockp[0])
    );								    );
    invbd4 ibufp10 (						    invbd4 ibufp10 (
	.I(d[6]),							.I(d[6]),
	.ZN(c[1])							.ZN(c[1])
    );								    );
    invbd7 ibufp11 (						    invbd7 ibufp11 (
	.I(c[1]),							.I(c[1]),
	.ZN(clockp[1])							.ZN(clockp[1])
    );								    );
 // !FUNCTIONAL							 // !FUNCTIONAL

endmodule							endmodule
`default_nettype wire						`default_nettype wire
Only in rtl: scl180_macro_sparecell.v
Only in verilog/rtl: simple_por.v
diff -ry rtl/spare_logic_block.v verilog/rtl/spare_logic_block.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none

// Spare logic block.  This block can be used for metal mask 	// Spare logic block.  This block can be used for metal mask 
// a design.  It is much larger and more comprehensive than t	// a design.  It is much larger and more comprehensive than t
// "macro_sparecell" in the HD library, and contains flops, t	// "macro_sparecell" in the HD library, and contains flops, t
// and diodes in addition to the inverters, NOR, NAND, and co	// and diodes in addition to the inverters, NOR, NAND, and co
// gates provided by macro_sparecell.				// gates provided by macro_sparecell.

module spare_logic_block (					module spare_logic_block (
 /*   `ifdef USE_POWER_PINS				      |	    `ifdef USE_POWER_PINS
        inout vccd,						        inout vccd,
        inout vssd,						        inout vssd,
    `endif*/						      |	    `endif

    output [26:0] spare_xz,	// Constant 0 outputs (and bl	    output [26:0] spare_xz,	// Constant 0 outputs (and bl
    output [3:0]  spare_xi,	// Inverter outputs		    output [3:0]  spare_xi,	// Inverter outputs
    output	  spare_xib,	// Big inverter output		    output	  spare_xib,	// Big inverter output
    output [1:0]  spare_xna,	// NAND outputs			    output [1:0]  spare_xna,	// NAND outputs
    output [1:0]  spare_xno,	// NOR outputs			    output [1:0]  spare_xno,	// NOR outputs
    output [1:0]  spare_xmx,	// Mux outputs			    output [1:0]  spare_xmx,	// Mux outputs
    output [1:0]  spare_xfq,	// Flop noninverted output	    output [1:0]  spare_xfq,	// Flop noninverted output
    output [1:0]  spare_xfqn 	// Flop inverted output		    output [1:0]  spare_xfqn 	// Flop inverted output
);								);

    wire [3:0] spare_logic_nc;					    wire [3:0] spare_logic_nc;

    wire [26:0] spare_logic1;					    wire [26:0] spare_logic1;
    wire [26:0] spare_logic0;					    wire [26:0] spare_logic0;

    // Rename the logic0 outputs at the block pins.		    // Rename the logic0 outputs at the block pins.
    assign spare_xz = spare_logic0;				    assign spare_xz = spare_logic0;

    dummy_scl180_conb_1 spare_logic_const [26:0] (	      |	    sky130_fd_sc_hd__conb_1 spare_logic_const [26:0] (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
	`endif								`endif
            .HI(spare_logic1),					            .HI(spare_logic1),
            .LO(spare_logic0)					            .LO(spare_logic0)
    );								    );

     inv0d2 spare_logic_inv [3:0] (			      |	    sky130_fd_sc_hd__inv_2 spare_logic_inv [3:0] (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
	`endif								`endif
            .ZN(spare_xi),				      |	            .Y(spare_xi),
            .I(spare_logic0[3:0])			      |	            .A(spare_logic0[3:0])
    );								    );

     inv0d7 spare_logic_biginv (			      |	    sky130_fd_sc_hd__inv_8 spare_logic_biginv (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
	`endif								`endif
            .ZN(spare_xib),				      |	            .Y(spare_xib),
            .I(spare_logic0[4])				      |	            .A(spare_logic0[4])
    );								    );

    nd02d2 spare_logic_nand [1:0] (			      |	    sky130_fd_sc_hd__nand2_2 spare_logic_nand [1:0] (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
	`endif								`endif
            .ZN(spare_xna),				      |	            .Y(spare_xna),
            .A1(spare_logic0[6:5]),			      |	            .A(spare_logic0[6:5]),
            .A2(spare_logic0[8:7])			      |	            .B(spare_logic0[8:7])
    );								    );

    nr02d2 spare_logic_nor [1:0] (			      |	    sky130_fd_sc_hd__nor2_2 spare_logic_nor [1:0] (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
	`endif								`endif
            .ZN(spare_xno),				      |	            .Y(spare_xno),
            .A1(spare_logic0[10:9]),			      |	            .A(spare_logic0[10:9]),
            .A2(spare_logic0[12:11])			      |	            .B(spare_logic0[12:11])
    );								    );

    mx02d2 spare_logic_mux [1:0] (			      |	    sky130_fd_sc_hd__mux2_2 spare_logic_mux [1:0] (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
	`endif								`endif
            .Z(spare_xmx),				      |	            .X(spare_xmx),
            .I0(spare_logic0[14:13]),			      |	            .A0(spare_logic0[14:13]),
            .I1(spare_logic0[16:15]),			      |	            .A1(spare_logic0[16:15]),
            .S(spare_logic0[18:17])				            .S(spare_logic0[18:17])
    );								    );

    dfbrb1 spare_logic_flop [1:0] (			      |	    sky130_fd_sc_hd__dfbbp_1 spare_logic_flop [1:0] (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
	`endif								`endif
            .Q(spare_xfq),					            .Q(spare_xfq),
            .QN(spare_xfqn),				      |	            .Q_N(spare_xfqn),
            .D(spare_logic0[20:19]),				            .D(spare_logic0[20:19]),
            .CP(spare_logic0[22:21]),			      |	            .CLK(spare_logic0[22:21]),
            .SDN(spare_logic0[24:23]),			      |	            .SET_B(spare_logic0[24:23]),
            .CDN(spare_logic0[26:25])			      |	            .RESET_B(spare_logic0[26:25])
    );								    );

/*    sky130_fd_sc_hd__tapvpwrvgnd_1 spare_logic_tap [1:0] (  |	    sky130_fd_sc_hd__tapvpwrvgnd_1 spare_logic_tap [1:0] (
	`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd)						            .VNB(vssd)
	`endif								`endif
    );								    );
*/							      <
// don't find the need of this - CONFIRMATION TO NEEDED - TIM <

    adiode spare_logic_diode [3:0] (			      |	    sky130_fd_sc_hd__diode_2 spare_logic_diode [3:0] (
	`ifndef USE_POWER_PINS				      |		`ifdef USE_POWER_PINS
            .VPWR(vccd),					            .VPWR(vccd),
            .VGND(vssd),					            .VGND(vssd),
            .VPB(vccd),						            .VPB(vccd),
            .VNB(vssd),						            .VNB(vssd),
	`endif								`endif
	    .I(spare_logic_nc)				      |		    .DIODE(spare_logic_nc)
    );								    );
 								 
endmodule							endmodule
`default_nettype wire						`default_nettype wire
Only in rtl: spiflash.v
Only in verilog/rtl: toplevel_cocotb.v
Only in verilog/rtl: __uprj_analog_netlists.v
diff -ry rtl/__uprj_netlists.v verilog/rtl/__uprj_netlists.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0
/*-----------------------------------------------------------	/*-----------------------------------------------------------
/* caravel, a project harness for the Google/SkyWater sky130	/* caravel, a project harness for the Google/SkyWater sky130
/* fabrication process and open source PDK			/* fabrication process and open source PDK		
/*                                                          	/*                                                          
/* Copyright 2020 efabless, Inc.                            	/* Copyright 2020 efabless, Inc.                            
/* Written by Tim Edwards, December 2019                    	/* Written by Tim Edwards, December 2019                    
/* and Mohamed Shalan, August 2020			    	/* and Mohamed Shalan, August 2020			    
/* This file is open source hardware released under the     	/* This file is open source hardware released under the     
/* Apache 2.0 license.  See file LICENSE.                   	/* Apache 2.0 license.  See file LICENSE.                   
/*                                                          	/*                                                          
/*-----------------------------------------------------------	/*-----------------------------------------------------------

`define USE_POWER_PINS						`define USE_POWER_PINS

`include "defines.v"						`include "defines.v"

`ifdef GL							`ifdef GL
	`include "gl/__user_project_wrapper.v"		      |		`include "../gl/__user_project_wrapper.v"
`else								`else
    `include "__user_project_wrapper.v"				    `include "__user_project_wrapper.v"
`endif							      \	`endif
diff -ry rtl/__user_analog_project_wrapper.v verilog/rtl/__user_analog_project_wrapper.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
/*								/*
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 *								 *
 * user_analog_project_wrapper					 * user_analog_project_wrapper
 *								 *
 * This wrapper enumerates all of the pins available to the	 * This wrapper enumerates all of the pins available to the
 * user for the user analog project.				 * user for the user analog project.
 *								 *
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 */								 */
 								 
/// sta-blackbox						/// sta-blackbox
module user_analog_project_wrapper (				module user_analog_project_wrapper (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    inout vdda1,	// User area 1 3.3V supply		    inout vdda1,	// User area 1 3.3V supply
    inout vdda2,	// User area 2 3.3V supply		    inout vdda2,	// User area 2 3.3V supply
    inout vssa1,	// User area 1 analog ground		    inout vssa1,	// User area 1 analog ground
    inout vssa2,	// User area 2 analog ground		    inout vssa2,	// User area 2 analog ground
    inout vccd1,	// User area 1 1.8V supply		    inout vccd1,	// User area 1 1.8V supply
    inout vccd2,	// User area 2 1.8v supply		    inout vccd2,	// User area 2 1.8v supply
    inout vssd1,	// User area 1 digital ground		    inout vssd1,	// User area 1 digital ground
    inout vssd2,	// User area 2 digital ground		    inout vssd2,	// User area 2 digital ground
`endif								`endif

    // Wishbone Slave ports (WB MI A)				    // Wishbone Slave ports (WB MI A)
    input wb_clk_i,						    input wb_clk_i,
    input wb_rst_i,						    input wb_rst_i,
    input wbs_stb_i,						    input wbs_stb_i,
    input wbs_cyc_i,						    input wbs_cyc_i,
    input wbs_we_i,						    input wbs_we_i,
    input [3:0] wbs_sel_i,					    input [3:0] wbs_sel_i,
    input [31:0] wbs_dat_i,					    input [31:0] wbs_dat_i,
    input [31:0] wbs_adr_i,					    input [31:0] wbs_adr_i,
    output wbs_ack_o,						    output wbs_ack_o,
    output [31:0] wbs_dat_o,					    output [31:0] wbs_dat_o,

    // Logic Analyzer Signals					    // Logic Analyzer Signals
    input  [127:0] la_data_in,					    input  [127:0] la_data_in,
    output [127:0] la_data_out,					    output [127:0] la_data_out,
    input  [127:0] la_oenb,					    input  [127:0] la_oenb,

    /* GPIOs.  There are 27 GPIOs, on either side of the anal	    /* GPIOs.  There are 27 GPIOs, on either side of the anal
     * These have the following mapping to the GPIO padframe 	     * These have the following mapping to the GPIO padframe 
     * and memory-mapped registers, since the numbering remai	     * and memory-mapped registers, since the numbering remai
     * same as caravel but skips over the analog I/O:		     * same as caravel but skips over the analog I/O:
     *								     *
     * io_in/out/oeb/in_3v3 [26:14]  <--->  mprj_io[37:25]	     * io_in/out/oeb/in_3v3 [26:14]  <--->  mprj_io[37:25]
     * io_in/out/oeb/in_3v3 [13:0]   <--->  mprj_io[13:0]	     * io_in/out/oeb/in_3v3 [13:0]   <--->  mprj_io[13:0]
     *								     *
     * When the GPIOs are configured by the Management SoC fo	     * When the GPIOs are configured by the Management SoC fo
     * user use, they have three basic bidirectional controls	     * user use, they have three basic bidirectional controls
     * in, out, and oeb (output enable, sense inverted).  For	     * in, out, and oeb (output enable, sense inverted).  For
     * analog projects, a 3.3V copy of the signal input is	     * analog projects, a 3.3V copy of the signal input is
     * available.  out and oeb must be 1.8V signals.		     * available.  out and oeb must be 1.8V signals.
     */								     */

    input  [`MPRJ_IO_PADS-`ANALOG_PADS-1:0] io_in,		    input  [`MPRJ_IO_PADS-`ANALOG_PADS-1:0] io_in,
    input  [`MPRJ_IO_PADS-`ANALOG_PADS-1:0] io_in_3v3,		    input  [`MPRJ_IO_PADS-`ANALOG_PADS-1:0] io_in_3v3,
    output [`MPRJ_IO_PADS-`ANALOG_PADS-1:0] io_out,		    output [`MPRJ_IO_PADS-`ANALOG_PADS-1:0] io_out,
    output [`MPRJ_IO_PADS-`ANALOG_PADS-1:0] io_oeb,		    output [`MPRJ_IO_PADS-`ANALOG_PADS-1:0] io_oeb,

    /* Analog (direct connection to GPIO pad---not for high v	    /* Analog (direct connection to GPIO pad---not for high v
     * high frequency use).  The management SoC must turn off	     * high frequency use).  The management SoC must turn off
     * input and output buffers on these GPIOs to allow analo	     * input and output buffers on these GPIOs to allow analo
     * These signals may drive a voltage up to the value of V	     * These signals may drive a voltage up to the value of V
     * (3.3V typical, 5.5V maximum).				     * (3.3V typical, 5.5V maximum).
     * 								     * 
     * Note that analog I/O is not available on the 7 lowest-	     * Note that analog I/O is not available on the 7 lowest-
     * GPIO pads, and so the analog_io indexing is offset fro	     * GPIO pads, and so the analog_io indexing is offset fro
     * GPIO indexing by 7, as follows:				     * GPIO indexing by 7, as follows:
     *								     *
     * gpio_analog/noesd [17:7]  <--->  mprj_io[35:25]		     * gpio_analog/noesd [17:7]  <--->  mprj_io[35:25]
     * gpio_analog/noesd [6:0]   <--->  mprj_io[13:7]		     * gpio_analog/noesd [6:0]   <--->  mprj_io[13:7]	
     *								     *
     */								     */
    								    
    inout [`MPRJ_IO_PADS-`ANALOG_PADS-10:0] gpio_analog,	    inout [`MPRJ_IO_PADS-`ANALOG_PADS-10:0] gpio_analog,
    inout [`MPRJ_IO_PADS-`ANALOG_PADS-10:0] gpio_noesd,		    inout [`MPRJ_IO_PADS-`ANALOG_PADS-10:0] gpio_noesd,

    /* Analog signals, direct through to pad.  These have no 	    /* Analog signals, direct through to pad.  These have no 
     * so ESD protection is the responsibility of the designe	     * so ESD protection is the responsibility of the designe
     *								     *
     * user_analog[10:0]  <--->  mprj_io[24:14]			     * user_analog[10:0]  <--->  mprj_io[24:14]
     *								     *
     */								     */
    inout [`ANALOG_PADS-1:0] io_analog,				    inout [`ANALOG_PADS-1:0] io_analog,

    /* Additional power supply ESD clamps, one per analog pad	    /* Additional power supply ESD clamps, one per analog pad
     * high side should be connected to a 3.3-5.5V power supp	     * high side should be connected to a 3.3-5.5V power supp
     * The low side should be connected to ground.		     * The low side should be connected to ground.
     *								     *
     * clamp_high[2:0]   <--->  mprj_io[20:18]			     * clamp_high[2:0]   <--->  mprj_io[20:18]
     * clamp_low[2:0]    <--->  mprj_io[20:18]			     * clamp_low[2:0]    <--->  mprj_io[20:18]
     *								     *
     */								     */
    inout [2:0] io_clamp_high,					    inout [2:0] io_clamp_high,
    inout [2:0] io_clamp_low,					    inout [2:0] io_clamp_low,

    // Independent clock (on independent integer divider)	    // Independent clock (on independent integer divider)
    input   user_clock2,					    input   user_clock2,

    // User maskable interrupt signals				    // User maskable interrupt signals
    output [2:0] user_irq					    output [2:0] user_irq
);								);

// Dummy assignment so that we can take it through the openla	// Dummy assignment so that we can take it through the openla
assign io_out = io_in;						assign io_out = io_in;

// splitting the address space to user address space and debu	// splitting the address space to user address space and debu
// debug address space are the last 2 registers of user_proje	// debug address space are the last 2 registers of user_proje
wire wbs_cyc_i_user;						wire wbs_cyc_i_user;
wire  wbs_ack_o_user;						wire  wbs_ack_o_user;
wire [31:0] wbs_dat_o_user;					wire [31:0] wbs_dat_o_user;

wire  wbs_cyc_i_debug;						wire  wbs_cyc_i_debug;
wire wbs_ack_o_debug;						wire wbs_ack_o_debug;
wire [31:0] wbs_dat_o_debug;					wire [31:0] wbs_dat_o_debug;

assign wbs_cyc_i_user  = (wbs_adr_i[31:3] != 29'h601FFFF) ? w	assign wbs_cyc_i_user  = (wbs_adr_i[31:3] != 29'h601FFFF) ? w
assign wbs_cyc_i_debug = (wbs_adr_i[31:3] == 29'h601FFFF) ? w	assign wbs_cyc_i_debug = (wbs_adr_i[31:3] == 29'h601FFFF) ? w
assign wbs_ack_o = (wbs_adr_i[31:3] == 28'h601FFFF) ? wbs_ack	assign wbs_ack_o = (wbs_adr_i[31:3] == 28'h601FFFF) ? wbs_ack
assign wbs_dat_o = (wbs_adr_i[31:3] == 28'h601FFFF) ? wbs_dat	assign wbs_dat_o = (wbs_adr_i[31:3] == 28'h601FFFF) ? wbs_dat
assign wbs_ack_o_user = 0;					assign wbs_ack_o_user = 0;

debug_regs debug(						debug_regs debug(
    .wb_clk_i(wb_clk_i),					    .wb_clk_i(wb_clk_i),
    .wb_rst_i(wb_rst_i),					    .wb_rst_i(wb_rst_i),
    .wbs_cyc_i(wbs_cyc_i_debug),				    .wbs_cyc_i(wbs_cyc_i_debug),
    .wbs_stb_i(wbs_stb_i),					    .wbs_stb_i(wbs_stb_i),
    .wbs_we_i(wbs_we_i),					    .wbs_we_i(wbs_we_i),
    .wbs_sel_i(wbs_sel_i),					    .wbs_sel_i(wbs_sel_i),
    .wbs_adr_i(wbs_adr_i),					    .wbs_adr_i(wbs_adr_i),
    .wbs_dat_i(wbs_dat_i),					    .wbs_dat_i(wbs_dat_i),
    .wbs_ack_o(wbs_ack_o_debug),				    .wbs_ack_o(wbs_ack_o_debug),
    .wbs_dat_o(wbs_dat_o_debug)					    .wbs_dat_o(wbs_dat_o_debug)
);								);

endmodule	// user_analog_project_wrapper			endmodule	// user_analog_project_wrapper
diff -ry rtl/user_defines.v verilog/rtl/user_defines.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none

`ifndef __USER_DEFINES_H					`ifndef __USER_DEFINES_H
// User GPIO initial configuration parameters			// User GPIO initial configuration parameters
`define __USER_DEFINES_H					`define __USER_DEFINES_H

// Useful GPIO mode values.  These match the names used in de	// Useful GPIO mode values.  These match the names used in de
`define GPIO_MODE_MGMT_STD_INPUT_NOPULL    13'h0403		`define GPIO_MODE_MGMT_STD_INPUT_NOPULL    13'h0403
`define GPIO_MODE_MGMT_STD_INPUT_PULLDOWN  13'h0c01		`define GPIO_MODE_MGMT_STD_INPUT_PULLDOWN  13'h0c01
`define GPIO_MODE_MGMT_STD_INPUT_PULLUP    13'h0801		`define GPIO_MODE_MGMT_STD_INPUT_PULLUP    13'h0801
`define GPIO_MODE_MGMT_STD_OUTPUT          13'h1809		`define GPIO_MODE_MGMT_STD_OUTPUT          13'h1809
`define GPIO_MODE_MGMT_STD_BIDIRECTIONAL   13'h1801		`define GPIO_MODE_MGMT_STD_BIDIRECTIONAL   13'h1801
`define GPIO_MODE_MGMT_STD_ANALOG          13'h000b		`define GPIO_MODE_MGMT_STD_ANALOG          13'h000b

`define GPIO_MODE_USER_STD_INPUT_NOPULL    13'h0402		`define GPIO_MODE_USER_STD_INPUT_NOPULL    13'h0402
`define GPIO_MODE_USER_STD_INPUT_PULLDOWN  13'h0c00		`define GPIO_MODE_USER_STD_INPUT_PULLDOWN  13'h0c00
`define GPIO_MODE_USER_STD_INPUT_PULLUP    13'h0800		`define GPIO_MODE_USER_STD_INPUT_PULLUP    13'h0800
`define GPIO_MODE_USER_STD_OUTPUT          13'h1808		`define GPIO_MODE_USER_STD_OUTPUT          13'h1808
`define GPIO_MODE_USER_STD_BIDIRECTIONAL   13'h1800		`define GPIO_MODE_USER_STD_BIDIRECTIONAL   13'h1800
`define GPIO_MODE_USER_STD_OUT_MONITORED   13'h1802		`define GPIO_MODE_USER_STD_OUT_MONITORED   13'h1802
`define GPIO_MODE_USER_STD_ANALOG          13'h000a		`define GPIO_MODE_USER_STD_ANALOG          13'h000a

// The power-on configuration for GPIO 0 to 4 is fixed and ca	// The power-on configuration for GPIO 0 to 4 is fixed and ca
// modified (allowing the SPI and debug to always be accessib	// modified (allowing the SPI and debug to always be accessib
// overridden by a flash program).				// overridden by a flash program).

// The values below can be any of the standard types defined 	// The values below can be any of the standard types defined 
// or they can be any 13-bit value if the user wants a non-st	// or they can be any 13-bit value if the user wants a non-st
// startup state for the GPIO.  By default, every GPIO from 5	// startup state for the GPIO.  By default, every GPIO from 5
// is set to power up as an input controlled by the managemen	// is set to power up as an input controlled by the managemen
// Users may want to redefine these so that the user project 	// Users may want to redefine these so that the user project 
// up in a state that can be used immediately without dependi	// up in a state that can be used immediately without dependi
// the management SoC to run a startup program to configure t	// the management SoC to run a startup program to configure t

`define USER_CONFIG_GPIO_5_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_5_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_6_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_6_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_7_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_7_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_8_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_8_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_9_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_9_INIT  `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_10_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_10_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_11_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_11_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_12_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_12_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_13_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_13_INIT `GPIO_MODE_MGMT_STD_INPUT_NO

// Configurations of GPIO 14 to 24 are used on caravel but no	// Configurations of GPIO 14 to 24 are used on caravel but no
`define USER_CONFIG_GPIO_14_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_14_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_15_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_15_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_16_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_16_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_17_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_17_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_18_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_18_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_19_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_19_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_20_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_20_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_21_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_21_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_22_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_22_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_23_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_23_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_24_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_24_INIT `GPIO_MODE_MGMT_STD_INPUT_NO

`define USER_CONFIG_GPIO_25_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_25_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_26_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_26_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_27_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_27_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_28_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_28_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_29_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_29_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_30_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_30_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_31_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_31_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_32_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_32_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_33_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_33_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_34_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_34_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_35_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_35_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_36_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_36_INIT `GPIO_MODE_MGMT_STD_INPUT_NO
`define USER_CONFIG_GPIO_37_INIT `GPIO_MODE_MGMT_STD_INPUT_NO	`define USER_CONFIG_GPIO_37_INIT `GPIO_MODE_MGMT_STD_INPUT_NO

`endif // __USER_DEFINES_H					`endif // __USER_DEFINES_H
diff -ry rtl/user_id_programming.v verilog/rtl/user_id_programming.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
// This module represents an unprogrammed mask revision		// This module represents an unprogrammed mask revision
// block that is configured with via programming on the		// block that is configured with via programming on the
// chip top level.  This value is passed to the block as	// chip top level.  This value is passed to the block as
// a parameter							// a parameter

/// sta-blackbox						/// sta-blackbox
module user_id_programming #(					module user_id_programming #(
    parameter USER_PROJECT_ID = 32'h0				    parameter USER_PROJECT_ID = 32'h0
) (								) (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
    inout VPWR,							    inout VPWR,
    inout VGND,							    inout VGND,
`endif								`endif
    output [31:0] mask_rev					    output [31:0] mask_rev
);								);
    wire [31:0] user_proj_id_high;				    wire [31:0] user_proj_id_high;
    wire [31:0] user_proj_id_low;				    wire [31:0] user_proj_id_low;

    // For the mask revision input, use an array of digital c	    // For the mask revision input, use an array of digital c

    dummy_scl180_conb_1 mask_rev_value [31:0] (		      |	    sky130_fd_sc_hd__conb_1 mask_rev_value [31:0] (
`ifndef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
            .VPWR(VPWR),					            .VPWR(VPWR),
            .VPB(VPWR),						            .VPB(VPWR),
            .VNB(VGND),						            .VNB(VGND),
            .VGND(VGND),					            .VGND(VGND),
`endif								`endif
            .HI(user_proj_id_high),				            .HI(user_proj_id_high),
            .LO(user_proj_id_low)				            .LO(user_proj_id_low)
    );								    );

    genvar i;							    genvar i;
    generate							    generate
	for (i = 0; i < 32; i = i+1) begin				for (i = 0; i < 32; i = i+1) begin
	    assign mask_rev[i] = (USER_PROJECT_ID & (32'h01 <		    assign mask_rev[i] = (USER_PROJECT_ID & (32'h01 <
			user_proj_id_high[i] : user_proj_id_l				user_proj_id_high[i] : user_proj_id_l
	end								end
    endgenerate							    endgenerate

endmodule							endmodule
`default_nettype wire						`default_nettype wire
diff -ry rtl/user_id_textblock.v verilog/rtl/user_id_textblock.v
module user_id_textblock ();					module user_id_textblock ();
endmodule							endmodule
diff -ry rtl/__user_project_gpio_example.v verilog/rtl/__user_project_gpio_example.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
/*								/*
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 *								 *
 * user_project_la_example					 * user_project_la_example
 *								 *
 * This is a user project for testing the gpio testing only 	 * This is a user project for testing the gpio testing only 
 *								 *
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 */								 */

module user_project_gpio_example (				module user_project_gpio_example (
    // Wishbone Slave ports (WB MI A)				    // Wishbone Slave ports (WB MI A)
    input wb_clk_i,						    input wb_clk_i,
    input wb_rst_i,						    input wb_rst_i,
    input wbs_stb_i,						    input wbs_stb_i,
    input wbs_cyc_i,						    input wbs_cyc_i,
    input wbs_we_i,						    input wbs_we_i,
    input [3:0] wbs_sel_i,					    input [3:0] wbs_sel_i,
    input [31:0] wbs_dat_i,					    input [31:0] wbs_dat_i,
    input [31:0] wbs_adr_i,					    input [31:0] wbs_adr_i,
    output reg wbs_ack_o,					    output reg wbs_ack_o,
    output reg[31:0] wbs_dat_o,					    output reg[31:0] wbs_dat_o,

    // IOs							    // IOs
    input  [`MPRJ_IO_PADS-1:0] io_in,				    input  [`MPRJ_IO_PADS-1:0] io_in,
    output [`MPRJ_IO_PADS-1:0] io_out,				    output [`MPRJ_IO_PADS-1:0] io_out,
    output [`MPRJ_IO_PADS-1:0] io_oeb				    output [`MPRJ_IO_PADS-1:0] io_oeb

);								);
    reg [31:0] io_l;						    reg [31:0] io_l;
    reg [5:0] io_h;						    reg [5:0] io_h;
    reg [31:0] oeb_l;						    reg [31:0] oeb_l;
    reg [5:0] oeb_h;						    reg [5:0] oeb_h;

     always @(posedge wb_clk_i or posedge wb_rst_i) begin	     always @(posedge wb_clk_i or posedge wb_rst_i) begin
        if (wb_rst_i) begin					        if (wb_rst_i) begin
            io_l <=0;						            io_l <=0;
            io_h <=0;						            io_h <=0;
            oeb_l <=0;						            oeb_l <=0;
            oeb_h <=0;						            oeb_h <=0;
            wbs_dat_o   <=0;					            wbs_dat_o   <=0;
            wbs_ack_o   <=0;					            wbs_ack_o   <=0;

        end else if (wbs_cyc_i && wbs_stb_i && wbs_we_i && !w	        end else if (wbs_cyc_i && wbs_stb_i && wbs_we_i && !w
            // write to io_l					            // write to io_l
            io_l[7:0]    <= ((wbs_adr_i[31:0]==32'h300FFFF0) 	            io_l[7:0]    <= ((wbs_adr_i[31:0]==32'h300FFFF0) 
            io_l[15:8]   <= ((wbs_adr_i[31:0]==32'h300FFFF0) 	            io_l[15:8]   <= ((wbs_adr_i[31:0]==32'h300FFFF0) 
            io_l[23:16]  <= ((wbs_adr_i[31:0]==32'h300FFFF0) 	            io_l[23:16]  <= ((wbs_adr_i[31:0]==32'h300FFFF0) 
            io_l[31:24]  <= ((wbs_adr_i[31:0]==32'h300FFFF0) 	            io_l[31:24]  <= ((wbs_adr_i[31:0]==32'h300FFFF0) 
            // io_h						            // io_h
            io_h[5:0]  <= ((wbs_adr_i[31:0]==32'h300FFFF4) &&	            io_h[5:0]  <= ((wbs_adr_i[31:0]==32'h300FFFF4) &&
            // oeb_l						            // oeb_l
            oeb_l[7:0]    <= ((wbs_adr_i[31:0]==32'h300FFFEC)	            oeb_l[7:0]    <= ((wbs_adr_i[31:0]==32'h300FFFEC)
            oeb_l[15:8]   <= ((wbs_adr_i[31:0]==32'h300FFFEC)	            oeb_l[15:8]   <= ((wbs_adr_i[31:0]==32'h300FFFEC)
            oeb_l[23:16]  <= ((wbs_adr_i[31:0]==32'h300FFFEC)	            oeb_l[23:16]  <= ((wbs_adr_i[31:0]==32'h300FFFEC)
            oeb_l[31:24]  <= ((wbs_adr_i[31:0]==32'h300FFFEC)	            oeb_l[31:24]  <= ((wbs_adr_i[31:0]==32'h300FFFEC)
            // oeb_h						            // oeb_h
            oeb_h[7:0]    <= ((wbs_adr_i[31:0]==32'h300FFFE8)	            oeb_h[7:0]    <= ((wbs_adr_i[31:0]==32'h300FFFE8)
            oeb_h[15:8]   <= ((wbs_adr_i[31:0]==32'h300FFFE8)	            oeb_h[15:8]   <= ((wbs_adr_i[31:0]==32'h300FFFE8)
            oeb_h[23:16]  <= ((wbs_adr_i[31:0]==32'h300FFFE8)	            oeb_h[23:16]  <= ((wbs_adr_i[31:0]==32'h300FFFE8)
            oeb_h[31:24]  <= ((wbs_adr_i[31:0]==32'h300FFFE8)	            oeb_h[31:24]  <= ((wbs_adr_i[31:0]==32'h300FFFE8)

            wbs_ack_o <= 1;					            wbs_ack_o <= 1;
        end else if (wbs_cyc_i && wbs_stb_i && !wbs_we_i && !	        end else if (wbs_cyc_i && wbs_stb_i && !wbs_we_i && !
            wbs_dat_o <= (wbs_adr_i[31:0]==32'h300FFFF0)? io_	            wbs_dat_o <= (wbs_adr_i[31:0]==32'h300FFFF0)? io_
            wbs_ack_o <= 1;					            wbs_ack_o <= 1;
        end else begin 						        end else begin 
            wbs_ack_o <= 0;					            wbs_ack_o <= 0;
            wbs_dat_o <= 0;					            wbs_dat_o <= 0;
        end							        end
    end								    end
   								   
    assign io_out = {io_h,io_l};				    assign io_out = {io_h,io_l};
    assign io_oeb = {oeb_h,oeb_l};				    assign io_oeb = {oeb_h,oeb_l};

endmodule							endmodule

`default_nettype wire						`default_nettype wire
diff -ry rtl/__user_project_la_example.v verilog/rtl/__user_project_la_example.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
/*								/*
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 *								 *
 * user_project_la_example					 * user_project_la_example
 *								 *
 * This is a user project for testing the la only 		 * This is a user project for testing the la only 
 *								 *
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 */								 */

module user_project_la_example (				module user_project_la_example (
    // Logic Analyzer Signals					    // Logic Analyzer Signals
    input  [127:0] la_data_in,					    input  [127:0] la_data_in,
    output [127:0] la_data_out,					    output [127:0] la_data_out,
    input  [127:0] la_oenb					    input  [127:0] la_oenb
);								);
    // LA							    // LA
    assign la_data_out[63:32]  =  la_oenb[31:0]   ?  32'hz: l	    assign la_data_out[63:32]  =  la_oenb[31:0]   ?  32'hz: l
    assign la_data_out[31:0]   =  la_oenb[63:32]  ?  32'hz: l	    assign la_data_out[31:0]   =  la_oenb[63:32]  ?  32'hz: l
    assign la_data_out[127:96] =  la_oenb[95:64]  ?  32'hz: l	    assign la_data_out[127:96] =  la_oenb[95:64]  ?  32'hz: l
    assign la_data_out[95:64]  =  la_oenb[127:96] ?  32'hz: l	    assign la_data_out[95:64]  =  la_oenb[127:96] ?  32'hz: l
    // // LA							    // // LA
    // assign la_data_out[63:32]  =  la_oenb[31:0]   ?  la_da	    // assign la_data_out[63:32]  =  la_oenb[31:0]   ?  la_da
    // assign la_data_out[31:0]   =  la_oenb[63:32]  ?  la_da	    // assign la_data_out[31:0]   =  la_oenb[63:32]  ?  la_da
    // assign la_data_out[127:96] =  la_oenb[95:64]  ?  la_da	    // assign la_data_out[127:96] =  la_oenb[95:64]  ?  la_da
    // assign la_data_out[95:64]  =  la_oenb[127:96] ?  la_da	    // assign la_data_out[95:64]  =  la_oenb[127:96] ?  la_da
   								   

endmodule							endmodule

`default_nettype wire						`default_nettype wire
diff -ry rtl/__user_project_wrapper.v verilog/rtl/__user_project_wrapper.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

`default_nettype wire					      |	`default_nettype none
/*								/*
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 *								 *
 * user_project_wrapper						 * user_project_wrapper
 *								 *
 * This wrapper enumerates all of the pins available to the	 * This wrapper enumerates all of the pins available to the
 * user for the user project.					 * user for the user project.
 *								 *
 * An example user project is provided in this wrapper.  The	 * An example user project is provided in this wrapper.  The
 * example should be removed and replaced with the actual	 * example should be removed and replaced with the actual
 * user project.						 * user project.
 *								 *
 *-----------------------------------------------------------	 *-----------------------------------------------------------
 */								 */
`include "defines.v"					      |
							      >
							      >	// Include by Ritesh Balaji S
`include "debug_regs.v"						`include "debug_regs.v"
							      >
module user_project_wrapper #(					module user_project_wrapper #(
    parameter BITS = 32						    parameter BITS = 32
)(								)(
/*`ifdef USE_POWER_PINS					      |	`ifdef USE_POWER_PINS
    inout vdda1,	// User area 1 3.3V supply		    inout vdda1,	// User area 1 3.3V supply
    inout vdda2,	// User area 2 3.3V supply		    inout vdda2,	// User area 2 3.3V supply
    inout vssa1,	// User area 1 analog ground		    inout vssa1,	// User area 1 analog ground
    inout vssa2,	// User area 2 analog ground		    inout vssa2,	// User area 2 analog ground
    inout vccd1,	// User area 1 1.8V supply		    inout vccd1,	// User area 1 1.8V supply
    inout vccd2,	// User area 2 1.8v supply		    inout vccd2,	// User area 2 1.8v supply
    inout vssd1,	// User area 1 digital ground		    inout vssd1,	// User area 1 digital ground
    inout vssd2,	// User area 2 digital ground		    inout vssd2,	// User area 2 digital ground
`endif*/						      |	`endif

    // Wishbone Slave ports (WB MI A)				    // Wishbone Slave ports (WB MI A)
    input wb_clk_i,						    input wb_clk_i,
    input wb_rst_i,						    input wb_rst_i,
    input wbs_stb_i,						    input wbs_stb_i,
    input wbs_cyc_i,						    input wbs_cyc_i,
    input wbs_we_i,						    input wbs_we_i,
    input [3:0] wbs_sel_i,					    input [3:0] wbs_sel_i,
    input [31:0] wbs_dat_i,					    input [31:0] wbs_dat_i,
    input [31:0] wbs_adr_i,					    input [31:0] wbs_adr_i,
    output wbs_ack_o,						    output wbs_ack_o,
    output [31:0] wbs_dat_o,					    output [31:0] wbs_dat_o,

    // Logic Analyzer Signals					    // Logic Analyzer Signals
    input  [127:0] la_data_in,					    input  [127:0] la_data_in,
    output [127:0] la_data_out,					    output [127:0] la_data_out,
    input  [127:0] la_oenb,					    input  [127:0] la_oenb,

    // IOs							    // IOs
    input  [`MPRJ_IO_PADS-1:0] io_in,				    input  [`MPRJ_IO_PADS-1:0] io_in,
    output [`MPRJ_IO_PADS-1:0] io_out,				    output [`MPRJ_IO_PADS-1:0] io_out,
    output [`MPRJ_IO_PADS-1:0] io_oeb,				    output [`MPRJ_IO_PADS-1:0] io_oeb,

    // Analog (direct connection to GPIO pad---use with cauti	    // Analog (direct connection to GPIO pad---use with cauti
    // Note that analog I/O is not available on the 7 lowest-	    // Note that analog I/O is not available on the 7 lowest-
    // GPIO pads, and so the analog_io indexing is offset fro	    // GPIO pads, and so the analog_io indexing is offset fro
    // GPIO indexing by 7 (also upper 2 GPIOs do not have ana	    // GPIO indexing by 7 (also upper 2 GPIOs do not have ana
    inout [`MPRJ_IO_PADS-10:0] analog_io,			    inout [`MPRJ_IO_PADS-10:0] analog_io,

    // Independent clock (on independent integer divider)	    // Independent clock (on independent integer divider)
    input   user_clock2,					    input   user_clock2,

    // User maskable interrupt signals				    // User maskable interrupt signals
    output [2:0] user_irq					    output [2:0] user_irq
);								);

// Dummy assignments so that we can take it through the openl	// Dummy assignments so that we can take it through the openl
`ifndef GPIO_TESTING						`ifndef GPIO_TESTING
`ifdef SIM							`ifdef SIM
// Needed for running GL simulation				// Needed for running GL simulation
assign io_out = 0;						assign io_out = 0;
assign io_oeb = 0;						assign io_oeb = 0;
`else								`else
assign io_out = io_in;						assign io_out = io_in;
`endif								`endif
`endif // GPIO_TESTING						`endif // GPIO_TESTING

`ifdef LA_TESTING						`ifdef LA_TESTING
user_project_la_example la_testing(la_data_in,la_data_out,la_	user_project_la_example la_testing(la_data_in,la_data_out,la_
`endif								`endif

// splitting the address space to user address space and debu	// splitting the address space to user address space and debu
// debug address space are the last 2 registers of user_proje	// debug address space are the last 2 registers of user_proje
wire wbs_cyc_i_user;						wire wbs_cyc_i_user;
wire  wbs_ack_o_user;						wire  wbs_ack_o_user;
wire [31:0] wbs_dat_o_user;					wire [31:0] wbs_dat_o_user;

wire  wbs_cyc_i_debug;						wire  wbs_cyc_i_debug;
wire wbs_ack_o_debug;						wire wbs_ack_o_debug;
`ifdef GPIO_TESTING						`ifdef GPIO_TESTING
wire wbs_ack_o_gpio;						wire wbs_ack_o_gpio;
wire [31:0] wbs_dat_o_gpio;					wire [31:0] wbs_dat_o_gpio;
`endif								`endif
wire [31:0] wbs_dat_o_debug;					wire [31:0] wbs_dat_o_debug;

// reserve the last 2 regs for debugging registers		// reserve the last 2 regs for debugging registers
// `ifndef GPIO_TESTING						// `ifndef GPIO_TESTING
assign wbs_cyc_i_user  = (wbs_adr_i[31:3] != 29'h601FFFF) ? w	assign wbs_cyc_i_user  = (wbs_adr_i[31:3] != 29'h601FFFF) ? w
assign wbs_cyc_i_debug = (wbs_adr_i[31:3] == 29'h601FFFF) ? w	assign wbs_cyc_i_debug = (wbs_adr_i[31:3] == 29'h601FFFF) ? w
// `endif							// `endif


// `ifndef GPIO_TESTING						// `ifndef GPIO_TESTING
assign wbs_ack_o = (wbs_adr_i[31:3] == 28'h601FFFF) ? wbs_ack	assign wbs_ack_o = (wbs_adr_i[31:3] == 28'h601FFFF) ? wbs_ack
assign wbs_dat_o = (wbs_adr_i[31:3] == 28'h601FFFF) ? wbs_dat	assign wbs_dat_o = (wbs_adr_i[31:3] == 28'h601FFFF) ? wbs_dat
// `endif							// `endif

`ifndef GPIO_TESTING						`ifndef GPIO_TESTING
assign wbs_ack_o_user = 0;					assign wbs_ack_o_user = 0;
`endif								`endif
// // reserve the last 4 regs for debugging registers in case	// // reserve the last 4 regs for debugging registers in case
// `ifdef GPIO_TESTING						// `ifdef GPIO_TESTING
// assign wbs_cyc_i_user  = (wbs_adr_i[31:4] != 28'h300FFFF) 	// assign wbs_cyc_i_user  = (wbs_adr_i[31:4] != 28'h300FFFF) 
// assign wbs_cyc_i_debug = (wbs_adr_i[31:4] == 28'h300FFFF) 	// assign wbs_cyc_i_debug = (wbs_adr_i[31:4] == 28'h300FFFF) 
// `endif							// `endif

// `ifdef GPIO_TESTING						// `ifdef GPIO_TESTING
// assign wbs_ack_o = (wbs_adr_i[31:4] == 28'h300FFFF) ? (wbs	// assign wbs_ack_o = (wbs_adr_i[31:4] == 28'h300FFFF) ? (wbs
// assign wbs_dat_o = (wbs_adr_i[31:4] == 28'h300FFFF) ? (wbs	// assign wbs_dat_o = (wbs_adr_i[31:4] == 28'h300FFFF) ? (wbs
// `endif							// `endif


`ifdef GPIO_TESTING						`ifdef GPIO_TESTING
user_project_gpio_example gpio_testing(				user_project_gpio_example gpio_testing(
    .wb_clk_i(wb_clk_i),					    .wb_clk_i(wb_clk_i),
    .wb_rst_i(wb_rst_i),					    .wb_rst_i(wb_rst_i),
    .wbs_cyc_i(wbs_cyc_i_user),					    .wbs_cyc_i(wbs_cyc_i_user),
    .wbs_stb_i(wbs_stb_i),					    .wbs_stb_i(wbs_stb_i),
    .wbs_we_i(wbs_we_i),					    .wbs_we_i(wbs_we_i),
    .wbs_sel_i(wbs_sel_i),					    .wbs_sel_i(wbs_sel_i),
    .wbs_adr_i(wbs_adr_i),					    .wbs_adr_i(wbs_adr_i),
    .wbs_dat_i(wbs_dat_i),					    .wbs_dat_i(wbs_dat_i),
    .wbs_ack_o(wbs_ack_o_user),					    .wbs_ack_o(wbs_ack_o_user),
    .wbs_dat_o(wbs_dat_o_user), 				    .wbs_dat_o(wbs_dat_o_user), 
    .io_in(io_in),						    .io_in(io_in),
    .io_out(io_out),						    .io_out(io_out),
    .io_oeb(io_oeb));						    .io_oeb(io_oeb));
`endif								`endif

debug_regs debug(						debug_regs debug(
    .wb_clk_i(wb_clk_i),					    .wb_clk_i(wb_clk_i),
    .wb_rst_i(wb_rst_i),					    .wb_rst_i(wb_rst_i),
    .wbs_cyc_i(wbs_cyc_i_debug),				    .wbs_cyc_i(wbs_cyc_i_debug),
    .wbs_stb_i(wbs_stb_i),					    .wbs_stb_i(wbs_stb_i),
    .wbs_we_i(wbs_we_i),					    .wbs_we_i(wbs_we_i),
    .wbs_sel_i(wbs_sel_i),					    .wbs_sel_i(wbs_sel_i),
    .wbs_adr_i(wbs_adr_i),					    .wbs_adr_i(wbs_adr_i),
    .wbs_dat_i(wbs_dat_i),					    .wbs_dat_i(wbs_dat_i),
    .wbs_ack_o(wbs_ack_o_debug),				    .wbs_ack_o(wbs_ack_o_debug),
    .wbs_dat_o(wbs_dat_o_debug)					    .wbs_dat_o(wbs_dat_o_debug)
);								);

endmodule	// user_project_wrapper				endmodule	// user_project_wrapper
Only in rtl: VexRiscv_MinDebugCache.v
Only in rtl: vsdcaravel.v
diff -ry rtl/xres_buf.v verilog/rtl/xres_buf.v
// SPDX-FileCopyrightText: 2025 Efabless Corporation/VSD      |	// SPDX-FileCopyrightText: 2020 Efabless Corporation
//								//
// Licensed under the Apache License, Version 2.0 (the "Licen	// Licensed under the Apache License, Version 2.0 (the "Licen
// you may not use this file except in compliance with the Li	// you may not use this file except in compliance with the Li
// You may obtain a copy of the License at			// You may obtain a copy of the License at
//								//
//      http://www.apache.org/licenses/LICENSE-2.0		//      http://www.apache.org/licenses/LICENSE-2.0
//								//
// Unless required by applicable law or agreed to in writing,	// Unless required by applicable law or agreed to in writing,
// distributed under the License is distributed on an "AS IS"	// distributed under the License is distributed on an "AS IS"
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expre
// See the License for the specific language governing permis	// See the License for the specific language governing permis
// limitations under the License.				// limitations under the License.
// SPDX-License-Identifier: Apache-2.0				// SPDX-License-Identifier: Apache-2.0

// Module xres_buf is a level-shift buffer between the xres p	// Module xres_buf is a level-shift buffer between the xres p
// digital reset) and the caravel chip core.  The xres pad ou	// digital reset) and the caravel chip core.  The xres pad ou
// the 3.3V domain while the signal goes to the digital circu	// the 3.3V domain while the signal goes to the digital circu
// 1.8V domain.							// 1.8V domain.

module xres_buf (						module xres_buf (
	X    ,								X    ,
	A    ,								A    ,
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
	VPWR ,								VPWR ,
	VGND ,								VGND ,
	LVPWR,								LVPWR,
	LVGND,								LVGND,
`endif								`endif
);								);

inout X    ;						      |	output X    ;
inout A    ;						      |	input  A    ;
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
inout  VPWR ;							inout  VPWR ;
inout  VGND ;							inout  VGND ;
inout  LVPWR;							inout  LVPWR;
inout  LVGND;							inout  LVGND;
`endif								`endif

/*sky130_fd_sc_hvl__lsbufhv2lv_1 lvlshiftdown (		      |	sky130_fd_sc_hvl__lsbufhv2lv_1 lvlshiftdown (
`ifdef USE_POWER_PINS						`ifdef USE_POWER_PINS
	.VPWR(VPWR),							.VPWR(VPWR),
	.VPB(VPWR),							.VPB(VPWR),

	.LVPWR(LVPWR),							.LVPWR(LVPWR),

	.VNB(VGND),							.VNB(VGND),
	.VGND(VGND),							.VGND(VGND),
`endif								`endif
	.A(A),								.A(A),
	.X(X)								.X(X)
);								);
							      <
*/							      <
// the SCL180 pdk has inbuilt level-shift in the I/O pads     <
// HIGH-TO-LOW						      <
assign A = X;						      <

endmodule							endmodule
